import{s as Rt,o as Wm,k as qm,l as Hm,a as Gm,e as Ne,t as Km,m as Gn,d as Xm,p as Ym,i as Zm,q as Jm,_ as Qm}from"./e.js";import{c as Kt}from"./7.js";import{g as eg,m as tg,a as ng}from"./t.js";import{i as Xn}from"./2.js";import{c as Mt}from"./v.js";import"./3.js";import"./1.js";import"./0.js";import"./b.js";import"./$5.js";function rg(t,e){return e.forEach(function(n){n&&typeof n!="string"&&!Array.isArray(n)&&Object.keys(n).forEach(function(r){if(r!=="default"&&!(r in t)){var s=Object.getOwnPropertyDescriptor(n,r);Object.defineProperty(t,r,s.get?s:{enumerable:!0,get:function(){return n[r]}})}})}),Object.freeze(Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}))}var sg=t=>new Promise(e=>setTimeout(e,t)),ag=t=>{};const og=1e-7,ig=1e-4;class ug{constructor(e,n){this.backend=e,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,n){this.dataIdsCount++,this.data.set(e,n)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Bu{refCount(e){return ht("refCount")}incRef(e){return ht("incRef")}timerAvailable(){return!0}time(e){return ht("time")}read(e){return ht("read")}readSync(e){return ht("readSync")}readToGPU(e,n){return ht("readToGPU")}numDataIds(){return ht("numDataIds")}disposeData(e,n){return ht("disposeData")}write(e,n,r){return ht("write")}move(e,n,r,s,a){return ht("move")}memory(){return ht("memory")}floatPrecision(){return ht("floatPrecision")}epsilon(){return this.floatPrecision()===32?og:ig}dispose(){return ht("dispose")}}function ht(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Lu(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,Ns(t,e,n)}function lg(t,e){if(t.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${t.length}Second array length was ${e.length}`);let n=t.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,Ns(t,n,r),Ns(e,n,r)}function $r(t,e,n){return Math.max(t,Math.min(e,n))}function cg(t){return t%2===0?t:t+1}function Ns(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function hg(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function fg(t,e){const n=Math.random();return e*n+(1-n)*t}function pg(t,e){let n=0;for(let r=0;r<t.length;r++){const s=Number(t[r])-Number(e[r]);n+=s*s}return n}function S(t,e){if(!t)throw new Error(typeof e=="string"?e:e())}function Qe(t,e,n=""){S(jt(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function Ln(t){S(t!=null,()=>"The input to the tensor constructor must be a non-null value.")}function An(t,e=[],n=!1){if(e==null&&(e=[]),Array.isArray(t)||We(t)&&!n)for(let r=0;r<t.length;++r)An(t[r],e,n);else e.push(t);return e}function Ae(t){if(t.length===0)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function dg(t){return t.length===0}function jt(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function rr(t){return t%1===0}function mg(t){if(Math.tanh!=null)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const e=Math.exp(2*t);return(e-1)/(e+1)}}function gg(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function yg(t){const e=new Uint32Array(t);for(let n=0;n<t;++n)e[n]=n;return Lu(e),e}function _r(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function bg(t,e=r=>0,n){return new Promise((r,s)=>{let a=0;const o=()=>{if(t()){r();return}a++;const i=e(a);if(n!=null&&a>=n){s();return}setTimeout(o,i)};o()})}function wg(t,e){let n=1,r=-1;for(let a=0;a<t.length;++a)if(t[a]>=0)n*=t[a];else if(t[a]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(t[a]<0)throw Error(`Shapes can not be < 0. Found ${t[a]} at dim ${a}`);if(r===-1){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(n===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const s=t.slice();return s[r]=e/n,s}function zr(t,e){const n=e.length;return t=t==null?e.map((r,s)=>s):[].concat(t),S(t.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),S(t.every(r=>rr(r)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(r=>r<0?n+r:r)}function Mu(t,e){const n=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,a=e==null||s?null:zr(e,t).sort();let o=0;for(let i=0;i<t.length;++i){if(a!=null){if(a[o]===i&&t[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${t[i]}' is not 1`);(a[o]==null||a[o]>i)&&t[i]===1&&(n.push(t[i]),r.push(i)),a[o]<=i&&o++}t[i]!==1&&(n.push(t[i]),r.push(i))}return{newShape:n,keptDims:r}}function zu(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else throw new Error(`Unknown data type ${t}`);return n}function Vu(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else if(t==="string")n=new Array(e);else throw new Error(`Unknown data type ${t}`);return n}function ju(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function Uu(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function vg(t,e){return!(e==="complex64"||e==="float32"&&t!=="complex64"||e==="int32"&&t!=="float32"&&t!=="complex64"||e==="bool"&&t==="bool")}function We(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}function Aa(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function Wu(t){if(t==null)return 0;let e=0;return t.forEach(n=>e+=n.length),e}function on(t){return typeof t=="string"||t instanceof String}function qu(t){return typeof t=="boolean"}function Hu(t){return typeof t=="number"}function Bs(t){return Array.isArray(t)?Bs(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":Hu(t)?"float32":on(t)?"string":qu(t)?"bool":"float32"}function hn(t){return!!(t&&t.constructor&&t.call&&t.apply)}function Ts(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function hr(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function Gu(t,e,n,r=!1){const s=new Array;if(e.length===1){const a=e[0]*(r?2:1);for(let o=0;o<a;o++)s[o]=n[t+o]}else{const a=e[0],o=e.slice(1),i=o.reduce((u,l)=>u*l)*(r?2:1);for(let u=0;u<a;u++)s[u]=Gu(t+u*i,o,n,r)}return s}function kn(t,e,n=!1){if(t.length===0)return e[0];const r=t.reduce((s,a)=>s*a)*(n?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return Gu(0,t,e,n)}function ho(t,e){const n=Ls(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function Ls(t,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function Sg(t,e){const n=t.reduce((r,s)=>r*s,1);if(e==null||e==="float32")return kn(t,new Float32Array(n));if(e==="int32")return kn(t,new Int32Array(n));if(e==="bool")return kn(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function fo(t){t.forEach(e=>{S(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function Ng(t,e,n){if(e===0)return 0;if(e===1)return t[0];let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=n[s]*t[s];return r}function Tg(t,e,n){if(e===0)return[];if(e===1)return[t];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(t/n[s]),t-=r[s]*n[s];return r[r.length-1]=t,r}function In(t){return t&&t.then&&typeof t.then=="function"}const qi="tfjsflags";class Ku{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Eg,this.populateURLFlags()}setPlatform(e,n){this.platform!=null&&(re().getBool("IS_TEST")||re().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=n}registerFlag(e,n,r){if(this.flagRegistry[e]={evaluationFn:n,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];re().getBool("IS_TEST")||re().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const n=this.evaluateFlag(e);if(In(n))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=n,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,n){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=n,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(n)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);qi in e&&e[qi].split(",").forEach(r=>{const[s,a]=r.split(":");this.urlFlags[s]=_g(s,a)})}}function Eg(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(kg(e,r[0],r[1]),r.join("="))),e}function kg(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function _g(t,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}function re(){return po}let po=null;function xg(t){po=t}let ya;function Xu(){if(ya==null){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else if(typeof self<"u")t=self;else throw new Error("Could not find a global object");ya=t}return ya}function $g(){const t=Xu();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function mo(t,e){const n=$g();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const Yu="Abs",Zu="Acos",Ju="Acosh",go="Add",Qu="AddN",el="All",tl="Any",nl="ArgMax",rl="ArgMin",sl="Asin",al="Asinh",ol="Atan",il="Atanh",ul="Atan2",ll="AvgPool",Ag="AvgPoolGrad",cl="AvgPool3D",Ig="AvgPool3DGrad",hl="BatchMatMul",fl="BatchToSpaceND",pl="Bincount",Og="BroadcastTo",dl="BroadcastArgs",yo="Cast",ml="Ceil",gl="ClipByValue",yl="Complex",bl="ComplexAbs",wl="Concat",vl="Conv2D",Sl="Conv2DBackpropFilter",Nl="Conv2DBackpropInput",Tl="Conv3D",Dg="Conv3DBackpropFilterV2",El="Conv3DBackpropInputV2",kl="Cos",_l="Cosh",xl="Cumprod",$l="Cumsum",Al="CropAndResize",Il="DenseBincount",Ol="DepthToSpace",Dl="DepthwiseConv2dNative",Fl="DepthwiseConv2dNativeBackpropFilter",Cl="DepthwiseConv2dNativeBackpropInput",Pl="Diag",Rl="Dilation2D",Fg="Dilation2DBackpropInput",Cg="Dilation2DBackpropFilter",Bl="RealDiv",Ll="Einsum",Ml="Elu",Pg="EluGrad",zl="Erf",Vl="Equal",jl="Exp",Ul="ExpandDims",Wl="Expm1",ql="FFT",Hl="Fill",Gl="FlipLeftRight",Kl="Floor",Xl="FloorDiv",Yl="FusedBatchNorm",Zl="GatherV2",Jl="GatherNd",Ql="Greater",ec="GreaterEqual",bo="Identity",tc="IFFT",nc="Imag",rc="IsFinite",sc="IsInf",ac="IsNan",oc="LeakyRelu",ic="Less",uc="LessEqual",lc="LinSpace",cc="Log",hc="Log1p",fc="LogicalAnd",pc="LogicalNot",dc="LogicalOr",Rg="LogicalXor",Bg="LogSoftmax",Lg="LowerBound",mc="LRN",Mg="LRNGrad",gc="Max",yc="Maximum",bc="MaxPool",zg="MaxPoolGrad",wc="MaxPool3D",Vg="MaxPool3DGrad",vc="MaxPoolWithArgmax",Sc="Mean",Nc="Min",Tc="Minimum",Ec="MirrorPad",kc="Mod",_c="Multinomial",xc="Multiply",$c="Neg",Ac="NotEqual",Ic="NonMaxSuppressionV3",Oc="NonMaxSuppressionV4",Dc="NonMaxSuppressionV5",Fc="OnesLike",Cc="OneHot",Pc="Pack",Rc="PadV2",jg="Pool",Bc="Pow",Lc="Prelu",Mc="Prod",zc="Range",Vc="Real",jc="Reciprocal",Uc="Relu",Wc="Reshape",qc="ResizeNearestNeighbor",Ug="ResizeNearestNeighborGrad",Hc="ResizeBilinear",Wg="ResizeBilinearGrad",Gc="Relu6",Kc="Reverse",Xc="Round",Yc="Rsqrt",Zc="ScatterNd",Jc="SearchSorted",Qc="Select",eh="Selu",th="Slice",nh="Sin",rh="Sinh",sh="Sign",ah="Sigmoid",oh="Softplus",ih="Sqrt",uh="Sum",lh="SpaceToBatchND",ch="SplitV",hh="Softmax",fh="SparseFillEmptyRows",ph="SparseReshape",dh="SparseSegmentMean",mh="SparseSegmentSum",gh="SparseToDense",yh="SquaredDifference",qg="Square",bh="StridedSlice",wh="StringNGrams",vh="StringSplit",Sh="StringToHashBucketFast",Nh="Sub",Th="Tan",Eh="Tanh",wo="Tile",kh="TopK",_h="Transform",ys="Transpose",xh="Unique",$h="Unpack",Ah="UnsortedSegmentSum",Hg="UpperBound",Ih="ZerosLike",Oh="Step",Ia="FromPixels",Dh="RotateWithOffset",Oa="_FusedMatMul",Da="FusedConv2D",Fa="FusedDepthwiseConv2D";function sn(...t){re().getBool("IS_TEST")||re().getBool("PROD")||console.warn(...t)}function Gg(...t){re().getBool("IS_TEST")||re().getBool("PROD")||console.log(...t)}const sr=mo("kernelRegistry",()=>new Map),Ar=mo("gradRegistry",()=>new Map);function Es(t,e){const n=vo(t,e);return sr.get(n)}function Ca(t){return Ar.get(t)}function ks(t){const e=sr.entries(),n=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[a,o]=s,[i]=a.split("_");i===t&&n.push(o)}return n}function Fh(t){const{kernelName:e,backendName:n}=t,r=vo(e,n);sr.has(r)&&sn(`The kernel '${e}' for backend '${n}' is already registered`),sr.set(r,t)}function Kg(t){const{kernelName:e}=t;Ar.has(e)&&re().getBool("DEBUG")&&sn(`Overriding the gradient for '${e}'`),Ar.set(e,t)}function Xg(t,e){const n=vo(t,e);if(!sr.has(n))throw new Error(`The kernel '${t}' for backend '${e}' is not registered`);sr.delete(n)}function Yg(t){if(!Ar.has(t))throw new Error(`The gradient '${t}' for backend is not registered`);Ar.delete(t)}function Zg(t,e){ks(t).forEach(r=>{const s=Object.assign({},r,{backendName:e});Fh(s)})}function vo(t,e){return`${e}_${t}`}var Pa=Ie,mt=null;try{mt=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Ie(t,e,n){this.low=t|0,this.high=e|0,this.unsigned=!!n}Ie.prototype.__isLong__;Object.defineProperty(Ie.prototype,"__isLong__",{value:!0});function lt(t){return(t&&t.__isLong__)===!0}Ie.isLong=lt;var Hi={},Gi={};function Mn(t,e){var n,r,s;return e?(t>>>=0,(s=0<=t&&t<256)&&(r=Gi[t],r)?r:(n=Oe(t,(t|0)<0?-1:0,!0),s&&(Gi[t]=n),n)):(t|=0,(s=-128<=t&&t<128)&&(r=Hi[t],r)?r:(n=Oe(t,t<0?-1:0,!1),s&&(Hi[t]=n),n))}Ie.fromInt=Mn;function gt(t,e){if(isNaN(t))return e?Tn:yt;if(e){if(t<0)return Tn;if(t>=Ch)return Bh}else{if(t<=-Xi)return it;if(t+1>=Xi)return Rh}return t<0?gt(-t,e).neg():Oe(t%ar|0,t/ar|0,e)}Ie.fromNumber=gt;function Oe(t,e,n){return new Ie(t,e,n)}Ie.fromBits=Oe;var _s=Math.pow;function So(t,e,n){if(t.length===0)throw Error("empty string");if(t==="NaN"||t==="Infinity"||t==="+Infinity"||t==="-Infinity")return yt;if(typeof e=="number"?(n=e,e=!1):e=!!e,n=n||10,n<2||36<n)throw RangeError("radix");var r;if((r=t.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return So(t.substring(1),e,n).neg();for(var s=gt(_s(n,8)),a=yt,o=0;o<t.length;o+=8){var i=Math.min(8,t.length-o),u=parseInt(t.substring(o,o+i),n);if(i<8){var l=gt(_s(n,i));a=a.mul(l).add(gt(u))}else a=a.mul(s),a=a.add(gt(u))}return a.unsigned=e,a}Ie.fromString=So;function Ft(t,e){return typeof t=="number"?gt(t,e):typeof t=="string"?So(t,e):Oe(t.low,t.high,typeof e=="boolean"?e:t.unsigned)}Ie.fromValue=Ft;var Ki=1<<16,Jg=1<<24,ar=Ki*Ki,Ch=ar*ar,Xi=Ch/2,Yi=Mn(Jg),yt=Mn(0);Ie.ZERO=yt;var Tn=Mn(0,!0);Ie.UZERO=Tn;var Qn=Mn(1);Ie.ONE=Qn;var Ph=Mn(1,!0);Ie.UONE=Ph;var Ra=Mn(-1);Ie.NEG_ONE=Ra;var Rh=Oe(-1,2147483647,!1);Ie.MAX_VALUE=Rh;var Bh=Oe(-1,-1,!0);Ie.MAX_UNSIGNED_VALUE=Bh;var it=Oe(0,-2147483648,!1);Ie.MIN_VALUE=it;var W=Ie.prototype;W.toInt=function(){return this.unsigned?this.low>>>0:this.low};W.toNumber=function(){return this.unsigned?(this.high>>>0)*ar+(this.low>>>0):this.high*ar+(this.low>>>0)};W.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(it)){var n=gt(e),r=this.div(n),s=r.mul(n).sub(this);return r.toString(e)+s.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var a=gt(_s(e,6),this.unsigned),o=this,i="";;){var u=o.div(a),l=o.sub(u.mul(a)).toInt()>>>0,c=l.toString(e);if(o=u,o.isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}};W.getHighBits=function(){return this.high};W.getHighBitsUnsigned=function(){return this.high>>>0};W.getLowBits=function(){return this.low};W.getLowBitsUnsigned=function(){return this.low>>>0};W.getNumBitsAbs=function(){if(this.isNegative())return this.eq(it)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,n=31;n>0&&(e&1<<n)==0;n--);return this.high!=0?n+33:n+1};W.isZero=function(){return this.high===0&&this.low===0};W.eqz=W.isZero;W.isNegative=function(){return!this.unsigned&&this.high<0};W.isPositive=function(){return this.unsigned||this.high>=0};W.isOdd=function(){return(this.low&1)===1};W.isEven=function(){return(this.low&1)===0};W.equals=function(e){return lt(e)||(e=Ft(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};W.eq=W.equals;W.notEquals=function(e){return!this.eq(e)};W.neq=W.notEquals;W.ne=W.notEquals;W.lessThan=function(e){return this.comp(e)<0};W.lt=W.lessThan;W.lessThanOrEqual=function(e){return this.comp(e)<=0};W.lte=W.lessThanOrEqual;W.le=W.lessThanOrEqual;W.greaterThan=function(e){return this.comp(e)>0};W.gt=W.greaterThan;W.greaterThanOrEqual=function(e){return this.comp(e)>=0};W.gte=W.greaterThanOrEqual;W.ge=W.greaterThanOrEqual;W.compare=function(e){if(lt(e)||(e=Ft(e)),this.eq(e))return 0;var n=this.isNegative(),r=e.isNegative();return n&&!r?-1:!n&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};W.comp=W.compare;W.negate=function(){return!this.unsigned&&this.eq(it)?it:this.not().add(Qn)};W.neg=W.negate;W.add=function(e){lt(e)||(e=Ft(e));var n=this.high>>>16,r=this.high&65535,s=this.low>>>16,a=this.low&65535,o=e.high>>>16,i=e.high&65535,u=e.low>>>16,l=e.low&65535,c=0,h=0,p=0,d=0;return d+=a+l,p+=d>>>16,d&=65535,p+=s+u,h+=p>>>16,p&=65535,h+=r+i,c+=h>>>16,h&=65535,c+=n+o,c&=65535,Oe(p<<16|d,c<<16|h,this.unsigned)};W.subtract=function(e){return lt(e)||(e=Ft(e)),this.add(e.neg())};W.sub=W.subtract;W.multiply=function(e){if(this.isZero())return yt;if(lt(e)||(e=Ft(e)),mt){var n=mt.mul(this.low,this.high,e.low,e.high);return Oe(n,mt.get_high(),this.unsigned)}if(e.isZero())return yt;if(this.eq(it))return e.isOdd()?it:yt;if(e.eq(it))return this.isOdd()?it:yt;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(Yi)&&e.lt(Yi))return gt(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,s=this.high&65535,a=this.low>>>16,o=this.low&65535,i=e.high>>>16,u=e.high&65535,l=e.low>>>16,c=e.low&65535,h=0,p=0,d=0,b=0;return b+=o*c,d+=b>>>16,b&=65535,d+=a*c,p+=d>>>16,d&=65535,d+=o*l,p+=d>>>16,d&=65535,p+=s*c,h+=p>>>16,p&=65535,p+=a*l,h+=p>>>16,p&=65535,p+=o*u,h+=p>>>16,p&=65535,h+=r*c+s*l+a*u+o*i,h&=65535,Oe(d<<16|b,h<<16|p,this.unsigned)};W.mul=W.multiply;W.divide=function(e){if(lt(e)||(e=Ft(e)),e.isZero())throw Error("division by zero");if(mt){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var n=(this.unsigned?mt.div_u:mt.div_s)(this.low,this.high,e.low,e.high);return Oe(n,mt.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Tn:yt;var r,s,a;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Tn;if(e.gt(this.shru(1)))return Ph;a=Tn}else{if(this.eq(it)){if(e.eq(Qn)||e.eq(Ra))return it;if(e.eq(it))return Qn;var o=this.shr(1);return r=o.div(e).shl(1),r.eq(yt)?e.isNegative()?Qn:Ra:(s=this.sub(e.mul(r)),a=r.add(s.div(e)),a)}else if(e.eq(it))return this.unsigned?Tn:yt;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=yt}for(s=this;s.gte(e);){r=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(r)/Math.LN2),u=i<=48?1:_s(2,i-48),l=gt(r),c=l.mul(e);c.isNegative()||c.gt(s);)r-=u,l=gt(r,this.unsigned),c=l.mul(e);l.isZero()&&(l=Qn),a=a.add(l),s=s.sub(c)}return a};W.div=W.divide;W.modulo=function(e){if(lt(e)||(e=Ft(e)),mt){var n=(this.unsigned?mt.rem_u:mt.rem_s)(this.low,this.high,e.low,e.high);return Oe(n,mt.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};W.mod=W.modulo;W.rem=W.modulo;W.not=function(){return Oe(~this.low,~this.high,this.unsigned)};W.and=function(e){return lt(e)||(e=Ft(e)),Oe(this.low&e.low,this.high&e.high,this.unsigned)};W.or=function(e){return lt(e)||(e=Ft(e)),Oe(this.low|e.low,this.high|e.high,this.unsigned)};W.xor=function(e){return lt(e)||(e=Ft(e)),Oe(this.low^e.low,this.high^e.high,this.unsigned)};W.shiftLeft=function(e){return lt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Oe(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Oe(0,this.low<<e-32,this.unsigned)};W.shl=W.shiftLeft;W.shiftRight=function(e){return lt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Oe(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Oe(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};W.shr=W.shiftRight;W.shiftRightUnsigned=function(e){if(lt(e)&&(e=e.toInt()),e&=63,e===0)return this;var n=this.high;if(e<32){var r=this.low;return Oe(r>>>e|n<<32-e,n>>>e,this.unsigned)}else return e===32?Oe(n,0,this.unsigned):Oe(n>>>e-32,0,this.unsigned)};W.shru=W.shiftRightUnsigned;W.shr_u=W.shiftRightUnsigned;W.toSigned=function(){return this.unsigned?Oe(this.low,this.high,!1):this};W.toUnsigned=function(){return this.unsigned?this:Oe(this.low,this.high,!0)};W.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};W.toBytesLE=function(){var e=this.high,n=this.low;return[n&255,n>>>8&255,n>>>16&255,n>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};W.toBytesBE=function(){var e=this.high,n=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,n>>>24,n>>>16&255,n>>>8&255,n&255]};Ie.fromBytes=function(e,n,r){return r?Ie.fromBytesLE(e,n):Ie.fromBytesBE(e,n)};Ie.fromBytesLE=function(e,n){return new Ie(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,n)};Ie.fromBytesBE=function(e,n){return new Ie(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],n)};var Qg=rg({__proto__:null,default:Pa},[Pa]);const Nn=Pa||Qg;function Vr(t){return Nn.fromString(t,!0,16)}const Lh=Vr("c3a5c85c97cb3127"),Sn=Vr("b492b66fbe98f273"),Ye=Vr("9ae16a3b2f90404f");function Ba(t){return t.xor(t.shru(47))}function Mh(t,e,n){const r=t.slice(e,e+n);return Nn.fromBytes(Array.from(r),!0,!0)}function xe(t,e){return Mh(t,e,8)}function Zi(t,e){return Mh(t,e,4)}function Ve(t,e){return e===0?t:t.shru(e).or(t.shl(64-e))}function cn(t,e,n=Vr("9ddfea08eb382d69")){let r=t.xor(e).mul(n);r=r.xor(r.shru(47));let s=e.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function ey(t,e,n,r,s,a){s=s.add(t),a=Ve(a.add(s).add(r),21);const o=s;return s=s.add(e),s=s.add(n),a=a.add(Ve(s,44)),[s.add(r),a.add(o)]}function is(t,e,n,r){return ey(xe(t,e),xe(t,e+8),xe(t,e+16),xe(t,e+24),n,r)}function ty(t,e=t.length){if(e>=8){const n=Ye.add(e*2),r=xe(t,0).add(Ye),s=xe(t,e-8),a=Ve(s,37).mul(n).add(r),o=Ve(r,25).add(s).mul(n);return cn(a,o,n)}if(e>=4){const n=Ye.add(e*2),r=Zi(t,0);return cn(r.shl(3).add(e),Zi(t,e-4),n)}if(e>0){const n=t[0],r=t[e>>1],s=t[e-1],a=n+(r<<8),o=e+(s<<2);return Ba(Ye.mul(a).xor(Lh.mul(o))).mul(Ye)}return Ye}function ny(t,e=t.length){const n=Ye.add(e*2),r=xe(t,0).mul(Sn),s=xe(t,8),a=xe(t,e-8).mul(n),o=xe(t,e-16).mul(Ye);return cn(Ve(r.add(s),43).add(Ve(a,30)).add(o),r.add(Ve(s.add(Ye),18)).add(a),n)}function ry(t,e=t.length){const n=Ye.add(e*2),r=xe(t,0).mul(Ye),s=xe(t,8),a=xe(t,e-8).mul(n),o=xe(t,e-16).mul(Ye),i=Ve(r.add(s),43).add(Ve(a,30)).add(o),u=cn(i,r.add(Ve(s.add(Ye),18)).add(a),n),l=xe(t,16).mul(n),c=xe(t,24),h=i.add(xe(t,e-32)).mul(n),p=u.add(xe(t,e-24)).mul(n);return cn(Ve(l.add(c),43).add(Ve(h,30)).add(p),l.add(Ve(c.add(r),18)).add(h),n)}function sy(t,e=t.length){const n=Nn.fromNumber(81,!0);if(e<=32)return e<=16?ty(t,e):ny(t,e);if(e<=64)return ry(t,e);let r=n,s=n.mul(Sn).add(113),a=Ba(s.mul(Ye).add(113)).mul(Ye),o=[Nn.UZERO,Nn.UZERO],i=[Nn.UZERO,Nn.UZERO];r=r.mul(Ye).add(xe(t,0));let u=0;const l=(e-1>>6)*64,c=l+(e-1&63)-63;do r=Ve(r.add(s).add(o[0]).add(xe(t,u+8)),37).mul(Sn),s=Ve(s.add(o[1]).add(xe(t,u+48)),42).mul(Sn),r=r.xor(i[1]),s=s.add(o[0]).add(xe(t,u+40)),a=Ve(a.add(i[0]),33).mul(Sn),o=is(t,u,o[1].mul(Sn),r.add(i[0])),i=is(t,u+32,a.add(i[1]),s.add(xe(t,u+16))),[a,r]=[r,a],u+=64;while(u!==l);const h=Sn.add(a.and(255).shl(1));return u=c,i[0]=i[0].add(e-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),r=Ve(r.add(s).add(o[0]).add(xe(t,u+8)),37).mul(h),s=Ve(s.add(o[1]).add(xe(t,u+48)),42).mul(h),r=r.xor(i[1].mul(9)),s=s.add(o[0].mul(9).add(xe(t,u+40))),a=Ve(a.add(i[0]),33).mul(h),o=is(t,u,o[1].mul(h),r.add(i[0])),i=is(t,u+32,a.add(i[1]),s.add(xe(t,u+16))),[a,r]=[r,a],cn(cn(o[0],i[0],h).add(Ba(s).mul(Lh)).add(a),cn(o[1],i[1],h).add(r),h)}function ay(t,e){return e==="string"?jr(t):Ms([t],e)}function oy(t,e){return t instanceof Float32Array&&e==="float32"||t instanceof Int32Array&&e==="int32"||t instanceof Uint8Array&&e==="bool"}function Ms(t,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=An(t)),re().getBool("DEBUG")&&ju(t,e),oy(t,e))return t;if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool"){const n=new Uint8Array(t.length);for(let r=0;r<n.length;++r)Math.round(t[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${e}`)}function Ir(){return re().platform.now()}function iy(t,e){return re().platform.fetch(t,e)}function jr(t,e="utf-8"){return e=e||"utf-8",re().platform.encode(t,e)}function xs(t,e="utf-8"){return e=e||"utf-8",re().platform.decode(t,e)}var uy=Object.freeze(Object.defineProperty({__proto__:null,createScalarValue:ay,toTypedArray:Ms,now:Ir,fetch:iy,encodeString:jr,decodeString:xs,shuffle:Lu,shuffleCombo:lg,clamp:$r,nearestLargerEven:cg,swap:Ns,sum:hg,randUniform:fg,distSquared:pg,assert:S,assertShapesMatch:Qe,assertNonNull:Ln,flatten:An,sizeFromShape:Ae,isScalarShape:dg,arraysEqual:jt,isInt:rr,tanh:mg,sizeToSquarishShape:gg,createShuffledIndices:yg,rightPad:_r,repeatedTry:bg,inferFromImplicitShape:wg,parseAxisParam:zr,squeezeShape:Mu,getTypedArrayFromDType:zu,getArrayFromDType:Vu,checkConversionForErrors:ju,isValidDtype:Uu,hasEncodingLoss:vg,isTypedArray:We,bytesPerElement:Aa,bytesFromStringArray:Wu,isString:on,isBoolean:qu,isNumber:Hu,inferDtype:Bs,isFunction:hn,nearestDivisor:Ts,computeStrides:hr,toNestedArray:kn,makeOnesTypedArray:ho,makeZerosTypedArray:Ls,makeZerosNestedTypedArray:Sg,assertNonNegativeIntegerDimensions:fo,locToIndex:Ng,indexToLoc:Tg,isPromise:In,hexToLong:Vr,fingerPrint64:sy},Symbol.toStringTag,{value:"Module"}));class ly{constructor(e,n){this.backendTimer=e,this.logger=n,n==null&&(this.logger=new hy)}profileKernel(e,n,r){let s;const a=()=>{s=r()};let o;const i=Ir();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(a);else{a();for(const l of s)l.dataSync();o=Promise.resolve({kernelMs:Ir()-i})}if(re().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<s.length;l++){const c=s[l];c.data().then(h=>{cy(h,c.dtype,e)})}return{kernelName:e,outputs:s,inputs:n,timeMs:o.then(l=>l.kernelMs),extraInfo:o.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:n,outputs:r,timeMs:s,inputs:a,extraInfo:o}=e;r.forEach(i=>{Promise.all([i.data(),s,o]).then(u=>{this.logger.logKernelProfile(n,i,u[0],u[1],a,u[2])})})}}function cy(t,e,n){if(e!=="float32")return!1;for(let r=0;r<t.length;r++){const s=t[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}class hy{logKernelProfile(e,n,r,s,a,o){const i=typeof s=="number"?_r(`${s}ms`,9):s.error,u=_r(e,25),l=n.rank,c=n.size,h=_r(n.shape.toString(),14);let p="";for(const d in a){const b=a[d];if(b!=null){const v=b.shape||n.shape,N=v.length;p+=`${d}: ${N}D ${N>0?v:""} `}}console.log(`%c${u}	%c${i}	%c${l}D ${h}	%c${c}	%c${p}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function fy(t,e,n){const r={},s={};for(let u=0;u<e.length;u++)r[e[u].id]=!0;for(let u=0;u<t.length;u++){const l=t[u],c=l.inputs;for(const h in c){const p=c[h];let d=!1;for(let b=0;b<e.length;b++)if(r[p.id]){l.outputs.forEach(v=>r[v.id]=!0),d=!0,s[l.id]=!0;break}if(d)break}}const a={};a[n.id]=!0;const o={};for(let u=t.length-1;u>=0;u--){const l=t[u],c=l.inputs;for(let h=0;h<l.outputs.length;h++)if(a[l.outputs[h].id]){for(const p in c)a[c[p].id]=!0,o[l.id]=!0;break}}const i=[];for(let u=0;u<t.length;u++){const l=t[u];if(s[l.id]&&o[l.id]){const c={};for(const p in l.inputs){const d=l.inputs[p];r[d.id]&&(c[p]=d)}const h=Object.assign({},l);h.inputs=c,h.outputs=l.outputs,i.push(h)}}return i}function py(t,e,n,r){for(let s=e.length-1;s>=0;s--){const a=e[s],o=[];if(a.outputs.forEach(u=>{const l=t[u.id];l!=null?o.push(l):o.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const i=a.gradient(o);for(const u in a.inputs){if(!(u in i))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(i)}.`);const l=n(()=>i[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);const c=a.inputs[u];if(!jt(l.shape,c.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${c.shape}'`);if(t[c.id]==null)t[c.id]=l;else{const h=t[c.id];t[c.id]=r(h,l),h.dispose()}}}}const Ji=20,wr=3,ba=7;function dy(t,e,n,r){const s=hr(e),a=my(t,e,n,s),o=e.length,i=bs(t,e,n,s,a),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${o}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(i.map(l=>"    "+l).join(`
`)),u.join(`
`)}function my(t,e,n,r){const s=Ae(e),a=r[r.length-1],o=new Array(a).fill(0),i=e.length,u=n==="complex64"?Tr(t):t;if(i>1)for(let l=0;l<s/a;l++){const c=l*a;for(let h=0;h<a;h++)o[h]=Math.max(o[h],Nr(u[c+h],0,n).length)}return o}function Nr(t,e,n){let r;return Array.isArray(t)?r=`${parseFloat(t[0].toFixed(ba))} + ${parseFloat(t[1].toFixed(ba))}j`:on(t)?r=`'${t}'`:n==="bool"?r=zh(t):r=parseFloat(t.toFixed(ba)).toString(),_r(r,e)}function zh(t){return t===0?"false":"true"}function bs(t,e,n,r,s,a=!0){const o=n==="complex64"?2:1,i=e[0],u=e.length;if(u===0){if(n==="complex64"){const v=Tr(t);return[Nr(v[0],0,n)]}return n==="bool"?[zh(t[0])]:[t[0].toString()]}if(u===1){if(i>Ji){const N=wr*o;let x=Array.from(t.slice(0,N)),F=Array.from(t.slice((i-wr)*o,i*o));return n==="complex64"&&(x=Tr(x),F=Tr(F)),["["+x.map((_,$)=>Nr(_,s[$],n)).join(", ")+", ..., "+F.map((_,$)=>Nr(_,s[i-wr+$],n)).join(", ")+"]"]}const v=n==="complex64"?Tr(t):Array.from(t);return["["+v.map((N,x)=>Nr(N,s[x],n)).join(", ")+"]"]}const l=e.slice(1),c=r.slice(1),h=r[0]*o,p=[];if(i>Ji){for(let v=0;v<wr;v++){const N=v*h,x=N+h;p.push(...bs(t.slice(N,x),l,n,c,s,!1))}p.push("...");for(let v=i-wr;v<i;v++){const N=v*h,x=N+h;p.push(...bs(t.slice(N,x),l,n,c,s,v===i-1))}}else for(let v=0;v<i;v++){const N=v*h,x=N+h;p.push(...bs(t.slice(N,x),l,n,c,s,v===i-1))}const d=u===2?",":"";p[0]="["+p[0]+d;for(let v=1;v<p.length-1;v++)p[v]=" "+p[v]+d;let b=`,
`;for(let v=2;v<u;v++)b+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(a?"":b),p}function Tr(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class $s{constructor(e,n,r){if(this.dtype=n,this.shape=e.slice(),this.size=Ae(e),r!=null){const s=r.length;S(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Vu(n,this.size),this.strides=hr(e)}set(e,...n){n.length===0&&(n=[0]),S(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const r=this.locToIndex(n);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let n=0;for(const s of e){if(s<0||s>=this.shape[n]){const a=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(a)}n++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return n}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const n=new Array(this.shape.length);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(e/this.strides[r]),e-=n[r]*this.strides[r];return n[n.length-1]=e,n}get rank(){return this.shape.length}toTensor(){return Ot().makeTensor(this.values,this.shape,this.dtype)}}let Ot=null,Yn=null;function gy(t){Ot=t}function yy(t){Yn=t}class be{constructor(e,n,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=n||"float32",this.size=Ae(e),this.strides=hr(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Yn.buffer(this.shape,this.dtype,e)}bufferSync(){return Yn.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return kn(this.shape,e,this.dtype==="complex64")}arraySync(){return kn(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Ot().read(this.dataId);if(this.dtype==="string"){const n=await e;try{return n.map(r=>xs(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Ot().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Ot().readSync(this.dataId);if(this.dtype==="string")try{return e.map(n=>xs(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Ot().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Ot().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Yn.print(this,e)}clone(){return this.throwIfDisposed(),Yn.clone(this)}toString(e=!1){const n=this.dataSync();return dy(n,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Yn.cast(this,e)}variable(e=!0,n,r){return this.throwIfDisposed(),Ot().makeVariable(this,e,n,r)}}Object.defineProperty(be,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function by(){return mo("Tensor",()=>be)}by();class Or extends be{constructor(e,n,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=n,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!jt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Ot().disposeTensor(this),this.dataId=e.dataId,Ot().incRef(this,null)}dispose(){Ot().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Or,Symbol.hasInstance,{value:t=>t instanceof be&&t.assign!=null&&t.assign instanceof Function});var La;(function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"})(La||(La={}));var Ma;(function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"})(Ma||(Ma={}));var za;(function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"})(za||(za={}));var Va;(function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"})(Va||(Va={}));var ja;(function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"})(ja||(ja={}));const wy={float32:Va,int32:Ma,bool:za,complex64:ja};function zs(t,e){if(t==="string"||e==="string"){if(t==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return wy[t][e]}function vy(t){return zs(t,"int32")}function Pe(t,e){if(t.dtype===e.dtype)return[t,e];const n=zs(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function Vh(t,e){S(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function Sy(t,e){return e.some(n=>n.id===t.id)}function No(t){const e=[];return jh(t,e,new Set),e}function jh(t,e,n){if(t==null)return;if(t instanceof be){e.push(t);return}if(!Ny(t))return;const r=t;for(const s in r){const a=r[s];n.has(a)||(n.add(a),jh(a,e,n))}}function Ny(t){return Array.isArray(t)||typeof t=="object"}var Ty=Object.freeze(Object.defineProperty({__proto__:null,makeTypesMatch:Pe,assertTypesMatch:Vh,isTensorInList:Sy,getTensorsInContainer:No},Symbol.toStringTag,{value:"Module"}));function wa(t){return t.kernelName!=null}class Qi{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class or{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Qi}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:n}=this.initializeBackend(e);if(n)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,n,r=1){return e in this.registryFactory?(sn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:n,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:n,asyncInit:r}=this.initializeBackend(e);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new ly(this.backendInstance),!0}setupRegisteredKernels(){ks(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){ks(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const n=this.registryFactory[e];if(n==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=n.factory();if(r&&!(r instanceof Bu)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,a=r.then(o=>s<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,sn(`Initialization of backend ${e} failed`),sn(o.stack||o.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return sn(`Initialization of backend ${e} failed`),sn(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,n)=>this.registryFactory[n].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n],{success:s,asyncInit:a}=this.initializeBackend(r);if(a||s)return{name:r,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,n){const r=this.state.tensorInfo.get(n),s=r.backend,a=this.readSync(n),o=s.refCount(n);s.disposeData(n,!0),r.backend=e,e.move(n,a,r.shape,r.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,n){let r=null;if(n==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");n=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=n(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,n,r){e();try{const s=r();return n(),s}catch(s){throw n(),s}}nextTensorId(){return or.nextTensorId++}nextVariableId(){return or.nextVariableId++}clone(e){const n=k.runKernel(bo,{x:e}),r={x:e},s=o=>({x:()=>{const i="float32",u={x:o},l={dtype:i};return k.runKernel(yo,u,l)}}),a=[];return this.addTapeNode(this.state.activeScope.name,r,[n],s,a,{}),n}runKernel(e,n,r){if(this.backendName==null&&this.backend,!(Es(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,n,r){const s=this.backend.numDataIds();let a=0;r.forEach(u=>{a+=u.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=s-n-a-o;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let n,r=[];const s=this.isTapeOn(),a=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let u;const l=wa(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(wa(e)){const{kernelName:b,inputs:v,attrs:N}=e;this.backendName==null&&this.backend;const x=Es(b,this.backendName);S(x!=null,()=>`Cannot find registered kernel '${b}' for backend '${this.backendName}'`),i=()=>{const F=this.backend.numDataIds();u=x.kernelFunc({inputs:v,attrs:N,backend:this.backend});const _=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(b,F,_);const $=_.map(A=>A.rank!=null?A:this.makeTensorFromTensorInfo(A));if(s){const A=this.getTensorsForGradient(b,v,$);r=this.saveTensorsForBackwardMode(A)}return $}}else{const{forwardFunc:b}=e,v=N=>{!s||(r=N.map(x=>this.keep(this.clone(x))))};i=()=>{const N=this.backend.numDataIds();u=this.tidy(()=>b(this.backend,v));const x=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,N,x),x}}const{inputs:c,attrs:h}=e,p=wa(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=i():(d=this.profiler.profileKernel(l,c,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),n=d.outputs)}),s&&this.addTapeNode(l,c,n,p,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(b=>c[b]!=null?c[b].shape:null),outputShapes:n.map(b=>b.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(u)?n:n[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,n,r){const s=Ca(e);if(s!=null){const a=s.inputsToSave||[],o=s.outputsToSave||[];let i;s.saveAllInputs?(S(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(n).map(l=>n[l])):i=a.map(l=>n[l]);const u=r.filter((l,c)=>o[c]);return i.concat(u)}return[]}makeTensor(e,n,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let a=e;r==="string"&&on(e[0])&&(a=e.map(u=>jr(u)));const o=s.write(a,n,r),i=new be(n,r,o,this.nextTensorId());if(this.trackTensor(i,s),r==="string"){const u=this.state.tensorInfo.get(o),l=Wu(a);this.state.numBytes+=l-u.bytes,u.bytes=l}return i}makeTensorFromDataId(e,n,r,s){r=r||"float32";const a={dataId:e,shape:n,dtype:r};return this.makeTensorFromTensorInfo(a,s)}makeTensorFromTensorInfo(e,n){const{dataId:r,shape:s,dtype:a}=e,o=new be(s,a,r,this.nextTensorId());return this.trackTensor(o,n),o}makeVariable(e,n=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const a=new Or(e,n,r,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,n){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*Aa(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:n||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof Or||this.track(e)}incRef(e,n){this.trackTensor(e,n),this.backend.incRef(e.dataId)}removeDataId(e,n){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===n&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const n=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*Aa(e.dtype);this.state.numBytes-=r}n.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,n.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const n=this.state.registeredVariables[e];this.disposeVariable(n)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,n,r,s,a,o){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:n,outputs:r,saved:a},u=Ca(e);u!=null&&(s=u.gradFunc),s!=null&&(i.gradient=l=>(l=l.map((c,h)=>{if(c==null){const p=r[h],d=Ls(p.size,p.dtype);return this.makeTensor(d,p.shape,p.dtype)}return c}),s(l.length>1?l:l[0],a,o))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(n.name=e),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(e){const n=No(e),r=new Set(n.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const o=this.state.activeScope.track[a];!o.kept&&!r.has(o.id)&&o.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(a=>{!a.kept&&a.scopeId===s.id&&this.track(a)})}gradients(e,n,r,s=!1){if(S(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));S(a instanceof be,()=>"The result y returned by f() must be a tensor.");const o=fy(this.state.activeTape,n,a);if(!s&&o.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const i={};i[a.id]=r??Ey(a.shape),py(i,o,l=>this.tidy(l),ky);const u=n.map(l=>i[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(const c of l.saved)c.dispose()}),this.state.activeTape=null),{value:a,grads:u}})}customGrad(e){return S(hn(e),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{S(n.every(i=>i instanceof be),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};n.forEach((i,u)=>{s[u]=i});const a=(i,u)=>(r=e(...n,u),S(r.value instanceof be,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),S(hn(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),o=(i,u)=>{const l=r.gradFunc(i,u),c=Array.isArray(l)?l:[l];S(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),S(c.every(p=>p instanceof be),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return c.forEach((p,d)=>{h[d]=()=>p}),h};return this.runKernelFunc({forwardFunc:a,backwardsFunc:o,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,n){return this.state.tensorInfo.get(e).backend.readToGPU(e,n)}async time(e){const n=Ir(),r=await this.backend.time(e);return r.wallMs=Ir()-n,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Qi;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}or.nextTensorId=0;or.nextVariableId=0;function Ey(t){const e=ho(Ae(t),"float32");return k.makeTensor(e,t,"float32")}function Uh(){const t=Xu();if(t._tfengine==null){const e=new Ku(t);t._tfengine=new or(e)}return xg(t._tfengine.ENV),gy(()=>t._tfengine),t._tfengine}const k=Uh();function ky(t,e){const n={a:t,b:e};return k.runKernel(go,n)}function _y(){return typeof navigator<"u"&&navigator!=null}let Ua;function xy(t){Ua=t}function $y(t){if(Ua!==void 0)return Ua;if(t||_y()){if(t||(t=navigator),t.product==="ReactNative")return!0;const e=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");if(!e){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function Wh(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var Ay=Object.freeze(Object.defineProperty({__proto__:null,mockIsMobile:xy,isMobile:$y,isBrowser:Wh},Symbol.toStringTag,{value:"Module"}));const Nt=re();Nt.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Nt.registerFlag("IS_BROWSER",()=>Wh());Nt.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Nt.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Nt.registerFlag("PROD",()=>!1);Nt.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Nt.getBool("DEBUG"));Nt.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Nt.registerFlag("IS_TEST",()=>!1);Nt.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);Nt.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Nt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Ut(t,e){let n=t;if(We(t))return e==="string"?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||We(n)&&e!=="string";)r.push(n.length),n=n[0];return Array.isArray(t)&&re().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&qh(t,r,[]),r}function qh(t,e,n){if(n=n||[],!Array.isArray(t)&&!We(t)){S(e.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}S(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),S(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const r=e.slice(1);for(let s=0;s<t.length;++s)qh(t[s],r,n.concat(s))}function eu(t,e,n,r){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==e||t==="numeric"&&e==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function w(t,e,n,r="numeric"){if(t instanceof be)return eu(r,t.dtype,e,n),t;let s=Bs(t);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),eu(r,s,e,n),t==null||!We(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){const u=t==null?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${u}'`)}const a=Ut(t,s);!We(t)&&!Array.isArray(t)&&(t=[t]);const i=s!=="string"?Ms(t,s):An(t,[],!0);return k.makeTensor(i,a,s)}function Dr(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((a,o)=>w(a,`${e}[${o}]`,n,r))}const To="__op";function E(t){const e=Object.keys(t);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+To;const s=(...a)=>{k.startScope(n);try{const o=r(...a);return In(o)&&console.error("Cannot return a Promise inside of tidy."),k.endScope(o),o}catch(o){throw k.endScope(null),o}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}function Iy(t,e){const n=w(t,"real","complex"),r=w(e,"imag","complex");Qe(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return k.runKernel(yl,s)}const Jt=E({complex_:Iy});function mn(t,e,n,r){if(r==null&&(r=Bs(t)),r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!We(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){fo(e);const s=Ae(e),a=Ae(n);S(s===a,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${a}`);for(let o=0;o<n.length;++o){const i=n[o],u=o===n.length-1?i!==Ae(e.slice(o)):!0;S(n[o]===e[o]||!u,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return!We(t)&&!Array.isArray(t)&&(t=[t]),e=e||n,t=r!=="string"?Ms(t,r):An(t,[],!0),k.makeTensor(t,e,r)}function vt(t,e,n){const r=Ut(t,n);return mn(t,e,r,n)}const Wa={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};const As=4;async function Oy(t,e){const n=[],r=[],s=Array.isArray(t)?t.map(o=>o.name):Object.keys(t);for(let o=0;o<s.length;++o){const i=s[o],u=Array.isArray(t)?t[o].tensor:t[i];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${u.dtype}`);const l={name:i,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const c=new Promise(async h=>{const p=await u.bytes(),d=p.reduce((N,x)=>N+x.length,0)+As*p.length,b=new Uint8Array(d);let v=0;for(let N=0;N<p.length;N++){const x=p[N],F=new Uint8Array(new Uint32Array([x.length]).buffer);b.set(F,v),v+=As,b.set(x,v),v+=x.length}h(b)});r.push(c)}else r.push(u.data());e!=null&&(l.group=e),n.push(l)}const a=await Promise.all(r);return{data:Dy(a),specs:n}}function Hh(t,e){const n={};let r,s=0;for(const a of e){const o=a.name,i=a.dtype,u=a.shape,l=Ae(u);let c;if("quantization"in a){const h=a.quantization;if(h.dtype==="uint8"||h.dtype==="uint16"){if(!("min"in h&&"scale"in h))throw new Error(`Weight ${a.name} with quantization ${h.dtype} doesn't have corresponding metadata min and scale.`)}else if(h.dtype==="float16"){if(i!=="float32")throw new Error(`Weight ${a.name} is quantized with ${h.dtype} which only supports weights of type float32 not ${i}.`)}else throw new Error(`Weight ${a.name} has unknown quantization dtype ${h.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const p=Wa[h.dtype],d=t.slice(s,s+l*p),b=h.dtype==="uint8"?new Uint8Array(d):new Uint16Array(d);if(i==="float32")if(h.dtype==="uint8"||h.dtype==="uint16"){c=new Float32Array(b.length);for(let v=0;v<b.length;v++){const N=b[v];c[v]=N*h.scale+h.min}}else if(h.dtype==="float16")r===void 0&&(r=Ly()),c=r(b);else throw new Error(`Unsupported quantization type ${h.dtype} for weight type float32.`);else if(i==="int32"){if(h.dtype!=="uint8"&&h.dtype!=="uint16")throw new Error(`Unsupported quantization type ${h.dtype} for weight type int32.`);c=new Int32Array(b.length);for(let v=0;v<b.length;v++){const N=b[v];c[v]=Math.round(N*h.scale+h.min)}}else throw new Error(`Unsupported dtype in weight '${o}': ${i}`);s+=l*p}else if(i==="string"){const h=Ae(a.shape);c=[];for(let p=0;p<h;p++){const d=new Uint32Array(t.slice(s,s+As))[0];s+=As;const b=new Uint8Array(t.slice(s,s+d));c.push(b),s+=d}}else{const h=Wa[i],p=t.slice(s,s+l*h);if(i==="float32")c=new Float32Array(p);else if(i==="int32")c=new Int32Array(p);else if(i==="bool")c=new Uint8Array(p);else if(i==="complex64"){c=new Float32Array(p);const d=new Float32Array(c.length/2),b=new Float32Array(c.length/2);for(let x=0;x<d.length;x++)d[x]=c[x*2],b[x]=c[x*2+1];const v=vt(d,u,"float32"),N=vt(b,u,"float32");n[o]=Jt(v,N),v.dispose(),N.dispose()}else throw new Error(`Unsupported dtype in weight '${o}': ${i}`);s+=l*h}i!=="complex64"&&(n[o]=vt(c,u,i))}return n}function Dy(t){if(t===null)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(a=>{if(e+=a.byteLength,n.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const r=new Uint8Array(e);let s=0;return n.forEach(a=>{r.set(new Uint8Array(a.buffer),s),s+=a.byteLength}),r.buffer}const Eo=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function tu(t){return Eo?Buffer.byteLength(t):new Blob([t]).size}function Fy(t){if(Eo)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,s=e.length;r<s;r++)n+=String.fromCharCode(e[r]);return btoa(n)}function Cy(t){if(Eo){const r=Buffer.from(t,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}function ko(t){if(t.length===1)return t[0];let e=0;t.forEach(s=>{e+=s.byteLength});const n=new Uint8Array(e);let r=0;return t.forEach(s=>{n.set(new Uint8Array(s),r),r+=s.byteLength}),n.buffer}function nu(t){const e="/";for(t=t.trim();t.endsWith(e);)t=t.slice(0,t.length-1);const n=t.split(e);return n[n.length-1]}function Gh(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),n}async function _o(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),t.weightsManifest!=null){const[r,s]=await e(t.weightsManifest);n.weightSpecs=r,n.weightData=s}return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),n}function Ur(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:tu(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:tu(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:t.weightData.byteLength}}function Py(){const t=n=>{let r=n<<13,s=0;for(;(r&8388608)===0;)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}function Ry(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}function By(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}function Ly(){const t=Py(),e=Ry(),n=By();return r=>{const s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let o=0;o<r.length;o++){const i=r[o],u=t[n[i>>10]+(i&1023)]+e[i>>10];a[o]=u}return new Float32Array(s)}}class Ce{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Ce.instance==null&&(Ce.instance=new Ce),Ce.instance}static registerSaveRouter(e){Ce.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Ce.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Ce.getHandlers(e,"save")}static getLoadHandlers(e,n){return Ce.getHandlers(e,"load",n)}static getHandlers(e,n,r){const s=[];return(n==="load"?Ce.getInstance().loadRouters:Ce.getInstance().saveRouters).forEach(o=>{const i=o(e,r);i!==null&&s.push(i)}),s}}const My=t=>Ce.registerSaveRouter(t),zy=t=>Ce.registerLoadRouter(t),Vy=t=>Ce.getSaveHandlers(t),jy=(t,e)=>Ce.getLoadHandlers(t,e);const qa="tensorflowjs",Ha=1,En="models_store",un="model_info_store";function Kh(){if(!re().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Ga(t){const e=t.result;e.createObjectStore(En,{keyPath:"modelPath"}),e.createObjectStore(un,{keyPath:"modelPath"})}class On{constructor(e){if(this.indexedDB=Kh(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,n){return new Promise((r,s)=>{const a=this.indexedDB.open(qa,Ha);a.onupgradeneeded=()=>Ga(a),a.onsuccess=()=>{const o=a.result;if(n==null){const i=o.transaction(En,"readonly"),l=i.objectStore(En).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return o.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(l.result.modelArtifacts)},l.onerror=c=>(o.close(),s(l.error)),i.oncomplete=()=>o.close()}else{const i=Ur(n),u=o.transaction(un,"readwrite");let l=u.objectStore(un);const c=l.put({modelPath:this.modelPath,modelArtifactsInfo:i});let h;c.onsuccess=()=>{h=o.transaction(En,"readwrite");const d=h.objectStore(En).put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:i});d.onsuccess=()=>r({modelArtifactsInfo:i}),d.onerror=b=>{l=u.objectStore(un);const v=l.delete(this.modelPath);v.onsuccess=()=>(o.close(),s(d.error)),v.onerror=N=>(o.close(),s(d.error))}},c.onerror=p=>(o.close(),s(c.error)),u.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},a.onerror=o=>s(a.error)})}}On.URL_SCHEME="indexeddb://";const Xh=t=>re().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(On.URL_SCHEME)?Uy(t.slice(On.URL_SCHEME.length)):null;Ce.registerSaveRouter(Xh);Ce.registerLoadRouter(Xh);function Uy(t){return new On(t)}function Wy(t){return t.startsWith(On.URL_SCHEME)?t.slice(On.URL_SCHEME.length):t}class qy{constructor(){this.indexedDB=Kh()}async listModels(){return new Promise((e,n)=>{const r=this.indexedDB.open(qa,Ha);r.onupgradeneeded=()=>Ga(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(un,"readonly"),i=a.objectStore(un).getAll();i.onsuccess=()=>{const u={};for(const l of i.result)u[l.modelPath]=l.modelArtifactsInfo;e(u)},i.onerror=u=>(s.close(),n(i.error)),a.oncomplete=()=>s.close()},r.onerror=s=>n(r.error)})}async removeModel(e){return e=Wy(e),new Promise((n,r)=>{const s=this.indexedDB.open(qa,Ha);s.onupgradeneeded=()=>Ga(s),s.onsuccess=()=>{const a=s.result,o=a.transaction(un,"readwrite"),i=o.objectStore(un),u=i.get(e);let l;u.onsuccess=()=>{if(u.result==null)return a.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=i.delete(e),h=()=>{l=a.transaction(En,"readwrite");const d=l.objectStore(En).delete(e);d.onsuccess=()=>n(u.result.modelArtifactsInfo),d.onerror=b=>r(u.error)};c.onsuccess=h,c.onerror=p=>(h(),a.close(),r(u.error))}},u.onerror=c=>(a.close(),r(u.error)),o.oncomplete=()=>{l==null?a.close():l.oncomplete=()=>a.close()}},s.onerror=a=>r(s.error)})}}const Yt="/",Zn="tensorflowjs_models",Yh="info",Hy="model_topology",Gy="weight_specs",Ky="weight_data",Xy="model_metadata";function Zh(t){return{info:[Zn,t,Yh].join(Yt),topology:[Zn,t,Hy].join(Yt),weightSpecs:[Zn,t,Gy].join(Yt),weightData:[Zn,t,Ky].join(Yt),modelMetadata:[Zn,t,Xy].join(Yt)}}function Jh(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function Yy(t){const e=t.split(Yt);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(Yt)}function Zy(t){return t.startsWith(Dn.URL_SCHEME)?t.slice(Dn.URL_SCHEME.length):t}class Dn{constructor(e){if(!re().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Zh(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=Ur(e);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,Fy(e.weightData));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:s}}catch{throw Jh(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=s;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const i=JSON.parse(a);n.format=i.format,n.generatedBy=i.generatedBy,n.convertedBy=i.convertedBy,i.signature!=null&&(n.signature=i.signature),i.userDefinedMetadata!=null&&(n.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(n.modelInitializer=i.modelInitializer),i.trainingConfig!=null&&(n.trainingConfig=i.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=Cy(o),n}}Dn.URL_SCHEME="localstorage://";const Qh=t=>re().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Dn.URL_SCHEME)?Jy(t.slice(Dn.URL_SCHEME.length)):null;Ce.registerSaveRouter(Qh);Ce.registerLoadRouter(Qh);function Jy(t){return new Dn(t)}class Qy{constructor(){S(re().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),S(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},n=Zn+Yt,r=Yt+Yh;for(let s=0;s<this.LS.length;++s){const a=this.LS.key(s);if(a.startsWith(n)&&a.endsWith(r)){const o=Yy(a);e[o]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=Zy(e);const n=Zh(e);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return Jh(n),r}}const er="://";class Xe{constructor(){this.managers={}}static getInstance(){return Xe.instance==null&&(Xe.instance=new Xe),Xe.instance}static registerManager(e,n){S(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(er)&&(e=e.slice(0,e.indexOf(er))),S(e.length>0,()=>"scheme must not be an empty string.");const r=Xe.getInstance();S(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=n}static getManager(e){const n=Xe.getInstance().managers[e];if(n==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return n}static getSchemes(){return Object.keys(Xe.getInstance().managers)}}function ws(t){if(t.indexOf(er)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Xe.getSchemes().join(",")}`);return{scheme:t.split(er)[0],path:t.split(er)[1]}}async function ef(t,e,n=!1){S(t!==e,()=>`Old path and new path are the same: '${t}'`);const r=Ce.getLoadHandlers(t);S(r.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),S(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`);const s=r[0],a=Ce.getSaveHandlers(e);S(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),S(a.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const o=a[0],i=ws(t).scheme,u=ws(t).path,l=i===ws(t).scheme,c=await s.load();n&&l&&await Xe.getManager(i).removeModel(u);const h=await o.save(c);return n&&!l&&await Xe.getManager(i).removeModel(u),h.modelArtifactsInfo}async function e0(){const t=Xe.getSchemes(),e={};for(const n of t){const r=await Xe.getManager(n).listModels();for(const s in r){const a=n+er+s;e[a]=r[s]}}return e}async function t0(t){const e=ws(t);return Xe.getManager(e.scheme).removeModel(e.path)}async function n0(t,e){return ef(t,e,!1)}async function r0(t,e){return ef(t,e,!0)}class s0{fetch(e,n){return fetch(e,n)}now(){return performance.now()}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,n){return new TextDecoder(n).decode(e)}}if(re().get("IS_BROWSER")){re().setPlatform("browser",new s0);try{Xe.registerManager(Dn.URL_SCHEME,new Qy)}catch{}try{Xe.registerManager(On.URL_SCHEME,new qy)}catch{}}const a0={importFetch:()=>require("node-fetch")};let va;class o0{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return re().global.fetch!=null?re().global.fetch(e,n):(va==null&&(va=a0.importFetch()),va(e,n))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(e)}decode(e,n){return e.length===0?"":new this.util.TextDecoder(n).decode(e)}}re().get("IS_NODE")&&!re().get("IS_BROWSER")&&re().setPlatform("node",new o0);function Wt(t,e="float32",n){return e=e||"float32",fo(t),new $s(t,e,n)}function i0(t,e){const n=w(t,"x","cast");if(!Uu(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&n.dtype!=="string"||e!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:e};return k.runKernel(yo,r,s)}const we=E({cast_:i0});function u0(t){const n={x:w(t,"x","clone","string_or_numeric")};return k.runKernel(bo,n)}const Zt=E({clone_:u0});function xo(t,e=!1){console.log(t.toString(e))}Uh();const l0={buffer:Wt,cast:we,clone:Zt,print:xo};yy(l0);const c0="model",h0=".json",f0=".weights.bin";function ru(t){return new Promise(e=>setTimeout(e)).then(t)}class Fn{constructor(e){if(!re().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Fn.URL_SCHEME)&&(e=e.slice(Fn.URL_SCHEME.length)),(e==null||e.length===0)&&(e=c0),this.modelJsonFileName=e+h0,this.weightDataFileName=e+f0}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],s=Gh(e,r),a=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=a,await ru(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=n,await ru(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Ur(e)}}}}Fn.URL_SCHEME="downloads://";class p0{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,n)=>{const r=new FileReader;r.onload=s=>{const a=JSON.parse(s.target.result),o=a.modelTopology;if(o==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:o});return}const u=_o(a,l=>this.loadWeights(l));e(u)},r.onerror=s=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){const n=[],r=[];for(const o of e)n.push(...o.weights),r.push(...o.paths);const s=this.checkManifestAndWeightFiles(e),a=r.map(o=>this.loadWeightsFile(o,s[o]));return Promise.all(a).then(o=>[n,ko(o)])}loadWeightsFile(e,n){return new Promise((r,s)=>{const a=new FileReader;a.onload=o=>{const i=o.target.result;r(i)},a.onerror=o=>s(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(e){const n=[],r=this.weightsFiles.map(a=>nu(a.name)),s={};for(const a of e)a.paths.forEach(o=>{const i=nu(o);if(n.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(n.push(i),r.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);s[o]=this.weightsFiles[r.indexOf(i)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}const d0=t=>re().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Fn.URL_SCHEME)?m0(t.slice(Fn.URL_SCHEME.length)):null;Ce.registerSaveRouter(d0);function m0(t="model"){return new Fn(t)}function g0(t){return new p0(t)}function su(t,e,n,r){o(t),n=n??0,r=r??1,i(n,r);let s=0;const a=u=>(u.then(l=>{const c=n+ ++s/t.length*(r-n);return e(c),l}),u);function o(u){S(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function i(u,l){S(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),S(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),S(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(t.map(a))}async function tf(t,e){e==null&&(e={});const n=e.fetchFunc==null?re().platform.fetch:e.fetchFunc,r=t.map(h=>n(h,e.requestInit,{isBinary:!0})),s=0,a=.5,i=(e.onProgress==null?await Promise.all(r):await su(r,e.onProgress,s,a)).map(h=>h.arrayBuffer()),u=.5,l=1;return e.onProgress==null?await Promise.all(i):await su(i,e.onProgress,u,l)}async function y0(t,e="",n,r){return nf(o=>tf(o,{requestInit:r}))(t,e,n)}function nf(t){return async(e,n="",r)=>{const s=e.map(()=>!1),a={},o=r!=null?r.map(()=>!1):[],i=[];if(e.forEach((d,b)=>{let v=0;d.weights.forEach(N=>{const x="quantization"in N?N.quantization.dtype:N.dtype,F=Wa[x]*Ae(N.shape),_=()=>{s[b]=!0,a[b]==null&&(a[b]=[]),a[b].push({manifestEntry:N,groupOffset:v,sizeBytes:F})};r!=null?r.forEach(($,A)=>{$===N.name&&(_(),o[A]=!0)}):_(),i.push(N.name),v+=F})}),!o.every(d=>d)){const d=r.filter((b,v)=>!o[v]);throw new Error(`Could not find weights in manifest with names: ${d.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}const u=s.reduce((d,b,v)=>(b&&d.push(v),d),[]),l=[];u.forEach(d=>{e[d].paths.forEach(b=>{const v=n+(n.endsWith("/")?"":"/")+b;l.push(v)})});const c=await t(l),h={};let p=0;return u.forEach(d=>{const b=e[d].paths.length;let v=0;for(let $=0;$<b;$++)v+=c[p+$].byteLength;const N=new ArrayBuffer(v),x=new Uint8Array(N);let F=0;for(let $=0;$<b;$++){const A=new Uint8Array(c[p+$]);x.set(A,F),F+=A.byteLength}a[d].forEach($=>{const A=N.slice($.groupOffset,$.groupOffset+$.sizeBytes),C=Hh(A,[$.manifestEntry]);for(const M in C)h[M]=C[M]}),p+=b}),h}}const b0="application/octet-stream",w0="application/json";class $o{constructor(e,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.onProgress=n.onProgress,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(S(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=re().platform.fetch,S(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&S(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=Gh(e,r);n.body.append("model.json",new Blob([JSON.stringify(s)],{type:w0}),"model.json"),e.weightData!=null&&n.body.append("model.weights.bin",new Blob([e.weightData],{type:b0}),"model.weights.bin");const a=await this.fetch(this.path,n);if(a.ok)return{modelArtifactsInfo:Ur(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const r=n.modelTopology,s=n.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return _o(n,a=>this.loadWeights(a))}async loadWeights(e){const n=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=v0(n),a=this.weightPathPrefix||r,o=[];for(const c of e)o.push(...c.weights);const i=[],u=[];for(const c of e)for(const h of c.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(h)):i.push(a+h+s);this.weightUrlConverter&&i.push(...await Promise.all(u));const l=await tf(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,ko(l)]}}$o.URL_SCHEME_REGEX=/^https?:\/\//;function v0(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),s=n>e?t.substring(n):"";return[r+"/",s]}function Ka(t){return t.match($o.URL_SCHEME_REGEX)!=null}const rf=(t,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let n=!0;if(Array.isArray(t)?n=t.every(r=>Ka(r)):n=Ka(t),n)return Ao(t,e)}return null};Ce.registerSaveRouter(rf);Ce.registerLoadRouter(rf);function Ao(t,e){return new $o(t,e)}function S0(t,e){return Ao(t,e)}class Sa{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class sf{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class N0{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=n=>Promise.resolve(e.save(n)))}}function T0(t,e,n,r){const s=arguments;return new N0(af(...s))}function af(t,e,n,r){return arguments.length===1?t.modelTopology!=null||t.weightSpecs!=null?new Sa(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Sa({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Sa({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r}))}function E0(t){return new sf(t)}function k0(t){return new sf(t)}var Io=Object.freeze(Object.defineProperty({__proto__:null,browserFiles:g0,browserHTTPRequest:S0,concatenateArrayBuffers:ko,decodeWeights:Hh,encodeWeights:Oy,fromMemory:T0,fromMemorySync:af,getLoadHandlers:jy,getModelArtifactsForJSON:_o,getModelArtifactsInfoForJSON:Ur,getSaveHandlers:Vy,http:Ao,isHTTPScheme:Ka,loadWeights:y0,registerLoadRouter:zy,registerSaveRouter:My,weightsLoaderFactory:nf,withSaveHandler:E0,withSaveHandlerSync:k0,copyModel:n0,listModels:e0,moveModel:r0,removeModel:t0},Symbol.toStringTag,{value:"Module"}));function _0(t,e,n=!1,r=!1){let s=w(t,"a","matMul"),a=w(e,"b","matMul");[s,a]=Pe(s,a);const o={a:s,b:a},i={transposeA:n,transposeB:r};return k.runKernel(hl,o,i)}const ye=E({matMul_:_0});function x0(t,e,n=1,r=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const a={indices:w(t,"indices","oneHot","int32")},o={depth:e,onValue:n,offValue:r};return k.runKernel(Cc,a,o)}const Fr=E({oneHot_:x0});function $0(){re().set("PROD",!0)}function A0(){re().set("DEBUG",!0)}function I0(){re().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function O0(t){re().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function D0(){k.disposeVariables()}function Oo(){return k}function F0(){return k.memory()}function C0(t){return k.profile(t)}function Z(t,e){return k.tidy(t,e)}function tt(t){No(t).forEach(n=>n.dispose())}function Lt(t){return k.keep(t)}function P0(t){return k.time(t)}function R0(t){return k.setBackend(t)}function B0(){return k.ready()}function of(){return k.backendName}function L0(t){k.removeBackend(t)}function M0(t){return k.findBackend(t)}function z0(t){return k.findBackendFactory(t)}function V0(t,e,n=1){return k.registerBackend(t,e,n)}function uf(){return k.backend}function j0(t,e){re().setPlatform(t,e)}function U0(t){const n={input:w(t,"input","imag")};return k.runKernel(nc,n)}const Wr=E({imag_:U0});function W0(t){const n={x:w(t,"x","neg")};return k.runKernel($c,n)}const zt=E({neg_:W0});function q0(t){const n={input:w(t,"input","real")};return k.runKernel(Vc,n)}const ir=E({real_:q0});function H0(t,e,n){const r=w(t,"x","transpose");if(e==null&&(e=r.shape.map((o,i)=>i).reverse()),S(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(o=>{S(o>=0&&o<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const s={x:r},a={perm:e};return r.dtype==="complex64"?Z(()=>{let o=ir(r),i=Wr(r);return o=k.runKernel(ys,{x:o},a),i=k.runKernel(ys,{x:i},a),n&&(i=zt(i)),Jt(o,i)}):k.runKernel(ys,s,a)}const Cr=E({transpose_:H0});function G0(t,e,n){const r=w(t,"labels","confusionMatrix"),s=w(e,"predictions","confusionMatrix");S(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),S(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),S(s.rank===1,()=>`Expected the rank of predictions to be 1, but got ${s.rank}`),S(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),S(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);const a=Fr(we(r,"int32"),n),o=Fr(we(s,"int32"),n),i=Cr(a),u=ye(i,o);return we(u,"int32")}const K0=E({confusionMatrix_:G0});var X0=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:K0},Symbol.toStringTag,{value:"Module"}));function lf(t,e){const n=t.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,o=t[a]||1;(e[e.length-1-s]||1)>1&&o===1&&r.unshift(a)}return r}function Do(t,e){const n=[];for(let r=0;r<e.length;r++){const s=t[t.length-r-1],a=e.length-r-1,o=e[a];(s==null||s===1&&o>1)&&n.unshift(a)}return n}function Me(t,e){const n=[],r=Math.max(t.length,e.length);for(let s=0;s<r;s++){let a=t[t.length-s-1];a==null&&(a=1);let o=e[e.length-s-1];if(o==null&&(o=1),a===1)n.unshift(o);else if(o===1)n.unshift(a);else if(a!==o){const i=`Operands could not be broadcast together with shapes ${t} and ${e}.`;throw Error(i)}else n.unshift(a)}return n}var Y0=Object.freeze(Object.defineProperty({__proto__:null,getBroadcastDims:lf,getReductionAxes:Do,assertAndGetBroadcastShape:Me},Symbol.toStringTag,{value:"Module"}));function Fo(t,e,n){if(Ln(t),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=Ut(t,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return mn(t,e,r,n)}let vn;function cf(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(t==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,o=!1,i=!1;if(t.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&t instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)a=!0;else if(t.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&t instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);if(s&&s&&t.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(Es(Ia,k.backendName)!=null){const b={pixels:t},v={numChannels:e};return k.runKernel(Ia,b,v)}const[l,c]=s?[t.videoWidth,t.videoHeight]:[t.width,t.height];let h;if(o)h=t.getContext("2d").getImageData(0,0,l,c).data;else if(r||n)h=t.data;else if(a||s||i){if(vn==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")vn=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else vn=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});vn.canvas.width=l,vn.canvas.height=c,vn.drawImage(t,0,0,l,c),h=vn.getImageData(0,0,l,c).data}let p;if(e===4)p=new Int32Array(h);else{const b=l*c;p=new Int32Array(b*e);for(let v=0;v<b;v++)for(let N=0;N<e;++N)p[v*e+N]=h[v*4+N]}return Fo(p,[c,l,e],"int32")}function Z0(t){return t!=null&&t.data instanceof Uint8Array}function J0(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function Q0(t){return t!=null&&t.width!==0&&t.height!==0}function eb(t){return J0()&&!(t instanceof ImageBitmap)&&Q0(t)&&!Z0(t)}async function tb(t,e=3){let n=null;if(re().getBool("WRAP_TO_IMAGEBITMAP")&&eb(t)){let r;try{r=await createImageBitmap(t,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===t.width&&r.height===t.height?n=r:n=t}else n=t;return cf(n,e)}async function qr(t,e){let n=w(t,"img","toPixels");if(!(t instanceof be)){const l=n;n=we(l,"int32"),l.dispose()}if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[r,s]=n.shape.slice(0,2),a=n.rank===2?1:n.shape[2];if(a>4||a===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${a}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);const o=await n.data(),i=n.dtype==="float32"?255:1,u=new Uint8ClampedArray(s*r*4);for(let l=0;l<r*s;++l){const c=[0,0,0,255];for(let p=0;p<a;p++){const d=o[l*a+p];if(n.dtype==="float32"){if(d<0||d>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${d}.`)}else if(n.dtype==="int32"&&(d<0||d>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${d}.`);a===1?(c[0]=d*i,c[1]=d*i,c[2]=d*i):c[p]=d*i}const h=l*4;u[h+0]=Math.round(c[0]),u[h+1]=Math.round(c[1]),u[h+2]=Math.round(c[2]),u[h+3]=Math.round(c[3])}if(e!=null){e.width=s,e.height=r;const l=e.getContext("2d"),c=new ImageData(u,s,r);l.putImageData(c,0,0)}return n!==t&&n.dispose(),u}const Vs=E({fromPixels_:cf});var nb=Object.freeze(Object.defineProperty({__proto__:null,fromPixelsAsync:tb,toPixels:qr,fromPixels:Vs},Symbol.toStringTag,{value:"Module"}));function hf(t,e){const n=t.shape.length,r=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${n}`);if(Ae(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const s=e.shape,a=s[s.length-1];let o=1;for(let h=0;h<s.length-1;++h)o*=s[h];const i=t.shape,u=s.slice();u.pop();let l=1;for(let h=a;h<n;++h)l*=i[h],u.push(i[h]);const c=[...hr(t.shape).map(h=>h/l),1].slice(0,a);return[u,o,l,c]}var rb=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:hf},Symbol.toStringTag,{value:"Module"}));function Co(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(t.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+t.length-r)throw new Error(a+` update.rank != ${s+t.length-r}`);for(let o=0;o<s;++o)if(n.shape[o]!==e.shape[o])throw new Error(a+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<n.rank-s;++o)if(n.shape[o+s]!==t[o+r])throw new Error(a+` updates.shape[${o+s}] (${n.shape[o+s]}) != shape[${o+s}] (${t[o+s]})`)}function Po(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}Co(n,e,t)}function ff(t,e,n){const r=e.shape.length,s=r>1?e.shape[r-1]:1,a=n.length;let o=1;for(let h=s;h<a;++h)o*=n[h];const i=s<1?1:s,u=Ae(e.shape)/i,l=[...hr(n.slice(0,s)),1],c=Ae(n);return{sliceRank:s,numUpdates:u,sliceSize:o,strides:l,outputSize:c}}var sb=Object.freeze(Object.defineProperty({__proto__:null,validateUpdateShape:Co,validateInput:Po,calculateShapes:ff},Symbol.toStringTag,{value:"Module"}));const Xa=-2,ab=-1;function ob(t,e,n){const r=t.shape.length;S(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),S(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)S(e[s]+n[s]<=t.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+n[s]}) would overflow input.shape[${s}] (${t.shape[s]})`)}function ib(t){const e=[];let n=0;for(;t>0;)t&1&&e.push(n),t/=2,n++;return e}function ub(t,e,n){const r=[];for(let s=0;s<t.length;s++)r[s]=Math.ceil((e[s]-t[s])/n[s]);return r}function pf(t,e,n,r){const s=[...t];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<n;a++)a===0?s[e]=1:(s.splice(e,0,1),s.pop());return s}function df(t,e,n){return n<=t?n:n-(e-1)}function mf(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function lb(t,e,n,r,s,a,o,i,u){const l=t.length;let c=new Array(l),h=new Array(l),p=new Array(l);if(e.length&&n>0){const d=e[0],b=n+1;c=gf(o,d,b,r,t),h=yf(i,d,b,s,t),p=pf(a,d,b,t)}else for(let d=0;d<l;d++)c[d]=wf(o,r,a,t,d,u),h[d]=vf(i,s,a,t,d,u),p[d]=bf(a,d,u);return{begin:c,end:h,strides:p}}function gf(t,e,n,r,s){const a=[...s],o=mf(n,e);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=0;else{const u=df(e,n,i);let l=r[u];t&1<<u&&(l=0),a[i]=l}return a}function yf(t,e,n,r,s){const a=[...s],o=mf(n,e);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=Number.MAX_SAFE_INTEGER;else{const u=df(e,n,i);let l=r[u];t&1<<u&&(l=Number.MAX_SAFE_INTEGER),a[i]=l}for(let i=0;i<a.length;i++){const u=s[i];a[i]<0&&(a[i]+=u),a[i]=$r(0,a[i],s[i])}return a}function bf(t,e,n){let r=t[e];return(n&1<<e||r==null)&&(r=1),r}function wf(t,e,n,r,s,a){let o=e[s];const i=n[s]||1;(t&1<<s||a&1<<s||o==null)&&(i>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const u=r[s];return o<0&&(o+=u),o=$r(0,o,u-1),o}function vf(t,e,n,r,s,a){let o=e[s];const i=n[s]||1;(t&1<<s||a&1<<s||o==null)&&(i>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const u=r[s];return o<0&&(o+=u),i>0?o=$r(0,o,u):o=$r(-1,o,u-1),o}function cb(t,e,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(e[s]>0||n[s]!==t[s])return!1;return!0}function hb(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function fb(t,e,n){let r;const s=t.shape.length;typeof e=="number"?r=[e,...new Array(s-1).fill(0)]:e.length<s?r=e.concat(new Array(s-e.length).fill(0)):r=e.slice(),r.forEach(o=>{S(o!==-1,()=>"slice() does not support negative begin indexing.")});let a;return n==null?a=new Array(s).fill(-1):typeof n=="number"?a=[n,...new Array(s-1).fill(-1)]:n.length<s?a=n.concat(new Array(s-n.length).fill(-1)):a=n,a=a.map((o,i)=>o>=0?o:(S(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${i}.`),t.shape[i]-r[i])),[r,a]}function pb(t,e,n,r,s,a,o,i,u){let l;if(r==null?(l=new Array(e.length),l.fill(1)):l=r,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:l.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:l.slice(),beginMask:s,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};for(let _=0;_<h.dims;_++)c&&(1<<_&i)!==0&&h.numAddAxisAfterEllipsis++,1<<_&o&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const p={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};db(h,p);let d=!0,b=!0,v=!0;const N=[],x=[];for(let _=0;_<t.length;++_){if(p.strides[_]===0)throw Error(`strides[${_}] must be non-zero`);const $=!!(p.shrinkAxisMask&1<<_),A=t[_];if(A===-1){N.push($?1:-1);continue}const C=[p.beginMask&1<<_,p.endMask&1<<_],M=[p.strides[_]>0?0:-1,p.strides[_]>0?A:A-1];if($&&p.strides[_]<=0)throw Error("only stride 1 allowed on non-range indexing.");v=v&&p.strides[_]===1;const P=!!(p.beginMask&1<<_&&p.endMask&1<<_);if(p.beginValid&&p.endValid){if($){const q=p.begin[_]<0?A+p.begin[_]:p.begin[_];if(p.begin[_]=q,p.end[_]=p.begin[_]+1,q<0||q>=A)throw Error(`slice index ${p.begin[_]} of dimension ${_} out of bounds.`)}else p.begin[_]=au(p.begin[_],0,p.strides[_],A,C,M),p.end[_]=au(p.end[_],1,p.strides[_],A,C,M);const z=p.strides[_]===1&&p.begin[_]===0&&p.end[_]===A;d=d&&z,b=b&&(_===0&&p.strides[_]===1||z)}else d=d&&p.strides[_]===1&&P,b=b&&(_===0&&p.strides[_]===1||P);let D,V=!1;if(p.beginValid&&p.endValid?(D=p.end[_]-p.begin[_],V=!0):$?(D=1,V=!0):P&&A>=0&&(p.strides[_]<0?D=-A:D=A,V=!0),V){let z;D===0||D<0!=p.strides[_]<0?z=0:z=Math.trunc(D/p.strides[_])+(D%p.strides[_]!==0?1:0),N.push(z)}else N.push(-1)}for(let _=0;_<p.finalShapeGatherIndices.length;++_){const $=p.finalShapeGatherIndices[_];$>=0?x.push(N[$]):$===Xa&&x.push(1)}return{finalShapeSparse:x.filter((_,$)=>p.finalShapeGatherIndices[$]!==Xa),finalShape:x,isIdentity:d,sliceDim0:b,isSimpleSlice:v,begin:p.begin,end:p.end,strides:p.strides}}function db(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=t.begin!=null,e.endValid=t.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const s=Math.min(e.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<s;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&t.newAxisMask)e.finalShapeGatherIndices.push(Xa),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);t.begin!=null&&(e.begin[n]=t.begin[r]),t.end!=null&&(e.end[n]=t.end[r]),e.strides[n]=t.strides[r],t.beginMask&1<<r&&(e.beginMask|=1<<n),t.endMask&1<<r&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(ab),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[n]=r,n++}}function au(t,e,n,r,s,a){if(s[e])return n>0?a[e]:a[e+1&1];{const o=t<0?r+t:t;return o<a[0]?a[0]:o>a[1]?a[1]:o}}var Sf=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:ob,maskToAxes:ib,computeOutShape:ub,stridesWithElidedDims:pf,getNormalizedAxes:lb,startIndicesWithElidedDims:gf,stopIndicesWithElidedDims:yf,stridesForAxis:bf,startForAxis:wf,stopForAxis:vf,isSliceContinous:cb,computeFlatOffset:hb,parseSliceParams:fb,sliceInfo:pb},Symbol.toStringTag,{value:"Module"}));class Nf{getClassName(){return this.constructor.className}static fromConfig(e,n){return new e(n)}}class an{constructor(){this.classNameMap={}}static getMap(){return an.instance==null&&(an.instance=new an),an.instance}static register(e){an.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function gn(t){S(t.className!=null,()=>"Class being registered does not have the static className property defined."),S(typeof t.className=="string",()=>"className is required to be a string, but got type "+typeof t.className),S(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),an.register(t)}var mb=Object.freeze(Object.defineProperty({__proto__:null,Serializable:Nf,SerializationMap:an,registerClass:gn},Symbol.toStringTag,{value:"Module"}));const gb=.001,Tf=.1;function yb(t,e,n){return n==null&&(n=Ro()),Ya(t,e,(r,s)=>Bo(r,s,n))}function Ro(){return k.backend.floatPrecision()===32?gb:Tf}function Ya(t,e,n){let r=!0;if((We(t)||We(e))&&(r=!1),We(t)&&We(e)&&(r=!0),r){const o=t.constructor.name,i=e.constructor.name;if(o!==i)throw new Error(`Arrays are of different type. Actual: ${o}. Expected: ${i}`)}if(Array.isArray(t)&&Array.isArray(e)){const o=Ut(t),i=Ut(e);if(!jt(o,i))throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${i}]`)}const s=We(t)?t:An(t),a=We(e)?e:An(e);if(s.length!==a.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${a.length}.
Actual:   ${s}.
Expected: ${a}.`);for(let o=0;o<a.length;++o){const i=s[o],u=a[o];if(!n(i,u))throw new Error(`Arrays differ: actual[${o}] = ${i}, expected[${o}] = ${u}.
Actual:   ${s}.
Expected: ${a}.`)}}function bb(t,e){t().then(()=>e.fail(),()=>e())}function wb(t,e){const n=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return on(t)||on(t[0])||on(e)||on(e[0])?Ya(t,n,(r,s)=>r==s):Ya(t,e,(r,s)=>Bo(r,s,0))}function vb(t,e,n){if(n==null&&(n=Ro()),!Bo(t,e,n))throw new Error(`Numbers differ: actual === ${t}, expected === ${e}`)}function Bo(t,e,n){return!isFinite(t)&&!isFinite(e)?!0:!(isNaN(t)||isNaN(e)||Math.abs(t-e)>n)}function Sb(t,e,n){for(let r=0;r<t.length;r++)if(t[r]<e||t[r]>n)throw new Error(`Value out of range:${t[r]} low: ${e}, high: ${n}`)}function Nb(t,e){const n=new Float32Array(t),r=new Float32Array(e);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let s=0;s<r.length;s++)if(n[s]!==r[s])throw new Error(`Expected ArrayBuffer value at ${s} to be ${r[s]} but got ${n[s]} instead`)}function Ef(t){for(let e=0;e<t.length;e++){const n=t[e];Array.isArray(n)?Ef(n):t[e]=jr(n)}return t}var Tb=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:Tf,expectArraysClose:yb,testEpsilon:Ro,expectPromiseToFail:bb,expectArraysEqual:wb,expectNumbersClose:vb,expectValuesInRange:Sb,expectArrayBuffersEqual:Nb,encodeStrings:Ef},Symbol.toStringTag,{value:"Module"}));const Eb="3.19.0";function kb(t,e){let n=w(t,"a","add"),r=w(e,"b","add");[n,r]=Pe(n,r);const s={a:n,b:r};return k.runKernel(go,s)}const Y=E({add_:kb});function _b(t,e){let n=w(t,"a","floorDiv"),r=w(e,"b","floorDiv");[n,r]=Pe(n,r);const s={a:n,b:r};return k.runKernel(Xl,s)}const Lo=E({floorDiv_:_b});function xb(t,e){let n=w(t,"a","div"),r=w(e,"b","div");if([n,r]=Pe(n,r),n.dtype==="int32"&&r.dtype==="int32")return Lo(n,r);const s={a:n,b:r},a={};return k.runKernel(Bl,s,a)}const _e=E({div_:xb});function $b(t,e){let n=w(t,"a","mul"),r=w(e,"b","mul");[n,r]=Pe(n,r);const s={a:n,b:r};return k.runKernel(xc,s)}const U=E({mul_:$b});function Ab(t){const e=w(t,"x","abs");if(e.dtype==="complex64"){const n={x:e};return k.runKernel(bl,n)}else{const n={x:e};return k.runKernel(Yu,n)}}const at=E({abs_:Ab});function Ib(t){const n={x:w(t,"x","acos")};return k.runKernel(Zu,n)}const kf=E({acos_:Ib});function Ob(t){const n={x:w(t,"x","acosh")};return k.runKernel(Ju,n)}const _f=E({acosh_:Ob});function Db(t){S(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),S(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((s,a)=>w(s,`tensors${a}`,"addN")),n=e[0];e.forEach(s=>{if(s.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!jt(s.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return k.runKernel(Qu,r)}const xf=E({addN_:Db});function Fb(t,e=null,n=!1){const s={x:w(t,"x","all","bool")},a={axis:e,keepDims:n};return k.runKernel(el,s,a)}const $f=E({all_:Fb});function Cb(t,e=null,n=!1){const s={x:w(t,"x","any","bool")},a={axis:e,keepDims:n};return k.runKernel(tl,s,a)}const Af=E({any_:Cb});function Pb(t,e=0){const r={x:w(t,"x","argMax")},s={axis:e};return k.runKernel(nl,r,s)}const Mo=E({argMax_:Pb});function Rb(t,e=0){const r={x:w(t,"x","argMin")},s={axis:e};return k.runKernel(rl,r,s)}const If=E({argMin_:Rb});function Bb(t){const n={x:w(t,"x","asin")};return k.runKernel(sl,n)}const Of=E({asin_:Bb});function Lb(t){const n={x:w(t,"x","asinh")};return k.runKernel(al,n)}const Df=E({asinh_:Lb});function Mb(t){const n={x:w(t,"x","atan")};return k.runKernel(ol,n)}const Ff=E({atan_:Mb});function zb(t,e){let n=w(t,"a","atan2"),r=w(e,"b","atan2");[n,r]=Pe(n,r);const s={a:n,b:r};return k.runKernel(ul,s)}const Cf=E({atan2_:zb});function Vb(t){const n={x:w(t,"x","atanh")};return k.runKernel(il,n)}const Pf=E({atanh_:Vb});function jb(t,e,n,r,s="NHWC",a){const o=t[3],i=[...e,o],u=Lf(s);return Hr(t,i,n,a,r,null,null,u)}function Rf(t,e,n,r,s,a,o="channelsLast"){const[i,u]=Is(e);let l;if(o==="channelsLast")l=[i,u,t[3],t[3]];else if(o==="channelsFirst")l=[i,u,t[1],t[1]];else throw new Error(`Unknown dataFormat ${o}`);return Hr(t,l,n,r,s,a,!1,o)}function Ub(t,e,n,r,s,a,o="NDHWC"){const[i,u,l]=Za(e);let c,h;if(o==="NDHWC")h="channelsLast",c=[i,u,l,t[4],t[4]];else if(o==="NCDHW")h="channelsFirst",c=[i,u,l,t[1],t[1]];else throw new Error(`Unknown dataFormat ${o}`);return Bf(t,c,n,r,s,!1,h,a)}function Hr(t,e,n,r,s,a,o=!1,i="channelsLast"){let[u,l,c,h]=[-1,-1,-1,-1];if(i==="channelsLast")[u,l,c,h]=t;else if(i==="channelsFirst")[u,h,l,c]=t;else throw new Error(`Unknown dataFormat ${i}`);const[p,d,,b]=e,[v,N]=Is(n),[x,F]=Is(r),_=tr(p,x),$=tr(d,F),{padInfo:A,outHeight:C,outWidth:M}=Hb(s,l,c,v,N,_,$,a,i),P=o?b*h:b;let D;return i==="channelsFirst"?D=[u,P,C,M]:i==="channelsLast"&&(D=[u,C,M,P]),{batchSize:u,dataFormat:i,inHeight:l,inWidth:c,inChannels:h,outHeight:C,outWidth:M,outChannels:P,padInfo:A,strideHeight:v,strideWidth:N,filterHeight:p,filterWidth:d,effectiveFilterHeight:_,effectiveFilterWidth:$,dilationHeight:x,dilationWidth:F,inShape:t,outShape:D,filterShape:e}}function Bf(t,e,n,r,s,a=!1,o="channelsLast",i){let[u,l,c,h,p]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[u,l,c,h,p]=t;else if(o==="channelsFirst")[u,p,l,c,h]=t;else throw new Error(`Unknown dataFormat ${o}`);const[d,b,v,,N]=e,[x,F,_]=Za(n),[$,A,C]=Za(r),M=tr(d,$),P=tr(b,A),D=tr(v,C),{padInfo:V,outDepth:z,outHeight:q,outWidth:G}=Gb(s,l,c,h,x,F,_,M,P,D,i),X=a?N*p:N;let oe;return o==="channelsFirst"?oe=[u,X,z,q,G]:o==="channelsLast"&&(oe=[u,z,q,G,X]),{batchSize:u,dataFormat:o,inDepth:l,inHeight:c,inWidth:h,inChannels:p,outDepth:z,outHeight:q,outWidth:G,outChannels:X,padInfo:V,strideDepth:x,strideHeight:F,strideWidth:_,filterDepth:d,filterHeight:b,filterWidth:v,effectiveFilterDepth:M,effectiveFilterHeight:P,effectiveFilterWidth:D,dilationDepth:$,dilationHeight:A,dilationWidth:C,inShape:t,outShape:oe,filterShape:e}}function Wb(t,e,n,r,s){r==null&&(r=zo(t,e,n));const a=t[0],o=t[1],i=_n((a-e+2*r)/n+1,s),u=_n((o-e+2*r)/n+1,s);return[i,u]}function qb(t,e,n,r,s,a){s==null&&(s=zo(t,e,r));const o=t[0],i=t[1],u=t[2],l=_n((o-e+2*s)/r+1,a),c=_n((i-e+2*s)/r+1,a),h=_n((u-e+2*s)/r+1,a);return[l,c,h,n]}function zo(t,e,n,r=1){const s=tr(e,r);return Math.floor((t[0]*(n-1)-n+s)/2)}function Is(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function Za(t){return typeof t=="number"?[t,t,t]:t}function tr(t,e){return e<=1?t:t+(t-1)*(e-1)}function Hb(t,e,n,r,s,a,o,i,u){let l,c,h;if(typeof t=="number"){l={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};const d=Wb([e,n],a,r,t,i);c=d[0],h=d[1]}else if(t==="same"){c=Math.ceil(e/r),h=Math.ceil(n/s);const p=Math.max(0,(c-1)*r+a-e),d=Math.max(0,(h-1)*s+o-n),b=Math.floor(p/2),v=p-b,N=Math.floor(d/2),x=d-N;l={top:b,bottom:v,left:N,right:x,type:"SAME"}}else if(t==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-a+1)/r),h=Math.ceil((n-o+1)/s);else if(typeof t=="object"){const p=u==="channelsLast"?t[1][0]:t[2][0],d=u==="channelsLast"?t[1][1]:t[2][1],b=u==="channelsLast"?t[2][0]:t[3][0],v=u==="channelsLast"?t[2][1]:t[3][1];l={top:p,bottom:d,left:b,right:v,type:p===0&&d===0&&b===0&&v===0?"VALID":"EXPLICIT"},c=_n((e-a+p+d)/r+1,i),h=_n((n-o+b+v)/s+1,i)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:l,outHeight:c,outWidth:h}}function Gb(t,e,n,r,s,a,o,i,u,l,c){let h,p,d,b;if(typeof t=="number"){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};const N=qb([e,n,r,1],i,1,s,t,c);p=N[0],d=N[1],b=N[2]}else if(t==="same"){p=Math.ceil(e/s),d=Math.ceil(n/a),b=Math.ceil(r/o);const v=(p-1)*s+i-e,N=(d-1)*a+u-n,x=(b-1)*o+l-r,F=Math.floor(v/2),_=v-F,$=Math.floor(N/2),A=N-$,C=Math.floor(x/2),M=x-C;h={top:$,bottom:A,left:C,right:M,front:F,back:_,type:"SAME"}}else if(t==="valid")h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},p=Math.ceil((e-i+1)/s),d=Math.ceil((n-u+1)/a),b=Math.ceil((r-l+1)/o);else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:h,outDepth:p,outHeight:d,outWidth:b}}function _n(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function Pr(t){const[e,n,r]=Is(t);return e===1&&n===1&&r===1}function Qt(t,e){return Pr(t)||Pr(e)}function Lf(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function Tt(t,e,n){if(n!=null){if(typeof e=="string")throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if(typeof e=="number")S(rr(e),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(s=>{S(rr(s),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${s}.`)})});else throw Error(`Error in ${t}: Unknown padding parameter: ${e}`)}}function Kb(t,e){const r={x:w(t,"x","reshape","string_or_numeric")},s={shape:e};return k.runKernel(Wc,r,s)}const B=E({reshape_:Kb});function Xb(t,e,n,r,s){const a=w(t,"x","avgPool","float32"),o=1;S(Qt(n,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);let i=a,u=!1;a.rank===3&&(u=!0,i=B(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),Tt("avgPool",r,s);const l={x:i},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s};let h=k.runKernel(ll,l,c);return h=we(h,a.dtype),u?B(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Vo=E({avgPool_:Xb});function Yb(t,e,n,r,s,a="NDHWC"){const o=w(t,"x","avgPool3d","float32");let i=o,u=!1;o.rank===4&&(u=!0,i=B(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),S(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),Tt("avgPool3d",r,s);const l={x:i},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:a};let h=k.runKernel(cl,l,c);return h=we(h,i.dtype),u?B(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const Mf=E({avgPool3d_:Yb});function Zb(t,e=0){S(t.length>=1,()=>"Pass at least one tensor to concat");const n=Dr(t,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),n.length===1)return Zt(n[0]);const r=n,s={axis:e};return k.runKernel(wl,r,s)}const qe=E({concat_:Zb});function Jb(t){const n={x:w(t,"x","sigmoid","float32")};return k.runKernel(ah,n)}const Vt=E({sigmoid_:Jb});function Qb(t,e,n){const r=w(t,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:e,size:n};return k.runKernel(th,s,a)}const Ee=E({slice_:Qb});function e1(t){const n={x:w(t,"x","tanh","float32")};return k.runKernel(Eh,n)}const Os=E({tanh_:e1});function t1(t,e,n,r,s,a){const o=w(t,"forgetBias","basicLSTMCell"),i=w(e,"lstmKernel","basicLSTMCell"),u=w(n,"lstmBias","basicLSTMCell"),l=w(r,"data","basicLSTMCell"),c=w(s,"c","basicLSTMCell"),h=w(a,"h","basicLSTMCell"),p=qe([l,h],1),d=ye(p,i),b=Y(d,u),v=b.shape[0],N=b.shape[1]/4,x=[v,N],F=Ee(b,[0,0],x),_=Ee(b,[0,N],x),$=Ee(b,[0,N*2],x),A=Ee(b,[0,N*3],x),C=Y(U(Vt(F),Os(_)),U(c,Vt(Y(o,$)))),M=U(Os(C),Vt(A));return[C,M]}const zf=E({basicLSTMCell_:t1});function n1(t,e,n){const r=w(t,"x","batchToSpaceND"),s=e.reduce((i,u)=>i*u);S(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),S(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),S(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const a={x:r},o={blockShape:e,crops:n};return k.runKernel(fl,a,o)}const jo=E({batchToSpaceND_:n1});function r1(t){let e;return t.rank===0||t.rank===1?e=B(t,[1,1,1,t.size]):t.rank===2?e=B(t,[1,1,t.shape[0],t.shape[1]]):t.rank===3?e=B(t,[1,t.shape[0],t.shape[1],t.shape[2]]):e=t,e}function s1(t,e,n,r,s,a){a==null&&(a=.001);const o=w(t,"x","batchNorm"),i=w(e,"mean","batchNorm"),u=w(n,"variance","batchNorm");let l;s!=null&&(l=w(s,"scale","batchNorm"));let c;r!=null&&(c=w(r,"offset","batchNorm")),S(i.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(c==null||i.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(l==null||i.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const p={x:r1(o),scale:l,offset:c,mean:i,variance:u},d={varianceEpsilon:a},b=k.runKernel(Yl,p,d);return B(b,o.shape)}const Gr=E({batchNorm_:s1});function a1(t,e,n,r,s,a){const o=w(t,"x","batchNorm"),i=w(e,"mean","batchNorm"),u=w(n,"variance","batchNorm");let l;s!=null&&(l=w(s,"scale","batchNorm"));let c;return r!=null&&(c=w(r,"offset","batchNorm")),S(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),S(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),S(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&S(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&S(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Gr(o,i,u,c,l,a)}const Vf=E({batchNorm2d_:a1});function o1(t,e,n,r,s,a){const o=w(t,"x","batchNorm"),i=w(e,"mean","batchNorm"),u=w(n,"variance","batchNorm");let l;s!=null&&(l=w(s,"scale","batchNorm"));let c;return r!=null&&(c=w(r,"offset","batchNorm")),S(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),S(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),S(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&S(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&S(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Gr(o,i,u,c,l,a)}const jf=E({batchNorm3d_:o1});function i1(t,e,n,r,s,a){const o=w(t,"x","batchNorm"),i=w(e,"mean","batchNorm"),u=w(n,"variance","batchNorm");let l;s!=null&&(l=w(s,"scale","batchNorm"));let c;return r!=null&&(c=w(r,"offset","batchNorm")),S(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),S(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),S(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&S(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&S(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Gr(o,i,u,c,l,a)}const Uf=E({batchNorm4d_:i1});function u1(t,e,n){const r=w(t,"x","bincount"),s=w(e,"weights","bincount");S(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),S(n>=0,()=>`size must be non-negative, but got ${n}.`),S(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const a={x:r,weights:s},o={size:n};return k.runKernel(pl,a,o)}const Uo=E({bincount_:u1});function l1(t,e){const n=w(t,"s0","broadcastArgs","int32"),r=w(e,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:n,s1:r};return k.runKernel(dl,s)}const Wf=E({broadcastArgs_:l1});function c1(t,e){let n=w(t,"broadcastTo","x");const r=n.shape;if(e.some(l=>!(l>0)||l%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const l=n.shape.slice();for(;l.length<e.length;)l.unshift(1);n=B(n,l)}const s=n.shape,a=Array.from(e);for(let l=e.length-1;l>=0;l--)if(s[l]===e[l])a[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(a.map((l,c)=>l>1?c:-1).filter(l=>l>=0).length===0)return Zt(n);const i={x:n},u={reps:a};return k.runKernel(wo,i,u)}const xr=E({broadcastTo_:c1});function h1(t){const n={x:w(t,"x","ceil","float32")};return k.runKernel(ml,n)}const qf=E({ceil_:h1});function f1(t,e,n){const r=w(t,"x","clipByValue");S(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`);const s={x:r},a={clipValueMin:e,clipValueMax:n};return k.runKernel(gl,s,a)}const Hf=E({clipByValue_:f1});function p1(t){return qe(t,0)}const Gf=E({concat1d_:p1});function d1(t,e){return qe(t,e)}const Kf=E({concat2d_:d1});function m1(t,e){return qe(t,e)}const Xf=E({concat3d_:m1});function g1(t,e){return qe(t,e)}const Yf=E({concat4d_:g1});function y1(t,e,n,r,s="NHWC",a=[1,1],o){const i=w(t,"x","conv2d","float32"),u=w(e,"filter","conv2d","float32");let l=i,c=!1;i.rank===3&&(c=!0,l=B(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),S(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),Tt("conv2d",r,o);const h=s==="NHWC"?l.shape[3]:l.shape[1];S(h===u.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${u.shape[2]}.`),S(Qt(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const p={x:l,filter:u},d={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o},b=k.runKernel(vl,p,d);return c?B(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Kr=E({conv2d_:y1});function b1(t,e,n,r,s="NWC",a=1,o){const i=w(t,"x","conv1d"),u=w(e,"filter","conv1d");let l=i,c=!1;i.rank===2&&(c=!0,l=B(i,[1,i.shape[0],i.shape[1]])),S(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),S(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),Tt("conv1d",r,o),S(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),S(Qt(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),S(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=B(u,[1,u.shape[0],u.shape[1],u.shape[2]]),p=B(l,[l.shape[0],1,l.shape[1],l.shape[2]]),N=Kr(p,h,[1,n],r,"NHWC",[1,a],o);return c?B(N,[N.shape[2],N.shape[3]]):B(N,[N.shape[0],N.shape[2],N.shape[3]])}const Zf=E({conv1d_:b1});function w1(t,e,n,r,s,a="NHWC",o){S(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let i=t,u=e,l=!1;e.rank===3&&(l=!0,u=B(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,t[0],t[1],t[2]]),S(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),S(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),S(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c=a==="NHWC"?i[3]:i[1],h=a==="NHWC"?u.shape[3]:u.shape[1];S(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),S(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),Tt("conv2dDerInput",s,o);const p={dy:u,filter:n},d={strides:r,pad:s,dataFormat:a,dimRoundingMode:o,inputShape:i},b=k.runKernel(Nl,p,d);return l?B(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Jf=E({conv2DBackpropInput_:w1});function v1(t,e,n,r,s,a){const o=w(t,"x","conv2dTranspose"),i=w(e,"filter","conv2dTranspose");return Jf(n,o,i,r,s,"NHWC",a)}const Qf=E({conv2dTranspose_:v1});function S1(t,e,n,r,s="NDHWC",a=[1,1,1]){const o=w(t,"x","conv3d"),i=w(e,"filter","conv3d");let u=o,l=!1;o.rank===4&&(l=!0,u=B(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),S(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),S(u.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`),S(Qt(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),S(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const c={x:u,filter:i},h={strides:n,pad:r,dataFormat:s,dilations:a},p=k.runKernel(Tl,c,h);return l?B(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const ep=E({conv3d_:S1});function N1(t,e,n,r,s){S(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let a=t,o=e,i=!1;e.rank===4&&(i=!0,o=B(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),a=[1,t[0],t[1],t[2],t[3]]);const u=a[4],l=o.shape[4];S(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),S(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),S(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),S(u===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`),S(l===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`);const c={dy:o,filter:n},h={pad:s,strides:r,inputShape:a},p=k.runKernel(El,c,h);return i?B(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const T1=E({conv3DBackpropInput_:N1});function E1(t,e,n,r,s){const a=w(t,"x","conv3dTranspose"),o=w(e,"filter","conv3dTranspose");return T1(n,a,o,r,s)}const tp=E({conv3dTranspose_:E1});function k1(t){const n={x:w(t,"x","cos","float32")};return k.runKernel(kl,n)}const np=E({cos_:k1});function _1(t){const n={x:w(t,"x","cosh","float32")};return k.runKernel(_l,n)}const rp=E({cosh_:_1});function x1(t,e=0,n=!1,r=!1){const a={x:w(t,"x","cumprod")},o={axis:e,exclusive:n,reverse:r};return k.runKernel(xl,a,o)}const sp=E({cumprod_:x1});function $1(t,e=0,n=!1,r=!1){const a={x:w(t,"x","cumsum")},o={axis:e,exclusive:n,reverse:r};return k.runKernel($l,a,o)}const ap=E({cumsum_:$1});function A1(t,e,n,r=!1){const s=w(t,"x","denseBincount"),a=w(e,"weights","denseBincount");S(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),S(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),S(n>=0,()=>`size must be non-negative, but got ${n}.`),S(a.size===s.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`);const o={x:s,weights:a},i={size:n,binaryOutput:r};return k.runKernel(Il,o,i)}const op=E({denseBincount_:A1});function I1(t,e,n="NHWC"){const r=w(t,"x","depthToSpace","float32"),s=n==="NHWC"?r.shape[1]:r.shape[2],a=n==="NHWC"?r.shape[2]:r.shape[3],o=n==="NHWC"?r.shape[3]:r.shape[1];S(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),S(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),S(a*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${e} for depthToSpace with input shape
        ${r.shape}`),S(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${r.shape}`);const i={x:r},u={blockSize:e,dataFormat:n};return k.runKernel(Ol,i,u)}const ip=E({depthToSpace_:I1});function O1(t,e,n,r,s="NHWC",a=[1,1],o){const i=w(t,"x","depthwiseConv2d","float32"),u=w(e,"filter","depthwiseConv2d","float32");let l=i,c=!1;i.rank===3&&(c=!0,l=B(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),S(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const h=s==="NHWC"?l.shape[3]:l.shape[1];S(h===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${u.shape[2]}.`),Tt("depthwiseConv2d",r,o);const p={x:l,filter:u},d={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o},b=k.runKernel(Dl,p,d);return c?B(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const js=E({depthwiseConv2d_:O1});function D1(t){const n={x:w(t,"x","diag")};return k.runKernel(Pl,n)}const up=E({diag_:D1});function F1(t,e,n,r,s=[1,1],a="NHWC"){const o=w(t,"x","dilation2d"),i=w(e,"filter","dilation2d");S(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),S(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),S(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let u=o,l=!1;o.rank===3&&(u=B(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=!0);const c={x:u,filter:i},h={strides:n,pad:r,dilations:s},p=k.runKernel(Rl,c,h);return l?B(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const lp=E({dilation2d_:F1});function C1(t,e){let n=w(t,"a","equal","string_or_numeric"),r=w(e,"b","equal","string_or_numeric");[n,r]=Pe(n,r),Me(n.shape,r.shape);const s={a:n,b:r};return k.runKernel(Vl,s)}const Xr=E({equal_:C1});function P1(t,e,n){const r=w(e,"a","where"),s=w(n,"b","where"),a=w(t,"condition","where","bool"),o=Me(Me(a.shape,r.shape),s.shape),i=xr(a,o),u=xr(r,o),l=xr(s,o),c={condition:i,t:u,e:l};return k.runKernel(Qc,c)}const Cn=E({where_:P1});function R1(t){const n={x:w(t,"x","zerosLike")};return k.runKernel(Ih,n)}const ut=E({zerosLike_:R1});function B1(t,e){let n=w(t,"a","div"),r=w(e,"b","div");[n,r]=Pe(n,r);const s=_e(n,r),a=ut(s),o=Xr(r,a);return Cn(o,a,s)}const cp=E({divNoNan_:B1});function L1(t,e){const n=w(t,"t1","dot"),r=w(e,"t2","dot");S((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const s=n.rank===1?n.size:n.shape[1],a=r.rank===1?r.size:r.shape[0];if(S(s===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`),n.rank===1&&r.rank===1){const o=B(n,[1,-1]),i=B(r,[-1,1]),u=ye(o,i);return B(u,[])}else if(n.rank===1&&r.rank===2){const o=B(n,[1,-1]),i=B(r,[r.shape[0],r.shape[1]]),u=ye(o,i);return B(u,[u.size])}else if(n.rank===2&&r.rank===1){const o=B(r,[-1,1]),i=ye(n,o);return B(i,[i.size])}else{const o=B(r,[r.shape[0],r.shape[1]]);return ye(n,o)}}const hp=E({dot_:L1});function M1(t,...e){const n=e.map((s,a)=>w(s,`tensors${a}`,"einsum")),r={equation:t};return k.runKernel(Ll,n,r)}const fp=E({einsum_:M1});function z1(t){const n={x:w(t,"x","elu","float32")};return k.runKernel(Ml,n)}const Wo=E({elu_:z1});function V1(t){let e=w(t,"x","erf");S(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=we(e,"float32"));const n={x:e};return k.runKernel(zl,n)}const pp=E({erf_:V1});function qo(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function dp(t,e,n){const r=t.length+e.length,s=[];let a=0,o=0;for(let i=0;i<r;i++)n.indexOf(i)===-1?s.push(t[a++]):s.push(e[o++]);return s}function j1(t,e){const n=[],r=t.length;for(let a=0;a<r;a++)e.indexOf(a)===-1&&n.push(t[a]);const s=e.map(a=>t[a]);return[n,s]}function Yr(t,e){const n=e.map(r=>1);return dp(t,n,e)}function U1(t,e,n){S(qo(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function W1(t,e){if(qo(t,e))return null;const n=[];for(let r=0;r<e;++r)t.indexOf(r)===-1&&n.push(r);return t.forEach(r=>n.push(r)),n}function q1(t){return t.map((e,n)=>[n,e]).sort((e,n)=>e[1]-n[1]).map(e=>e[0])}function H1(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}function G1(t,e=null,n=!1){const s={x:w(t,"x","max")},a={reductionIndices:e,keepDims:n};return k.runKernel(gc,s,a)}const xn=E({max_:G1});function K1(t,e=null,n=!1){const s={x:w(t,"x","min")},a={axis:e,keepDims:n};return k.runKernel(Nc,s,a)}const Ds=E({min_:K1});function X1(t,e){let n=w(t,"base","pow"),r=w(e,"exp","pow");[n,r]=Pe(n,r);const s={a:n,b:r};return k.runKernel(Bc,s)}const ur=E({pow_:X1});function se(t,e){if((We(t)&&e!=="string"||Array.isArray(t))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&We(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return mn(t,[],[],e)}function Y1(t){const n={x:w(t,"x","sqrt","float32")};return k.runKernel(ih,n)}const qt=E({sqrt_:Y1});function Z1(t){const e=w(t,"x","square"),n={};return k.runKernel("Square",{x:e},n)}const St=E({square_:Z1});function J1(t,e=null,n=!1){let r=w(t,"x","sum");r.dtype==="bool"&&(r=we(r,"int32"));const s={x:r},a={axis:e,keepDims:n};return k.runKernel(uh,s,a)}const $e=E({sum_:J1});function Q1(t,e="euclidean",n=null,r=!1){t=w(t,"x","norm");const s=mp(t,e,n);let a=s.shape;if(r){const o=zr(n,t.shape);a=Yr(s.shape,o)}return B(s,a)}function mp(t,e,n=null){if(t.rank===0)return at(t);if(t.rank!==1&&n===null)return mp(B(t,[-1]),e,n);if(t.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(e===1)return $e(at(t),n);if(e===1/0)return xn(at(t),n);if(e===-1/0)return Ds(at(t),n);if(e==="euclidean"||e===2)return qt($e(ur(at(t),se(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&n.length===2){if(e===1)return xn($e(at(t),n[0]),n[1]-1);if(e===1/0)return xn($e(at(t),n[1]),n[0]);if(e===-1/0)return Ds($e(at(t),n[1]),n[0]);if(e==="fro"||e==="euclidean")return qt($e(St(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Zr=E({norm_:Q1});function ew(t,e=null,n=!1){return Zr(t,"euclidean",e,n)}const gp=E({euclideanNorm_:ew});function tw(t){const n={x:w(t,"x","exp")};return k.runKernel(jl,n)}const fn=E({exp_:tw});function nw(t,e=0){const n=w(t,"x","expandDims","string_or_numeric");S(e<=n.rank,()=>"Axis must be <= rank of the tensor");const r={input:n},s={dim:e};return k.runKernel(Ul,r,s)}const ot=E({expandDims_:nw});function rw(t){const n={x:w(t,"x","expm1")};return k.runKernel(Wl,n)}const yp=E({expm1_:rw});function sw(t,e){const n=w(t,"x","tile","string_or_numeric");S(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);const r={x:n},s={reps:e};return k.runKernel(wo,r,s)}const nr=E({tile_:sw});function aw(t,e,n,r="float32"){e==null&&(e=t);const s=Wt([t,e],r),a=t<=e?t:e;for(let i=0;i<a;++i)s.set(1,i,i);const o=B(s.toTensor(),[t,e]);if(n==null)return o;if(n.length===1)return nr(ot(o,0),[n[0],1,1]);if(n.length===2)return nr(ot(ot(o,0),0),[n[0],n[1],1,1]);if(n.length===3)return nr(ot(ot(ot(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const Ho=E({eye_:aw});function Jr(t,e,n){const r={shape:t,value:e,dtype:n};return k.runKernel(Hl,{},r)}function ow(t){const n={x:w(t,"x","floor","float32")};return k.runKernel(Kl,n)}const Go=E({floor_:ow});function iw(t,e,n=0,r=0){const s=w(t,"x","gather"),a=w(e,"indices","gather","int32"),o={x:s,indices:a},i={axis:n,batchDims:r};return k.runKernel(Zl,o,i)}const Ko=E({gather_:iw});function uw(t,e){let n=w(t,"a","greater","string_or_numeric"),r=w(e,"b","greater","string_or_numeric");[n,r]=Pe(n,r),Me(n.shape,r.shape);const s={a:n,b:r};return k.runKernel(Ql,s)}const fr=E({greater_:uw});function lw(t,e){let n=w(t,"a","greaterEqual","string_or_numeric"),r=w(e,"b","greaterEqual","string_or_numeric");[n,r]=Pe(n,r),Me(n.shape,r.shape);const s={a:n,b:r};return k.runKernel(ec,s)}const Xo=E({greaterEqual_:lw});function cw(t){const n={x:w(t,"x","isFinite")};return k.runKernel(rc,n)}const bp=E({isFinite_:cw});function hw(t){const n={x:w(t,"x","isInf")};return k.runKernel(sc,n)}const wp=E({isInf_:hw});function fw(t){const n={x:w(t,"x","isNaN")};return k.runKernel(ac,n)}const vp=E({isNaN_:fw});function pw(t,e=.2){const r={x:w(t,"x","leakyRelu")},s={alpha:e};return k.runKernel(oc,r,s)}const Yo=E({leakyRelu_:pw});function dw(t,e){let n=w(t,"a","less","string_or_numeric"),r=w(e,"b","less","string_or_numeric");[n,r]=Pe(n,r),Me(n.shape,r.shape);const s={a:n,b:r};return k.runKernel(ic,s)}const Sp=E({less_:dw});function mw(t,e){let n=w(t,"a","lessEqual","string_or_numeric"),r=w(e,"b","lessEqual","string_or_numeric");[n,r]=Pe(n,r),Me(n.shape,r.shape);const s={a:n,b:r};return k.runKernel(uc,s)}const Us=E({lessEqual_:mw});function Np(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:t,stop:e,num:n};return k.runKernel(lc,{},r)}function gw(t,e=5,n=1,r=1,s=.5){const a=w(t,"x","localResponseNormalization");S(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),S(rr(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=a,i=!1;a.rank===3&&(i=!0,o=B(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const u={x:o},l={depthRadius:e,bias:n,alpha:r,beta:s},c=k.runKernel(mc,u,l);return i?B(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Tp=E({localResponseNormalization_:gw});function yw(t){const n={x:w(t,"x","log","float32")};return k.runKernel(cc,n)}const lr=E({log_:yw});function bw(t){const n={x:w(t,"x","log1p")};return k.runKernel(hc,n)}const Zo=E({log1p_:bw});function ww(t){return S(hn(t),()=>"The f passed in grad(f) must be a function"),(e,n)=>{const r=w(e,"x","tf.grad","string_or_numeric"),s=n!=null?w(n,"dy","tf.grad"):null;return k.tidy(()=>{const{value:a,grads:o}=k.gradients(()=>t(r),[r],s);return s!=null&&Qe(a.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Ws(o),o[0]})}}function vw(t){return S(hn(t),()=>"The f passed in grads(f) must be a function"),(e,n)=>{S(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const r=Dr(e,"args","tf.grads","string_or_numeric"),s=n!=null?w(n,"dy","tf.grads"):null;return k.tidy(()=>{const{value:a,grads:o}=k.gradients(()=>t(...r),r,s);return s!=null&&Qe(a.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Ws(o),o})}}function Sw(t){return S(hn(t),()=>"The f passed in valueAndGrad(f) must be a function"),(e,n)=>{S(e instanceof be,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),S(n==null||n instanceof be,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:r,value:s}=k.gradients(()=>t(e),[e],n);return Ws(r),{grad:r[0],value:s}}}function Nw(t){return S(hn(t),()=>"The f passed in valueAndGrads(f) must be a function"),(e,n)=>{S(Array.isArray(e)&&e.every(s=>s instanceof be),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),S(n==null||n instanceof be,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const r=k.gradients(()=>t(...e),e,n);return n!=null&&Qe(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Ws(r.grads),r}}function Ep(t,e){S(hn(t),()=>"The f passed in variableGrads(f) must be a function"),S(e==null||Array.isArray(e)&&e.every(l=>l instanceof Or),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=e!=null;if(!n){e=[];for(const l in k.registeredVariables)e.push(k.registeredVariables[l])}const r=n?e.filter(l=>!l.trainable):null,s=e.length;e=e.filter(l=>l.trainable),S(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const a=!0,{value:o,grads:i}=k.gradients(t,e,null,a);S(i.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),S(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const u={};return e.forEach((l,c)=>{i[c]!=null&&(u[l.name]=i[c])}),r?.forEach(l=>u[l.name]=null),{value:o,grads:u}}function Ht(t){return k.customGrad(t)}function Ws(t){if(t.filter(n=>n==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function Tw(t){const n={x:w(t,"x","softplus")};return k.runKernel(oh,n)}const Jo=E({softplus_:Tw});function Ew(t){const e=w(t,"x","logSigmoid");return Ht(r=>({value:zt(Jo(zt(r))),gradFunc:o=>U(o,Vt(zt(r)))}))(e)}const kp=E({logSigmoid_:Ew});function kw(t,e){let n=w(t,"a","sub"),r=w(e,"b","sub");[n,r]=Pe(n,r);const s={a:n,b:r};return k.runKernel(Nh,s)}const ne=E({sub_:kw});function _w(t,e=-1){const n=w(t,"logits","logSoftmax");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return Ht((s,a)=>{const i=xn(s,e,!0),u=ne(s,i),l=ne(we(u,"float32"),lr($e(fn(u),e,!0)));return a([l]),{value:l,gradFunc:(h,p)=>{const[d]=p,b=!0,v=fn(d);return ne(h,U($e(h,e,b),v))}}})(n)}const _p=E({logSoftmax_:_w});function xw(t,e=null,n=!1){const r=w(t,"x","logSumExp"),s=zr(e,r.shape),a=xn(r,s,!0),o=ne(r,a),i=fn(o),u=$e(i,s),l=lr(u),c=Y(B(a,l.shape),l);if(n){const h=Yr(c.shape,s);return B(c,h)}return c}const Qo=E({logSumExp_:xw});function $w(t,e){const n=w(t,"a","logicalAnd","bool"),r=w(e,"b","logicalAnd","bool");Me(n.shape,r.shape);const s={a:n,b:r};return k.runKernel(fc,s)}const Rr=E({logicalAnd_:$w});function Aw(t){const n={x:w(t,"x","logicalNot","bool")};return k.runKernel(pc,n)}const ei=E({logicalNot_:Aw});function Iw(t,e){const n=w(t,"a","logicalOr","bool"),r=w(e,"b","logicalOr","bool");Me(n.shape,r.shape);const s={a:n,b:r};return k.runKernel(dc,s)}const ti=E({logicalOr_:Iw});function Ow(t,e){const n=w(t,"a","logicalXor","bool"),r=w(e,"b","logicalXor","bool");return Me(n.shape,r.shape),Rr(ti(t,e),ei(Rr(t,e)))}const xp=E({logicalXor_:Ow});const us=2147483648;function Dw(t,e,n="left"){const r=w(t,"sortedSequence","searchSorted"),s=w(e,"values","searchSorted"),a=r.shape[r.shape.length-1],o=s.shape[s.shape.length-1],i=B(r,[-1,a]),u=B(s,[-1,o]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Ae(u.shape)>=us)throw new Error(`values tensor size must less than ${us}`);if(i.shape[1]>=us)throw new Error(`trailing dim_size must less than ${us} for int32 output type, was ${i.shape[1]}`);const l={sortedSequence:i,values:u},c={side:n};return k.runKernel(Jc,l,c)}const qs=E({searchSorted_:Dw});function $p(t,e){return qs(t,e,"left")}function Fw(t,e,n,r,s){const a=w(t,"x","maxPool"),o=1;let i=a,u=!1;a.rank===3&&(u=!0,i=B(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),S(Qt(n,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),Tt("maxPool",r,s);const l={x:i},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s},h=k.runKernel(bc,l,c);return u?B(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const ni=E({maxPool_:Fw});function Cw(t,e=[1,1,1],n,r,s,a="NDHWC"){const o=w(t,"x","maxPool3d");let i=o,u=!1;o.rank===4&&(u=!0,i=B(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),S(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),Tt("maxPool3d",r,s);const l={x:i},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},h=k.runKernel(wc,l,c);return u?B(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const Ap=E({maxPool3d_:Cw});function Pw(t,e,n,r,s=!1){const o={x:w(t,"x","maxPoolWithArgmax")},i={filterSize:e,strides:n,pad:r,includeBatchInIndex:s},u=k.runKernel(vc,o,i);return{result:u[0],indexes:u[1]}}const Ip=E({maxPoolWithArgmax_:Pw});function Rw(t,e){let n=w(t,"a","maximum"),r=w(e,"b","maximum");[n,r]=Pe(n,r),n.dtype==="bool"&&(n=we(n,"int32"),r=we(r,"int32")),Me(n.shape,r.shape);const s={a:n,b:r};return k.runKernel(yc,s)}const ri=E({maximum_:Rw});function Bw(t,e=null,n=!1){const s={x:w(t,"x","mean")},a={axis:e,keepDims:n};return k.runKernel(Sc,s,a)}const Br=E({mean_:Bw});function Pn(t,e="float32"){if(e==="complex64"){const r=Pn(t,"float32"),s=Pn(t,"float32");return Jt(r,s)}const n=Ls(Ae(t),e);return k.makeTensor(n,t,e)}function ln(t,e="float32"){if(e==="complex64"){const r=ln(t,"float32"),s=Pn(t,"float32");return Jt(r,s)}const n=ho(Ae(t),e);return k.makeTensor(n,t,e)}function Op(t,e,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(t===void 0)return[];let r=w(t,"x","meshgrid",t instanceof be?t.dtype:"float32");if(e===void 0)return[r];let s=w(e,"y","meshgrid",e instanceof be?e.dtype:"float32");const a=Ae(r.shape),o=Ae(s.shape);return n==="xy"?(r=B(r,[1,-1]),s=B(s,[-1,1]),[ye(ln([o,1],r.dtype),r),ye(s,ln([1,a],s.dtype))]):(r=B(r,[-1,1]),s=B(s,[1,-1]),[ye(r,ln([1,o],r.dtype)),ye(ln([a,1],s.dtype),s)])}function Lw(t,e){let n=w(t,"a","minimum"),r=w(e,"b","minimum");[n,r]=Pe(n,r),n.dtype==="bool"&&(n=we(n,"int32"),r=we(r,"int32")),Me(n.shape,r.shape);const s={a:n,b:r};return k.runKernel(Tc,s)}const si=E({minimum_:Lw});function Mw(t,e,n){S(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=w(t,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");S(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=n==="reflect"?1:0;for(let i=0;i<r.rank;i++)S(e[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),S(e[i][0]>=0&&e[i][0]<=r.shape[i]-s&&e[i][1]>=0&&e[i][1]<=r.shape[i]-s,()=>`Padding in dimension ${i} cannot be greater than or equal to ${r.shape[i]-s} or less than 0 for input of shape ${r.shape}`);const a={paddings:e,mode:n},o={x:r};return k.runKernel(Ec,o,a)}const ai=E({mirrorPad_:Mw});function zw(t,e){let n=w(t,"a","mod"),r=w(e,"b","mod");[n,r]=Pe(n,r);const s={a:n,b:r};return k.runKernel(kc,s)}const Dp=E({mod_:zw});function Vw(t,e=null,n=!1){t=w(t,"x","moments");const r=zr(e,t.shape),s=Br(t,r,n);let a=s.shape;n||(a=Yr(s.shape,r));const o=St(ne(we(t,"float32"),B(s,a))),i=Br(o,r,n);return{mean:s,variance:i}}const Fp=E({moments_:Vw});function jw(t,e,n,r){const s=w(e,"data","multiRNNCell"),a=Dr(n,"c","multiRNNCell"),o=Dr(r,"h","multiRNNCell");let i=s;const u=[];for(let h=0;h<t.length;h++){const p=t[h](i,a[h],o[h]);u.push(p[0]),u.push(p[1]),i=p[1]}const l=[],c=[];for(let h=0;h<u.length;h+=2)l.push(u[h]),c.push(u[h+1]);return[l,c]}const Cp=E({multiRNNCell_:jw});function Uw(t,e,n,r=!1){const s=w(t,"logits","multinomial"),a=s.size,o=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n=n||Math.random();const u={logits:o===1?B(s,[1,-1]):s},l={numSamples:e,seed:n,normalized:r},c=k.runKernel(_c,u,l);return o===1?B(c,[c.size]):c}const Pp=E({multinomial_:Uw});function Ww(t,e){let n=w(t,"a","notEqual","string_or_numeric"),r=w(e,"b","notEqual","string_or_numeric");[n,r]=Pe(n,r),Me(n.shape,r.shape);const s={a:n,b:r};return k.runKernel(Ac,s)}const oi=E({notEqual_:Ww});function qw(t){const n={x:w(t,"x","onesLike")};return k.runKernel(Fc,n)}const Rp=E({onesLike_:qw});function Hw(t,e){const n=w(t,"v1","outerProduct"),r=w(e,"v2","outerProduct");S(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);const s=B(n,[-1,1]),a=B(r,[1,-1]);return ye(s,a)}const Bp=E({outerProduct_:Hw});function Gw(t,e,n=0){const r=w(t,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:n},a={x:r};return k.runKernel(Rc,a,s)}const zn=E({pad_:Gw});function Kw(t,e,n=0){return S(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),zn(t,[e],n)}const Lp=E({pad1d_:Kw});function Xw(t,e,n=0){return S(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),zn(t,e,n)}const Mp=E({pad2d_:Xw});function Yw(t,e,n=0){return S(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),zn(t,e,n)}const ii=E({pad3d_:Yw});function Zw(t,e,n=0){return S(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),zn(t,e,n)}const zp=E({pad4d_:Zw});function Jw(t,e,n){const r=w(t,"x","spaceToBatchND");S(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),S(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),S(r.shape.reduce((o,i,u)=>u>0&&u<=e.length?o&&(i+n[u-1][0]+n[u-1][1])%e[u-1]===0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},a={blockShape:e,paddings:n};return k.runKernel(lh,s,a)}const ui=E({spaceToBatchND_:Jw});function Qw(t,e,n,r,s,a,o){s==null&&(s=[1,1]),a==null&&(a=1),r===0&&(r="valid");const i=w(t,"x","maxPool");let u=i,l=!1;i.rank===3&&(l=!0,u=B(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(Qt(a,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`);const c=Rf(u.shape,e,a,s,r),h=[c.dilationHeight,c.dilationWidth];let p;r==="same"?p=tv([c.filterHeight,c.filterWidth],h):p=[[0,0],[0,0]];const d=h[0]===1&&h[1]===1,[b,v]=ev([c.inHeight,c.inWidth],h,p),N=d?r:"valid",x=d?u:ui(u,h,b),_=(n==="avg"?()=>Vo(x,e,a,N,o):()=>ni(x,e,a,N,o))(),$=d?_:jo(_,h,v);return l?B($,[$.shape[1],$.shape[2],$.shape[3]]):$}function ev(t,e,n){const r=n.map(c=>c[0]),s=n.map(c=>c[1]),a=t.concat(r,s),o=e.map((c,h)=>(c-a[h]%c)%c),i=s.map((c,h)=>c+o[h]),u=e.map((c,h)=>[r[h],i[h]]),l=e.map((c,h)=>[0,o[h]]);return[u,l]}function tv(t,e){const r=t.map((o,i)=>o+(o-1)*(e[i]-1)).map(o=>o-1),s=r.map(o=>Math.floor(o/2)),a=r.map((o,i)=>o-s[i]);return r.map((o,i)=>[s[i],a[i]])}const Vp=E({pool_:Qw});function nv(t,e){const n=w(t,"x","prelu"),r=w(e,"alpha","prelu"),s={x:n,alpha:r};return k.runKernel(Lc,s)}const li=E({prelu_:nv});function rv(t,e=null,n=!1){let r=w(t,"x","prod");r.dtype==="bool"&&(r=we(r,"int32"));const s={x:r},a={axis:e,keepDims:n};return k.runKernel(Mc,s,a)}const jp=E({prod_:rv});function sv(t,e,n){const r=Ae(t);let s=null;if(n==null||n==="float32")s=new Float32Array(r);else if(n==="int32")s=new Int32Array(r);else if(n==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let a=0;a<r;a++)s[a]=e();return k.makeTensor(s,t,n)}const Up=E({rand_:sv});var Wp={exports:{}};(function(t){(function(e,n,r){function s(u){var l=this,c=i();l.next=function(){var h=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=h-(l.c=h|0)},l.c=1,l.s0=c(" "),l.s1=c(" "),l.s2=c(" "),l.s0-=c(u),l.s0<0&&(l.s0+=1),l.s1-=c(u),l.s1<0&&(l.s1+=1),l.s2-=c(u),l.s2<0&&(l.s2+=1),c=null}function a(u,l){return l.c=u.c,l.s0=u.s0,l.s1=u.s1,l.s2=u.s2,l}function o(u,l){var c=new s(u),h=l&&l.state,p=c.next;return p.int32=function(){return c.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,h&&(typeof h=="object"&&a(h,c),p.state=function(){return a(c,{})}),p}function i(){var u=4022871197,l=function(c){c=String(c);for(var h=0;h<c.length;h++){u+=c.charCodeAt(h);var p=.02519603282416938*u;u=p>>>0,p-=u,p*=u,u=p>>>0,p-=u,u+=p*4294967296}return(u>>>0)*23283064365386963e-26};return l}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.alea=o})(Mt,t,!1)})(Wp);var qp={exports:{}};(function(t){(function(e,n,r){function s(i){var u=this,l="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var h=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^h^h>>>8},i===(i|0)?u.x=i:l+=i;for(var c=0;c<l.length+64;c++)u.x^=l.charCodeAt(c)|0,u.next()}function a(i,u){return u.x=i.x,u.y=i.y,u.z=i.z,u.w=i.w,u}function o(i,u){var l=new s(i),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,b=(p+d)/(1<<21);while(b===0);return b},h.int32=l.next,h.quick=h,c&&(typeof c=="object"&&a(c,l),h.state=function(){return a(l,{})}),h}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xor128=o})(Mt,t,!1)})(qp);var Hp={exports:{}};(function(t){(function(e,n,r){function s(i){var u=this,l="";u.next=function(){var h=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(h^h<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,i===(i|0)?u.x=i:l+=i;for(var c=0;c<l.length+64;c++)u.x^=l.charCodeAt(c)|0,c==l.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function a(i,u){return u.x=i.x,u.y=i.y,u.z=i.z,u.w=i.w,u.v=i.v,u.d=i.d,u}function o(i,u){var l=new s(i),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,b=(p+d)/(1<<21);while(b===0);return b},h.int32=l.next,h.quick=h,c&&(typeof c=="object"&&a(c,l),h.state=function(){return a(l,{})}),h}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xorwow=o})(Mt,t,!1)})(Hp);var Gp={exports:{}};(function(t){(function(e,n,r){function s(i){var u=this;u.next=function(){var c=u.x,h=u.i,p,d;return p=c[h],p^=p>>>7,d=p^p<<24,p=c[h+1&7],d^=p^p>>>10,p=c[h+3&7],d^=p^p>>>3,p=c[h+4&7],d^=p^p<<7,p=c[h+7&7],p=p^p<<13,d^=p^p<<9,c[h]=d,u.i=h+1&7,d};function l(c,h){var p,d=[];if(h===(h|0))d[0]=h;else for(h=""+h,p=0;p<h.length;++p)d[p&7]=d[p&7]<<15^h.charCodeAt(p)+d[p+1&7]<<13;for(;d.length<8;)d.push(0);for(p=0;p<8&&d[p]===0;++p);for(p==8&&(d[7]=-1),c.x=d,c.i=0,p=256;p>0;--p)c.next()}l(u,i)}function a(i,u){return u.x=i.x.slice(),u.i=i.i,u}function o(i,u){i==null&&(i=+new Date);var l=new s(i),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,b=(p+d)/(1<<21);while(b===0);return b},h.int32=l.next,h.quick=h,c&&(c.x&&a(c,l),h.state=function(){return a(l,{})}),h}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xorshift7=o})(Mt,t,!1)})(Gp);var Kp={exports:{}};(function(t){(function(e,n,r){function s(i){var u=this;u.next=function(){var c=u.w,h=u.X,p=u.i,d,b;return u.w=c=c+1640531527|0,b=h[p+34&127],d=h[p=p+1&127],b^=b<<13,d^=d<<17,b^=b>>>15,d^=d>>>12,b=h[p]=b^d,u.i=p,b+(c^c>>>16)|0};function l(c,h){var p,d,b,v,N,x=[],F=128;for(h===(h|0)?(d=h,h=null):(h=h+"\0",d=0,F=Math.max(F,h.length)),b=0,v=-32;v<F;++v)h&&(d^=h.charCodeAt((v+32)%h.length)),v===0&&(N=d),d^=d<<10,d^=d>>>15,d^=d<<4,d^=d>>>13,v>=0&&(N=N+1640531527|0,p=x[v&127]^=d+N,b=p==0?b+1:0);for(b>=128&&(x[(h&&h.length||0)&127]=-1),b=127,v=4*128;v>0;--v)d=x[b+34&127],p=x[b=b+1&127],d^=d<<13,p^=p<<17,d^=d>>>15,p^=p>>>12,x[b]=d^p;c.w=N,c.X=x,c.i=b}l(u,i)}function a(i,u){return u.i=i.i,u.w=i.w,u.X=i.X.slice(),u}function o(i,u){i==null&&(i=+new Date);var l=new s(i),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,b=(p+d)/(1<<21);while(b===0);return b},h.int32=l.next,h.quick=h,c&&(c.X&&a(c,l),h.state=function(){return a(l,{})}),h}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xor4096=o})(Mt,t,!1)})(Kp);var Xp={exports:{}};(function(t){(function(e,n,r){function s(i){var u=this,l="";u.next=function(){var h=u.b,p=u.c,d=u.d,b=u.a;return h=h<<25^h>>>7^p,p=p-d|0,d=d<<24^d>>>8^b,b=b-h|0,u.b=h=h<<20^h>>>12^p,u.c=p=p-d|0,u.d=d<<16^p>>>16^b,u.a=b-h|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,i===Math.floor(i)?(u.a=i/4294967296|0,u.b=i|0):l+=i;for(var c=0;c<l.length+20;c++)u.b^=l.charCodeAt(c)|0,u.next()}function a(i,u){return u.a=i.a,u.b=i.b,u.c=i.c,u.d=i.d,u}function o(i,u){var l=new s(i),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,b=(p+d)/(1<<21);while(b===0);return b},h.int32=l.next,h.quick=h,c&&(typeof c=="object"&&a(c,l),h.state=function(){return a(l,{})}),h}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.tychei=o})(Mt,t,!1)})(Xp);var Yp={exports:{}};(function(t){(function(e,n,r){var s=256,a=6,o=52,i="random",u=r.pow(s,a),l=r.pow(2,o),c=l*2,h=s-1,p;function d($,A,C){var M=[];A=A==!0?{entropy:!0}:A||{};var P=x(N(A.entropy?[$,_(n)]:$??F(),3),M),D=new b(M),V=function(){for(var z=D.g(a),q=u,G=0;z<l;)z=(z+G)*s,q*=s,G=D.g(1);for(;z>=c;)z/=2,q/=2,G>>>=1;return(z+G)/q};return V.int32=function(){return D.g(4)|0},V.quick=function(){return D.g(4)/4294967296},V.double=V,x(_(D.S),n),(A.pass||C||function(z,q,G,X){return X&&(X.S&&v(X,D),z.state=function(){return v(D,{})}),G?(r[i]=z,q):z})(V,P,"global"in A?A.global:this==r,A.state)}function b($){var A,C=$.length,M=this,P=0,D=M.i=M.j=0,V=M.S=[];for(C||($=[C++]);P<s;)V[P]=P++;for(P=0;P<s;P++)V[P]=V[D=h&D+$[P%C]+(A=V[P])],V[D]=A;(M.g=function(z){for(var q,G=0,X=M.i,oe=M.j,pe=M.S;z--;)q=pe[X=h&X+1],G=G*s+pe[h&(pe[X]=pe[oe=h&oe+q])+(pe[oe]=q)];return M.i=X,M.j=oe,G})(s)}function v($,A){return A.i=$.i,A.j=$.j,A.S=$.S.slice(),A}function N($,A){var C=[],M=typeof $,P;if(A&&M=="object")for(P in $)try{C.push(N($[P],A-1))}catch{}return C.length?C:M=="string"?$:$+"\0"}function x($,A){for(var C=$+"",M,P=0;P<C.length;)A[h&P]=h&(M^=A[h&P]*19)+C.charCodeAt(P++);return _(A)}function F(){try{var $;return p&&($=p.randomBytes)?$=$(s):($=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues($)),_($)}catch{var A=e.navigator,C=A&&A.plugins;return[+new Date,e,C,e.screen,_(n)]}}function _($){return String.fromCharCode.apply(0,$)}if(x(r.random(),n),t.exports){t.exports=d;try{p=require("crypto")}catch{}}else r["seed"+i]=d})(typeof self<"u"?self:Mt,[],Math)})(Yp);var av=Wp.exports,ov=qp.exports,iv=Hp.exports,uv=Gp.exports,lv=Kp.exports,cv=Xp.exports,Vn=Yp.exports;Vn.alea=av;Vn.xor128=ov;Vn.xorwow=iv;Vn.xorshift7=uv;Vn.xor4096=lv;Vn.tychei=cv;var ci=Vn;class hi{constructor(e,n,r,s,a){this.mean=e,this.stdDev=n,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=a||Math.random();this.random=ci.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,n,r=!1;for(;!r;){let s,a,o;do s=2*this.random()-1,a=2*this.random()-1,o=s*s+a*a;while(o>=1||o===0);const i=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*s*i,n=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class hv{constructor(e,n,r,s){this.alpha=e,this.beta=1/n,this.dtype=r;const a=s||Math.random();this.randu=ci.alea(a.toString()),this.randn=new hi(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,n,r,s,a,o;for(;;){do s=this.randn.nextValue(),o=1+this.c*s;while(o<=0);if(o*=o*o,e=s*s,n=1-.331*e*e,r=.5*e+this.d*(1-o+Math.log(o)),a=this.randu(),a<n||Math.log(a)<r)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class fv{constructor(e=0,n=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=n-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);this.random=ci.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function pv(t,e,n=1,r="float32",s){if(n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const a=new hv(e,n,r,s),o=Wt(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const Zp=E({randomGamma_:pv});function dv(t,e=0,n=1,r,s){if(r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const a=new hi(e,n,r,!1,s),o=Wt(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const fi=E({randomNormal_:dv});function mv(t,e,n){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return fi(t,0,1,e,n)}const Jp=E({randomStandardNormal_:mv});function gv(t,e=0,n=1,r="float32",s){const a=Wt(t,r),o=new fv(e,n,null,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const pi=E({randomUniform_:gv});function pn(t,e,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");const s={start:t,stop:e,step:n,dtype:r};return k.runKernel(zc,{},s)}function yv(t){const n={x:w(t,"x","reciprocal")};return k.runKernel(jc,n)}const Qp=E({reciprocal_:yv});function bv(t){const n={x:w(t,"x","relu")};return k.runKernel(Uc,n)}const Qr=E({relu_:bv});function wv(t){const n={x:w(t,"x","relu6")};return k.runKernel(Gc,n)}const di=E({relu6_:wv});function vv(t,e){const r={x:w(t,"x","reverse")},s={dims:e};return k.runKernel(Kc,r,s)}const dn=E({reverse_:vv});function Sv(t){const e=w(t,"x","reverse");return S(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),dn(e,0)}const ed=E({reverse1d_:Sv});function Nv(t,e){const n=w(t,"x","reverse");return S(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),dn(n,e)}const td=E({reverse2d_:Nv});function Tv(t,e){const n=w(t,"x","reverse");return S(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),dn(n,e)}const nd=E({reverse3d_:Tv});function Ev(t,e){const n=w(t,"x","reverse");return S(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),dn(n,e)}const rd=E({reverse4d_:Ev});function kv(t){const n={x:w(t,"x","round")};return k.runKernel(Xc,n)}const mi=E({round_:kv});function _v(t){const n={x:w(t,"x","rsqrt","float32")};return k.runKernel(Yc,n)}const sd=E({rsqrt_:_v});function xv(t){const n={x:w(t,"x","selu")};return k.runKernel(eh,n)}const ad=E({selu_:xv});function $v(t,e,n,r,s,a=[1,1],o="NHWC"){const i=w(t,"x","separableConv2d"),u=w(e,"depthwiseFilter","separableConv2d"),l=w(n,"pointwiseFilter","separableConv2d");let c=i,h=!1;if(i.rank===3&&(h=!0,c=B(i,[1,i.shape[0],i.shape[1],i.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");S(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),S(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),S(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),S(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),S(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);const p=u.shape[2],d=u.shape[3];S(l.shape[2]===p*d,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*d}, but got ${l.shape[2]}.`);const b=js(c,u,r,s,o,a),N=Kr(b,l,1,"valid",o);return h?B(N,[N.shape[1],N.shape[2],N.shape[3]]):N}const od=E({separableConv2d_:$v});async function Av(t,e){const n=w(t,"x","setdiff1d"),r=w(e,"y","setdiff1d");S(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),S(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),S(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await n.data(),a=await r.data(),o=new Set(a);let i=0;for(let c=0;c<s.length;c++)o.has(s[c])||i++;const u=new $s([i],n.dtype),l=new $s([i],"int32");for(let c=0,h=0;c<s.length;c++)o.has(s[c])||(u.values[h]=s[c],l.values[h]=c,h++);return[u.toTensor(),l.toTensor()]}const id=Av;function Iv(t){const n={x:w(t,"x","sign")};return k.runKernel(sh,n)}const ud=E({sign_:Iv});function Ov(t){const n={x:w(t,"x","sin","float32")};return k.runKernel(nh,n)}const ld=E({sin_:Ov});function Dv(t){const n={x:w(t,"x","sinh")};return k.runKernel(rh,n)}const cd=E({sinh_:Dv});function Fv(t,e,n){const r=w(t,"x","slice1d");return S(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Ee(r,[e],[n])}const hd=E({slice1d_:Fv});function Cv(t,e,n){const r=w(t,"x","slice2d");return S(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Ee(r,e,n)}const fd=E({slice2d_:Cv});function Pv(t,e,n){const r=w(t,"x","slice3d");return S(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Ee(r,e,n)}const pd=E({slice3d_:Pv});function Rv(t,e,n){const r=w(t,"x","slice4d");return S(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Ee(r,e,n)}const dd=E({slice4d_:Rv});function Bv(t,e=-1){const n=w(t,"logits","softmax","float32");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const r={logits:n},s={dim:e};return k.runKernel(hh,r,s)}const md=E({softmax_:Bv});function Lv(t){S(t.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);const e={input:t};return k.runKernel(ql,e)}const Hs=E({fft_:Lv});function Mv(t){S(t.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);const e={input:t};return k.runKernel(tc,e)}const Lr=E({ifft_:Mv});function zv(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const s=B(t,[n,e]);r=Lr(s)}else{const s=[n,2*(e-1)],a=B(ir(t),[n,e]),o=B(Wr(t),[n,e]),i=dn(Ee(a,[0,1],[n,e-2]),1),u=U(dn(Ee(o,[0,1],[n,e-2]),1),se(-1)),l=qe([a,i],1),c=qe([o,u],1),h=B(Jt(l,c),[s[0],s[1]]);r=Lr(h)}if(r=ir(r),t.rank===3&&t.shape[0]!==0){const s=r,a=t.shape[0];r=B(r,[a,r.shape[0]/a,r.shape[1]]),s.dispose()}return r}const gi=E({irfft_:zv});function Vv(t,e,n=0){const s={x:w(t,"x","split")},a={numOrSizeSplits:e,axis:n};return k.runKernel(ch,s,a)}const cr=E({split_:Vv});function jv(t,e){S(t.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const r=t.size/n;let s;if(e!=null&&e<n){const b=t.shape.map(N=>0),v=t.shape.map(N=>N);v[t.shape.length-1]=e,s=Ee(t,b,v),n=e}else if(e!=null&&e>n){const b=t.shape.map(v=>v);b[t.shape.length-1]=e-n,s=qe([t,Pn(b)],t.shape.length-1),n=e}else s=t;const a=ut(s),o=B(Jt(s,a),[r,n]),i=Hs(o),u=Math.floor(n/2)+1,l=ir(i),c=Wr(i),h=cr(l,[u,n-u],l.shape.length-1),p=cr(c,[u,n-u],c.shape.length-1),d=s.shape.slice();return d[s.shape.length-1]=u,B(Jt(h[0],p[0]),d)}const Gs=E({rfft_:jv});function Uv(t,e){let n=w(t,"a","squaredDifference"),r=w(e,"b","squaredDifference");[n,r]=Pe(n,r),Me(n.shape,r.shape);const s={a:n,b:r},a={};return k.runKernel(yh,s,a)}const yi=E({squaredDifference_:Uv});function Wv(t,e){const n=w(t,"x","squeeze","string_or_numeric");return B(n,Mu(n.shape,e).newShape)}const bt=E({squeeze_:Wv});function qv(t,e=0){const n=Dr(t,"tensors","stack","string_or_numeric");S(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&S(e<=n[0].rank,()=>"Axis must be <= rank of the tensor");const r=n,s={axis:e};return k.runKernel(Pc,r,s)}const Gt=E({stack_:qv});function Hv(t,e=0){const r={x:w(t,"x","step")},s={alpha:e};return k.runKernel(Oh,r,s)}const bi=E({step_:Hv});function Gv(t,e,n,r,s=0,a=0,o=0,i=0,u=0){const c={x:w(t,"x","stridedSlice","string_or_numeric")},h={begin:e,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};return k.runKernel(bh,c,h)}const gd=E({stridedSlice_:Gv});function Kv(t){const n={x:w(t,"x","tan","float32")};return k.runKernel(Th,n)}const yd=E({tan_:Kv});function wt(t,e){Ln(t);const n=Ut(t,e);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return mn(t,null,n,e)}function $n(t,e,n){if(Ln(t),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=Ut(t,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return mn(t,e,r,n)}function bd(t,e,n){if(Ln(t),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=Ut(t,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return mn(t,e,r,n)}function wd(t,e,n){if(Ln(t),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=Ut(t,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return mn(t,e,r,n)}function vd(t,e,n){if(Ln(t),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=Ut(t,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,mn(t,e,r,n)}function Xv(t,e=1,n=!0){const r=w(t,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const a={x:r},o={k:e,sorted:n},[i,u]=k.runKernel(kh,a,o);return{values:i,indices:u}}const Sd=E({topk_:Xv});function Yv(t,e=0,n=1,r,s){if(r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new hi(e,n,r,!0,s),o=Wt(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const Nd=E({truncatedNormal_:Yv});function Zv(t,e=0){const n=w(t,"x","unique","string_or_numeric");S(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},s={axis:e},[a,o]=k.runKernel(xh,r,s);return{values:a,indices:o}}const Td=E({unique_:Zv});function Jv(t,e,n){const r=w(t,"x","unsortedSegmentSum"),s=w(e,"segmentIds","unsortedSegmentSum","int32");S(rr(n),()=>"numSegments must be of dtype int");const a={x:r,segmentIds:s},o={numSegments:n};return k.runKernel(Ah,a,o)}const Ed=E({unsortedSegmentSum_:Jv});function Qv(t,e=0){const n=w(t,"x","unstack","string_or_numeric");S(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);const r={value:n},s={axis:e};return k.runKernel($h,r,s)}const yn=E({unstack_:Qv});function kd(t,e){return qs(t,e,"right")}function _d(t,e=!0,n,r){return k.makeVariable(t,e,n,r)}function xd(t,e){const n=[];for(let a=0;a<e.length;a++)e[a]&&n.push(a);const r=Wt(t,"int32"),s=Wt([n.length,t.length],"int32");for(let a=0;a<n.length;a++){const o=r.indexToLoc(n[a]),i=a*t.length;s.values.set(o,i)}return s.toTensor()}async function e2(t){const e=w(t,"condition","whereAsync","bool"),n=await e.data(),r=xd(e.shape,n);return t!==e&&e.dispose(),r}const wi=e2;async function t2(t,e,n){const r=w(t,"tensor","boolMask"),s=w(e,"mask","boolMask","bool"),a=n??0,o=s.rank,i=r.shape;S(o>0,()=>"mask cannot be scalar"),Qe(i.slice(a,a+o),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let v=a;v<a+o;v++)u*=i[v];const l=i.slice(0,a).concat([u],i.slice(a+o)),c=B(r,l),h=B(s,[-1]),p=await wi(h),d=bt(p,[1]),b=Ko(c,d,a);return t!==r&&r.dispose(),e!==s&&s.dispose(),d.dispose(),c.dispose(),h.dispose(),p.dispose(),b}const $d=t2;function n2(t,e,n,r,s=!0){const a=w(t,"v","movingAverage"),o=w(e,"x","movingAverage"),i=w(n,"decay","movingAverage");Vh(a,o),S(jt(a.shape,o.shape),()=>"Shape mismatch in v and x");const u=se(1),l=ne(u,i);let c=U(ne(o,a),l);if(s){S(r!=null,()=>"When using zeroDebias: true, step is required.");const h=w(r,"step","movingAverage");c=_e(c,ne(u,ur(i,h)))}return Y(a,c)}const Ad=E({movingAverage_:n2});function r2(t,e,n){const r=w(t,"indices","scatterND","int32"),s=w(e,"updates","scatterND");Po(s,r,n);const a={indices:r,updates:s},o={shape:n};return k.runKernel(Zc,a,o)}const Id=E({scatterND_:r2});function s2(t,e,n,r){if(t.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const s=t.rank>0?t.shape[0]:1,a=t.rank>1?t.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function a2(t,e,n,r=0){const s=w(t,"sparseIndices","sparseToDense","int32"),a=w(e,"sparseValues","sparseToDense","string_or_numeric"),o=w(r,"defaultValue","sparseToDense",a.dtype);s2(s,a,n,o);const i={sparseIndices:s,sparseValues:a,defaultValue:o},u={outputShape:n};return k.runKernel(gh,i,u)}const Od=E({sparseToDense_:a2});function o2(t,e){const n=w(e,"indices","gatherND","int32"),s={params:w(t,"x","gatherND","string_or_numeric"),indices:n};return k.runKernel(Jl,s)}const Dd=E({gatherND_:o2});function i2(t,e){if(e==null)return t.shape.slice();if(jt(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)e[r]==null&&t.shape[r]!=null?n.push(t.shape[r]):n.push(e[r]);return n}return e}function u2(t,e,n,r){const s=w(t,"x","dropout");if(S(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),S(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return t instanceof be?s.clone():s;const a=i2(s,n),o=1-e,i=_e(Go(Y(pi(a,0,1,"float32",r),o)),o);return U(s,i)}const Fd=E({dropout_:u2});function vi(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function Ks(t,e,n){const r=1-t%2,s=new Float32Array(t);for(let a=0;a<t;++a){const o=2*Math.PI*a/(t+r-1);s[a]=e-n*Math.cos(o)}return wt(s,"float32")}async function l2(t,e,n=1){const r=w(t,"predictions","inTopK"),s=w(e,"targets","inTopK");S(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),S(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),Qe(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=r.shape[r.shape.length-1];S(n>0&&n<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`);const o=await r.data(),i=await s.data(),[u,l]=[o.length/a,a],c=zu("bool",u);for(let h=0;h<u;h++){const p=h*l,d=o.subarray(p,p+l),b=[];for(let v=0;v<d.length;v++)b.push({value:d[v],index:v});b.sort((v,N)=>N.value-v.value),c[h]=0;for(let v=0;v<n;v++)if(b[v].index===i[h]){c[h]=1;break}}return t!==r&&r.dispose(),e!==s&&s.dispose(),vt(c,s.shape,"bool")}const Cd=l2;function c2(t,e,n,r,s,a="NHWC",o){let i=t;t.rank===3&&(i=B(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u=e;u.rank===3&&(u=B(e,[1,e.shape[0],e.shape[1],e.shape[2]])),S(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),S(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),S(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const l=a==="NHWC"?i.shape[3]:i.shape[1],c=a==="NHWC"?u.shape[3]:u.shape[1];S(l===n[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`),S(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),Tt("conv2dDerFilter",s,o);const h={x:i,dy:u},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:o,filterShape:n};return k.runKernel(Sl,h,p)}const h2=E({conv2DBackpropFilter_:c2});function Xs(t,e,n){if(n==null||n==="linear")return t;if(n==="relu")return U(t,bi(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Ys(t,e){let n=e;const r=Do(t.shape,e.shape);return r.length>0&&(n=$e(n,r)),B(n,t.shape)}function Zs(t,e,n,r){if(e==="linear")return t;if(e==="relu")return Qr(t);if(e==="elu")return Wo(t);if(e==="relu6")return di(t);if(e==="prelu")return li(t,n);if(e==="leakyrelu")return Yo(t,r);if(e==="sigmoid")return Vt(t);throw new Error(`Unknown fused activation ${e}.`)}const Js=(t,e)=>!(t>0)||e==="linear";function f2({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(u=u||"linear",Js(k.state.gradientDepth,u)===!1){S(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let C=Kr(t,e,n,r,s,a,o);return i!=null&&(C=Y(C,i)),Zs(C,u,l,c)}const h=w(t,"x","conv2d","float32"),p=w(e,"filter","conv2d","float32");let d=h,b=!1;h.rank===3&&(b=!0,d=B(h,[1,h.shape[0],h.shape[1],h.shape[2]])),S(d.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`),S(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),Tt("fused conv2d",r,o);const v=s==="NHWC"?d.shape[3]:d.shape[1];S(p.shape[2]===v,()=>`Error in conv2d: depth of input (${v}) must match input depth for filter ${p.shape[2]}.`),S(Qt(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const N=Hr(d.shape,p.shape,n,a,r,o);let x;i!=null&&(x=w(i,"bias","fused conv2d"),[x]=Pe(x,h),s==="NHWC"?Me(N.outShape,x.shape):(S(x.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${x.shape.length}.`),S(x.shape.length===0||x.shape[0]===N.outChannels||x.shape[0]===1,()=>`Error in fused conv2d: bias shape (${x.shape}) is not compatible with the number of output channels (${N.outChannels})`)));let F;if(l!=null){const C=l.shape;if(S(C.length<=1||C.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${C.length}.`),C.length===1)S(C[0]===1||C[0]===N.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the number of output channels (${N.outChannels}).`);else if(C.length===3)try{Me(C,N.outShape)}catch{const P=`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the output shape of the conv2d (${N.outShape}).`;throw Error(P)}F=w(l,"prelu weights","fused conv2d")}const _=(C,M)=>{S(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[P,D,V,z]=M,q=Xs(C,V,u);S(Pr(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const G=Jf(D.shape,q,P,n,r),X=h2(D,q,P.shape,n,r),oe=[G,X];if(z!=null){const pe=Ys(z,q);oe.push(pe)}return oe},$={x:d,filter:p,bias:x,preluActivationWeights:F},A={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:c};return i==null?Ht((M,P,D)=>{let V=k.runKernel(Da,$,A);return D([P,M,V]),b&&(V=B(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:_}})(d,p):Ht((M,P,D,V)=>{let z=k.runKernel(Da,$,A);return V([P,M,z,D]),b&&(z=B(z,[z.shape[1],z.shape[2],z.shape[3]])),{value:z,gradFunc:_}})(d,p,x)}const p2=E({fusedConv2d_:f2});function d2(t,e,n,r,s,a=[1,1],o){let i=t;t.rank===3&&(i=B(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u=e;u.rank===3&&(u=B(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={x:i,dy:u},c={strides:r,pad:s,dimRoundingMode:o,dilations:a,filterShape:n};return k.runKernel(Fl,l,c)}const m2=E({depthwiseConv2dNativeBackpropFilter_:d2});function g2(t,e,n,r,s,a=[1,1],o){let i=e,u=!1;e.rank===3&&(u=!0,i=B(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={dy:i,filter:n},c={strides:r,pad:s,dimRoundingMode:o,dilations:a,inputShape:t},h=k.runKernel(Cl,l,c);return u?B(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const y2=E({depthwiseConv2dNativeBackpropInput_:g2});function b2({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(Js(k.state.gradientDepth,u)===!1){let A=js(t,e,n,r,s,a,o);return i!=null&&(A=Y(A,i)),Zs(A,u,l,c)}const h=w(t,"x","depthwiseConv2d","float32"),p=w(e,"filter","depthwiseConv2d","float32");let d=h,b=!1;h.rank===3&&(b=!0,d=B(h,[1,h.shape[0],h.shape[1],h.shape[2]])),S(d.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),S(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),S(d.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),a==null&&(a=[1,1]),S(Qt(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Tt("fused depthwiseConv2d",r,o);const v=Hr(d.shape,p.shape,n,a,r,o,!0);let N;i!=null&&(N=w(i,"bias","fused conv2d"),[N]=Pe(N,h),Me(v.outShape,N.shape));let x;l!=null&&(x=w(l,"prelu weights","fused depthwiseConv2d"));const F=(A,C)=>{S(Pr(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[M,P,D,V]=C,z=Xs(A,D,u),q=y2(P.shape,z,M,n,r,a,o),G=m2(P,z,M.shape,n,r,a,o);if(V!=null){const X=Ys(N,z);return[q,G,X]}return[q,G]},_={x:d,filter:p,bias:N,preluActivationWeights:x},$={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:c};return i==null?Ht((C,M,P)=>{let D=k.runKernel(Fa,_,$);return P([M,C,D]),b&&(D=B(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:F}})(d,p):Ht((C,M,P,D)=>{let V=k.runKernel(Fa,_,$);return D([M,C,V,P]),b&&(V=B(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:F}})(d,p,N)}const w2=E({fusedDepthwiseConv2d_:b2});function v2({a:t,b:e,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:o,leakyreluAlpha:i=.2}){if(Js(k.state.gradientDepth,a)===!1){let z=ye(t,e,n,r);return s!=null&&(z=Y(z,s)),Zs(z,a,o,i)}let u=w(t,"a","fused matMul"),l=w(e,"b","fused matMul");[u,l]=Pe(u,l);const c=n?u.shape[u.rank-2]:u.shape[u.rank-1],h=r?l.shape[l.rank-1]:l.shape[l.rank-2],p=n?u.shape[u.rank-1]:u.shape[u.rank-2],d=r?l.shape[l.rank-2]:l.shape[l.rank-1],b=u.shape.slice(0,-2),v=l.shape.slice(0,-2),N=Ae(b),x=Ae(v);S(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${n} and transposeB=${r} must match.`);const _=Me(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([p,d]),$=n?B(u,[N,c,p]):B(u,[N,p,c]),A=r?B(l,[x,d,h]):B(l,[x,h,d]);let C;s!=null&&(C=w(s,"bias","fused matMul"),[C]=Pe(C,u),Me(_,C.shape));let M;o!=null&&(M=w(o,"prelu weights","fused matMul"));const P=(z,q)=>{const[G,X,oe,pe]=q,Te=Xs(B(z,oe.shape),oe,a);let De,Be;if(!n&&!r?(De=ye(Te,X,!1,!0),Be=ye(G,Te,!0,!1)):!n&&r?(De=ye(Te,X,!1,!1),Be=ye(Te,G,!0,!1)):n&&!r?(De=ye(X,Te,!1,!0),Be=ye(G,Te,!1,!1)):(De=ye(X,Te,!0,!0),Be=ye(Te,G,!0,!0)),s!=null){const Ue=Ys(pe,Te);return[De,Be,Ue]}else return[De,Be]},D={a:$,b:A,bias:C,preluActivationWeights:M},V={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:i};return s==null?Ht((q,G,X)=>{const oe=k.runKernel(Oa,D,V);return X([q,G,oe]),{value:B(oe,_),gradFunc:P}})($,A):Ht((q,G,X,oe)=>{const pe=k.runKernel(Oa,D,V);return oe([q,G,pe,X]),{value:B(pe,_),gradFunc:P}})($,A,C)}const S2=E({fusedMatMul_:v2});var Pd=Object.freeze(Object.defineProperty({__proto__:null,conv2d:p2,depthwiseConv2d:w2,matMul:S2},Symbol.toStringTag,{value:"Module"}));function N2(t){return Ks(t,.54,.46)}const T2=E({hammingWindow_:N2});function E2(t){return Ks(t,.5,.5)}const Rd=E({hannWindow_:E2});function k2(t,e,n,r=!1,s=0){let a=0;const o=[];for(;a+e<=t.size;)o.push(Ee(t,a,e)),a+=n;if(r)for(;a<t.size;){const i=a+e-t.size,u=qe([Ee(t,a,e-i),Jr([i],s)]);o.push(u),a+=n}return o.length===0?$n([],[0,e]):B(qe(o),[o.length,e])}const Bd=E({frame_:k2});function _2(t,e,n,r,s=Rd){r==null&&(r=vi(e));const a=Bd(t,e,n),o=U(a,s(e));return Gs(o,r)}const x2=E({stft_:_2});function $2(t,e,n,r,s="bilinear",a=0){const o=w(t,"image","cropAndResize"),i=w(e,"boxes","cropAndResize","float32"),u=w(n,"boxInd","cropAndResize","int32"),l=i.shape[0];S(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),S(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${i.shape}.`),S(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${i.shape}.`),S(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),S(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),S(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const c={image:o,boxes:i,boxInd:u},h={method:s,extrapolationValue:a,cropSize:r};return k.runKernel(Al,c,h)}const A2=E({cropAndResize_:$2});function I2(t){const e=w(t,"image","flipLeftRight","float32");S(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const n={image:e};return k.runKernel(Gl,n,{})}const O2=E({flipLeftRight_:I2});function D2(t){const e=w(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];S(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),S(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,n),s[n]=3,nr(e,s)}const F2=E({grayscaleToRGB_:D2});function C2(t,e,n=0,r=.5){const s=w(t,"image","rotateWithOffset","float32");S(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const a={image:s},o={radians:e,fillValue:n,center:r};return k.runKernel(Dh,a,o)}const P2=E({rotateWithOffset_:C2});function pr(t,e,n,r,s,a){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),a==null&&(a=0);const o=t.shape[0];return n=Math.min(n,o),S(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),S(t.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),S(t.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),S(e.rank===1,()=>"scores must be a 1D tensor"),S(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),S(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}function R2(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=w(t,"boxes","nonMaxSuppression","float32"),o=w(e,"scores","nonMaxSuppression","float32"),i=pr(a,o,n,r,s);n=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;const u={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return k.runKernel(Ic,{boxes:a,scores:o},u)}const B2=E({nonMaxSuppression_:R2});function L2(t,e,n){const r=M2(t,e,n),s=r<0?-(r+1):r;t.splice(s,0,e)}function M2(t,e,n){return V2(t,e,n||z2)}function z2(t,e){return t>e?1:t<e?-1:0}function V2(t,e,n){let r=0,s=t.length,a=0,o=!1;for(;r<s;){a=r+(s-r>>>1);const i=n(e,t[a]);i>0?r=a+1:(s=a,o=!i)}return o?r:-r-1}function Ld(t,e,n,r,s){return Si(t,e,n,r,s,0)}function Md(t,e,n,r,s,a){return Si(t,e,n,r,s,0,!1,a,!0)}function zd(t,e,n,r,s,a){return Si(t,e,n,r,s,a,!0)}function Si(t,e,n,r,s,a,o=!1,i=!1,u=!1){const l=[];for(let N=0;N<e.length;N++)e[N]>s&&l.push({score:e[N],boxIndex:N,suppressBeginIndex:0});l.sort(ou);const c=a>0?-.5/a:0,h=[],p=[];for(;h.length<n&&l.length>0;){const N=l.pop(),{score:x,boxIndex:F,suppressBeginIndex:_}=N;if(x<s)break;let $=!1;for(let A=h.length-1;A>=_;--A){const C=j2(t,F,h[A]);if(C>=r){$=!0;break}if(N.score=N.score*U2(r,c,C),N.score<=s)break}N.suppressBeginIndex=h.length,$||(N.score===x?(h.push(F),p.push(N.score)):N.score>s&&L2(l,N,ou))}const d=h.length,b=n-d;i&&b>0&&(h.push(...new Array(b).fill(0)),p.push(...new Array(b).fill(0)));const v={selectedIndices:h};return o&&(v.selectedScores=p),u&&(v.validOutputs=d),v}function j2(t,e,n){const r=t.subarray(e*4,e*4+4),s=t.subarray(n*4,n*4+4),a=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),p=Math.max(s[1],s[3]),d=(i-a)*(u-o),b=(h-l)*(p-c);if(d<=0||b<=0)return 0;const v=Math.max(a,l),N=Math.max(o,c),x=Math.min(i,h),F=Math.min(u,p),_=Math.max(x-v,0)*Math.max(F-N,0);return _/(d+b-_)}function U2(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function ou(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}async function W2(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=w(t,"boxes","nonMaxSuppressionAsync"),o=w(e,"scores","nonMaxSuppressionAsync"),i=pr(a,o,n,r,s);n=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;const u=await Promise.all([a.data(),o.data()]),l=u[0],c=u[1],{selectedIndices:h}=Ld(l,c,n,r,s);return a!==t&&a.dispose(),o!==e&&o.dispose(),wt(h,"int32")}const q2=W2;function H2(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const o=w(t,"boxes","nonMaxSuppression"),i=w(e,"scores","nonMaxSuppression"),u=pr(o,i,n,r,s,a);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;const l={boxes:o,scores:i},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},h=k.runKernel(Dc,l,c);return{selectedIndices:h[0],selectedScores:h[1]}}const G2=E({nonMaxSuppressionWithScore_:H2});async function K2(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const o=w(t,"boxes","nonMaxSuppressionAsync"),i=w(e,"scores","nonMaxSuppressionAsync"),u=pr(o,i,n,r,s,a);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;const l=await Promise.all([o.data(),i.data()]),c=l[0],h=l[1],{selectedIndices:p,selectedScores:d}=zd(c,h,n,r,s,a);return o!==t&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:wt(p,"int32"),selectedScores:wt(d)}}const X2=K2;function Y2(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const o=w(t,"boxes","nonMaxSuppression"),i=w(e,"scores","nonMaxSuppression"),u=pr(o,i,n,r,s,null),l=u.maxOutputSize,c=u.iouThreshold,h=u.scoreThreshold,p={boxes:o,scores:i},d={maxOutputSize:l,iouThreshold:c,scoreThreshold:h,padToMaxOutputSize:a},b=k.runKernel(Oc,p,d);return{selectedIndices:b[0],validOutputs:b[1]}}const Z2=E({nonMaxSuppressionPadded_:Y2});async function J2(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const o=w(t,"boxes","nonMaxSuppressionAsync"),i=w(e,"scores","nonMaxSuppressionAsync"),u=pr(o,i,n,r,s,null),l=u.maxOutputSize,c=u.iouThreshold,h=u.scoreThreshold,[p,d]=await Promise.all([o.data(),i.data()]),{selectedIndices:b,validOutputs:v}=Md(p,d,l,c,h,a);return o!==t&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:wt(b,"int32"),validOutputs:se(v,"int32")}}const Q2=J2;function eS(t,e,n=!1,r=!1){const s=w(t,"images","resizeBilinear");S(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),S(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),S(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=s,o=!1;s.rank===3&&(o=!0,a=B(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const i={images:a},u={alignCorners:n,halfPixelCenters:r,size:e},l=k.runKernel(Hc,i,u);return o?B(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const tS=E({resizeBilinear_:eS});function nS(t,e,n=!1,r=!1){const s=w(t,"images","resizeNearestNeighbor");S(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),S(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),S(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),S(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=s,o=!1;s.rank===3&&(o=!0,a=B(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const i={images:a},u={alignCorners:n,halfPixelCenters:r,size:e},l=k.runKernel(qc,i,u);return o?B(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const rS=E({resizeNearestNeighbor_:nS});function sS(t,e="binary",n=!1,r=.5){const s=w(t,"image","threshold"),a=.2989,o=.587,i=.114,u=s.shape[0]*s.shape[1];let l=U(wt([r]),255),c,h,p,d;if(S(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),S(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),S(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),S(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[c,h,p]=cr(s,[1,1,1],-1);const N=U(c,a),x=U(h,o),F=U(p,i);d=Y(Y(N,x),F)}else d=t;if(e==="otsu"){const N=Uo(we(mi(d),"int32"),vt([]),256);l=aS(N,u)}const b=n?Us(d,l):fr(d,l);return we(U(b,255),"int32")}function aS(t,e){let n=wt([-1]),r=wt([0]),s=wt([0]),a,o,i,u,l,c;for(let h=0;h<t.size-1;h++){a=Ee(t,0,h+1),o=Ee(t,h+1),l=_e($e(a),e),c=_e($e(o),e);const p=$e(U(a,pn(0,a.size)));i=_e(p,$e(a));const d=Jr(o.shape,a.size),b=Y(pn(0,o.size),d),v=U(o,b);u=_e($e(v),$e(o));const N=ne(i,u),x=ne(i,u),F=U(l,c);s=U(U(F,N),x);const _=fr(s,r);r=Cn(_,s,r),n=Cn(_,wt([h]),n)}return n}const oS=E({threshold_:sS});function iS(t,e,n="nearest",r="constant",s=0,a){const o=w(t,"image","transform","float32"),i=w(e,"transforms","transform","float32");S(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),S(i.rank===2&&(i.shape[0]===o.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),S(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const u={image:o,transforms:i},l={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return k.runKernel(_h,u,l)}const uS=E({transform_:iS});function lS(t,e,n){S(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),S(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const r=w(t,"a","bandPart");S(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[a,o]=r.shape.slice(-2);if(!(e<=a))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${a}).`);if(!(n<=o))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`);e<0&&(e=a),n<0&&(n=o);const i=B(pn(0,a,1,"int32"),[-1,1]),u=pn(0,o,1,"int32"),l=ne(i,u),c=Rr(Us(l,se(+e,"int32")),Xo(l,se(-n,"int32"))),h=Pn([a,o],r.dtype);return B(Gt(yn(B(r,[-1,a,o])).map(p=>Cn(c,p,h))),s)}const cS=E({bandPart_:lS});function hS(t){let e;if(Array.isArray(t)){e=!1,S(t!=null&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=t[0].shape[0];for(let a=1;a<t.length;++a)S(t[a].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[a].shape[0]} vs. ${s})`)}else e=!0,t=cr(t,t.shape[0],0).map(s=>bt(s,[0]));S(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],r=t;for(let s=0;s<t.length;++s)n.push(k.tidy(()=>{let a=r[s];if(s>0)for(let o=0;o<s;++o){const i=U($e(U(n[o],a)),n[o]);a=ne(a,i)}return _e(a,Zr(a,"euclidean"))}));return e?Gt(n,0):n}const fS=E({gramSchmidt_:hS});function pS(t,e=!1){if(S(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),t.rank===2)return iu(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((u,l)=>u*l),r=yn(B(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),s=[],a=[];r.forEach(u=>{const[l,c]=iu(u,e);s.push(l),a.push(c)});const o=B(Gt(s,0),t.shape),i=B(Gt(a,0),t.shape);return[o,i]}}function iu(t,e=!1){return k.tidy(()=>{S(t.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],r=t.shape[1];let s=Ho(n),a=Zt(t);const o=$n([[1]],[1,1]);let i=Zt(o);const u=n>=r?r:n;for(let l=0;l<u;++l){const c=a,h=i,p=s;[i,a,s]=k.tidy(()=>{const d=Ee(a,[l,l],[n-l,1]),b=Zr(d),v=Ee(a,[l,l],[1,1]),N=Cn(fr(v,0),$n([[-1]]),$n([[1]])),x=ne(v,U(N,b)),F=_e(d,x);F.shape[0]===1?i=Zt(o):i=qe([o,Ee(F,[1,0],[F.shape[0]-1,F.shape[1]])],0);const _=zt(_e(ye(N,x),b)),$=Ee(a,[l,0],[n-l,r]),A=U(_,i),C=Cr(i);if(l===0)a=ne($,ye(A,ye(C,$)));else{const D=ne($,ye(A,ye(C,$)));a=qe([Ee(a,[0,0],[l,r]),D],0)}const M=Cr(A),P=Ee(s,[0,l],[n,s.shape[1]-l]);if(l===0)s=ne(P,ye(ye(P,i),M));else{const D=ne(P,ye(ye(P,i),M));s=qe([Ee(s,[0,0],[n,l]),D],1)}return[i,a,s]}),tt([c,h,p])}return!e&&n>r&&(s=Ee(s,[0,0],[n,r]),a=Ee(a,[0,0],[r,r])),[s,a]})}const dS=E({qr_:pS});var Ze;(function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Ze||(Ze={}));function mS(t,e,n=Ze.SUM_BY_NONZERO_WEIGHTS){const r=w(t,"losses","computeWeightedLoss");let s=null;e!=null&&(s=w(e,"weights","computeWeightedLoss"));const a=s==null?r:U(r,s);if(n===Ze.NONE)return a;if(n===Ze.SUM)return $e(a);if(n===Ze.MEAN){if(s==null)return Br(a);{const o=r.size/s.size,i=_e($e(a),$e(s));return o>1?_e(i,se(o)):i}}if(n===Ze.SUM_BY_NONZERO_WEIGHTS){if(s==null)return _e($e(a),se(r.size));{const o=U(s,ln(r.shape)),i=we($e(oi(o,se(0))),"float32");return _e($e(a),i)}}throw Error(`Unknown reduction: ${n}`)}const en=E({computeWeightedLoss_:mS});function gS(t,e,n,r=Ze.SUM_BY_NONZERO_WEIGHTS){const s=w(t,"labels","absoluteDifference"),a=w(e,"predictions","absoluteDifference");let o=null;n!=null&&(o=w(n,"weights","absoluteDifference")),Qe(s.shape,a.shape,"Error in absoluteDifference: ");const i=at(ne(s,a));return en(i,o,r)}const yS=E({absoluteDifference_:gS});function bS(t,e,n,r,s=Ze.SUM_BY_NONZERO_WEIGHTS){const a=w(t,"labels","cosineDistance"),o=w(e,"predictions","cosineDistance");let i=null;r!=null&&(i=w(r,"weights","cosineDistance")),Qe(a.shape,o.shape,"Error in cosineDistance: ");const u=se(1),l=ne(u,$e(U(a,o),n,!0));return en(l,i,s)}const wS=E({cosineDistance_:bS});function vS(t,e,n,r=Ze.SUM_BY_NONZERO_WEIGHTS){let s=w(t,"labels","hingeLoss");const a=w(e,"predictions","hingeLoss");let o=null;n!=null&&(o=w(n,"weights","hingeLoss")),Qe(s.shape,a.shape,"Error in hingeLoss: ");const i=se(1);s=ne(U(se(2),s),i);const u=Qr(ne(i,U(s,a)));return en(u,o,r)}const SS=E({hingeLoss_:vS});function NS(t,e,n,r=1,s=Ze.SUM_BY_NONZERO_WEIGHTS){const a=w(t,"labels","huberLoss"),o=w(e,"predictions","huberLoss");let i=null;n!=null&&(i=w(n,"weights","huberLoss")),Qe(a.shape,o.shape,"Error in huberLoss: ");const u=se(r),l=at(ne(o,a)),c=si(l,u),h=ne(l,c),p=Y(U(se(.5),St(c)),U(u,h));return en(p,i,s)}const TS=E({huberLoss_:NS});function ES(t,e,n,r=1e-7,s=Ze.SUM_BY_NONZERO_WEIGHTS){const a=w(t,"labels","logLoss"),o=w(e,"predictions","logLoss");let i=null;n!=null&&(i=w(n,"weights","logLoss")),Qe(a.shape,o.shape,"Error in logLoss: ");const u=se(1),l=se(r),c=zt(U(a,lr(Y(o,l)))),h=U(ne(u,a),lr(Y(ne(u,o),l))),p=ne(c,h);return en(p,i,s)}const kS=E({logLoss_:ES});function _S(t,e,n,r=Ze.SUM_BY_NONZERO_WEIGHTS){const s=w(t,"labels","meanSquaredError"),a=w(e,"predictions","meanSquaredError");let o=null;n!=null&&(o=w(n,"weights","meanSquaredError")),Qe(s.shape,a.shape,"Error in meanSquaredError: ");const i=yi(s,a);return en(i,o,r)}const xS=E({meanSquaredError_:_S});function $S(t,e){const n=w(t,"labels","sigmoidCrossEntropyWithLogits"),r=w(e,"logits","sigmoidCrossEntropyWithLogits");Qe(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Qr(r),a=U(r,n),o=Zo(fn(zt(at(r))));return Y(ne(s,a),o)}function AS(t,e,n,r=0,s=Ze.SUM_BY_NONZERO_WEIGHTS){let a=w(t,"multiClassLabels","sigmoidCrossEntropy");const o=w(e,"logits","sigmoidCrossEntropy");let i=null;if(n!=null&&(i=w(n,"weights","sigmoidCrossEntropy")),Qe(a.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const l=se(r),c=se(1),h=se(.5);a=Y(U(a,ne(c,l)),U(h,l))}const u=$S(a,o);return en(u,i,s)}const IS=E({sigmoidCrossEntropy_:AS});function OS(t,e,n=-1){if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return Ht((s,a,o)=>{const u=Qo(a,[n],!0),l=ne(we(a,"float32"),u);o([s,l]);const c=zt(U(l,s));return{value:$e(c,[n]),gradFunc:(d,b)=>{const[v,N]=b,x=Yr(d.shape,[n]);return[U(B(d,x),ne(we(v,"float32"),fn(N))),U(B(d,x),ne(fn(N),we(v,"float32")))]}}})(t,e)}function DS(t,e,n,r=0,s=Ze.SUM_BY_NONZERO_WEIGHTS){let a=w(t,"onehotLabels","softmaxCrossEntropy");const o=w(e,"logits","softmaxCrossEntropy");let i=null;if(n!=null&&(i=w(n,"weights","softmaxCrossEntropy")),Qe(a.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const l=se(r),c=se(1),h=se(a.shape[1]);a=Y(U(a,ne(c,l)),_e(l,h))}const u=OS(a,o);return en(u,i,s)}const FS=E({softmaxCrossEntropy_:DS});function CS(t,e,n,r){const s=w(t,"indices","sparseFillEmptyRows","int32"),a=w(e,"values","sparseFillEmptyRows"),o=w(n,"denseShape","sparseFillEmptyRows","int32"),i=w(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const u={indices:s,values:a,denseShape:o,defaultValue:i},l=k.runKernel(fh,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}const PS=E({sparseFillEmptyRows_:CS});function RS(t,e,n){const r=w(t,"inputIndices","sparseReshape","int32"),s=w(e,"inputShape","sparseReshape","int32"),a=w(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const o={inputIndices:r,inputShape:s,newShape:a},i=k.runKernel(ph,o);return{outputIndices:i[0],outputShape:i[1]}}const BS=E({sparseReshape_:RS});function LS(t,e,n){const r=w(t,"data","sparseSegmentMean"),s=w(e,"indices","sparseSegmentMean","int32"),a=w(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);const o={data:r,indices:s,segmentIds:a};return k.runKernel(dh,o)}const MS=E({sparseSegmentMean_:LS});function zS(t,e,n){const r=w(t,"data","sparseSegmentSum"),s=w(e,"indices","sparseSegmentSum","int32"),a=w(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);const o={data:r,indices:s,segmentIds:a};return k.runKernel(mh,o)}const VS=E({sparseSegmentSum_:zS});function jS(t,e,n,r,s,a,o,i){const u=w(t,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const l=w(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:o,preserveShortSequences:i},h={data:u,dataSplits:l},p=k.runKernel(wh,h,c);return{nGrams:p[0],nGramsSplits:p[1]}}const US=E({stringNGrams_:jS});function WS(t,e,n=!0){const r=w(t,"input","stringSplit","string"),s=w(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a={skipEmpty:n},o={input:r,delimiter:s},i=k.runKernel(vh,o,a);return{indices:i[0],values:i[1],shape:i[2]}}const qS=E({stringSplit_:WS});function HS(t,e){const n=w(t,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return k.runKernel(Sh,s,r)}const GS=E({stringToHashBucketFast_:HS});const Vd={fft:Hs,ifft:Lr,rfft:Gs,irfft:gi},jd={hammingWindow:T2,hannWindow:Rd,frame:Bd,stft:x2},Rn={flipLeftRight:O2,grayscaleToRGB:F2,resizeNearestNeighbor:rS,resizeBilinear:tS,rotateWithOffset:P2,cropAndResize:A2,nonMaxSuppression:B2,nonMaxSuppressionAsync:q2,nonMaxSuppressionWithScore:G2,nonMaxSuppressionWithScoreAsync:X2,nonMaxSuppressionPadded:Z2,nonMaxSuppressionPaddedAsync:Q2,threshold:oS,transform:uS},Ud={bandPart:cS,gramSchmidt:fS,qr:dS},Wd={absoluteDifference:yS,computeWeightedLoss:en,cosineDistance:wS,hingeLoss:SS,huberLoss:TS,logLoss:kS,meanSquaredError:xS,sigmoidCrossEntropy:IS,softmaxCrossEntropy:FS},qd={sparseFillEmptyRows:PS,sparseReshape:BS,sparseSegmentMean:MS,sparseSegmentSum:VS},Hd={stringNGrams:US,stringSplit:qS,stringToHashBucketFast:GS};class bn extends Nf{minimize(e,n=!1,r){const{value:s,grads:a}=this.computeGradients(e,r);if(r!=null){const o=r.map(i=>({name:i.name,tensor:a[i.name]}));this.applyGradients(o)}else this.applyGradients(a);return tt(a),n?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,n){return Ep(e,n)}dispose(){this.iterations_!=null&&tt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:se(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(bn,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});class Qs extends bn{constructor(e,n,r=null){super(),this.learningRate=e,this.rho=n,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=k.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const a=k.registeredVariables[r],o=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:Z(()=>ut(a).variable(o))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:Z(()=>ut(a).variable(o))});const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const u=this.accumulatedGrads[s].variable,l=this.accumulatedUpdates[s].variable;Z(()=>{const c=Y(U(u,this.rho),U(St(i),1-this.rho)),h=U(_e(qt(Y(l,this.epsilon)),qt(Y(u,this.epsilon))),i),p=Y(U(l,this.rho),U(St(h),1-this.rho));u.assign(c),l.assign(p);const d=Y(U(h,-this.learningRate),a);a.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(tt(this.accumulatedGrads.map(e=>e.variable)),tt(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.rho,n.epsilon)}}Qs.className="Adadelta";gn(Qs);class ea extends bn{constructor(e,n=.1){super(),this.learningRate=e,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const a=k.registeredVariables[r];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:Z(()=>Jr(a.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[s].tensor:e[r];if(o==null)return;const i=this.accumulatedGrads[s].variable;Z(()=>{const u=Y(i,St(o));i.assign(u);const l=Y(U(_e(o,qt(Y(u,k.backend.epsilon()))),-this.learningRate),a);a.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&tt(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,n){return new e(n.learningRate,n.initialAccumulatorValue)}}ea.className="Adagrad";gn(ea);class ta extends bn{constructor(e,n,r,s=null){super(),this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Z(()=>{this.accBeta1=se(n).variable(),this.accBeta2=se(r).variable()}),s==null&&(this.epsilon=k.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Z(()=>{const r=ne(1,this.accBeta1),s=ne(1,this.accBeta2);n.forEach((a,o)=>{const i=k.registeredVariables[a],u=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${a}/m`,variable:Z(()=>ut(i).variable(u))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${a}/v`,variable:Z(()=>ut(i).variable(u))});const l=Array.isArray(e)?e[o].tensor:e[a];if(l==null)return;const c=this.accumulatedFirstMoment[o].variable,h=this.accumulatedSecondMoment[o].variable,p=Y(U(c,this.beta1),U(l,1-this.beta1)),d=Y(U(h,this.beta2),U(St(l),1-this.beta2)),b=_e(p,r),v=_e(d,s);c.assign(p),h.assign(d);const N=Y(U(_e(b,Y(qt(v),this.epsilon)),-this.learningRate),i);i.assign(N)}),this.accBeta1.assign(U(this.accBeta1,this.beta1)),this.accBeta2.assign(U(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&tt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&tt(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e),Z(()=>{this.accBeta1.assign(ur(this.beta1,this.iterations_+1)),this.accBeta2.assign(ur(this.beta2,this.iterations_+1))});const n=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon)}}ta.className="Adam";gn(ta);class na extends bn{constructor(e,n,r,s=null,a=0){super(),this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=s,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Z(()=>{this.iteration=se(0).variable(),this.accBeta1=se(n).variable()}),s==null&&(this.epsilon=k.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Z(()=>{const r=ne(1,this.accBeta1),s=_e(-this.learningRate,Y(U(this.iteration,this.decay),1));n.forEach((a,o)=>{const i=k.registeredVariables[a],u=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${a}/m`,variable:ut(i).variable(u)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${a}/v`,variable:ut(i).variable(u)});const l=Array.isArray(e)?e[o].tensor:e[a];if(l==null)return;const c=this.accumulatedFirstMoment[o].variable,h=this.accumulatedWeightedInfNorm[o].variable,p=Y(U(c,this.beta1),U(l,1-this.beta1)),d=U(h,this.beta2),b=at(l),v=ri(d,b);c.assign(p),h.assign(v);const N=Y(U(_e(s,r),_e(p,Y(v,this.epsilon))),i);i.assign(N)}),this.iteration.assign(Y(this.iteration,1)),this.accBeta1.assign(U(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&tt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&tt(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}na.className="Adamax";gn(na);class es extends bn{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const o=k.registeredVariables[r];Z(()=>{const i=Y(U(this.c,a),o);o.assign(i)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Lt(se(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,n){return new e(n.learningRate)}}es.className="SGD";gn(es);class ra extends es{constructor(e,n,r=!1){super(e),this.learningRate=e,this.momentum=n,this.useNesterov=r,this.accumulations=[],this.m=se(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const a=k.registeredVariables[r];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:Z(()=>ut(a).variable(!1))});const o=this.accumulations[s].variable,i=Array.isArray(e)?e[s].tensor:e[r];i!=null&&Z(()=>{let u;const l=Y(U(this.m,o),i);this.useNesterov?u=Y(U(this.c,Y(i,U(l,this.m))),a):u=Y(U(this.c,l),a),o.assign(l),a.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&tt(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,n){return new e(n.learningRate,n.momentum,n.useNesterov)}}ra.className="Momentum";gn(ra);class sa extends bn{constructor(e,n=.9,r=0,s=null,a=!1){if(super(),this.learningRate=e,this.decay=n,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,s==null&&(this.epsilon=k.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const a=k.registeredVariables[r],o=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:Z(()=>ut(a).variable(o))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:Z(()=>ut(a).variable(o))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:Z(()=>ut(a).variable(o))});const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const u=this.accumulatedMeanSquares[s].variable,l=this.accumulatedMoments[s].variable;Z(()=>{const c=Y(U(u,this.decay),U(St(i),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[s].variable,p=Y(U(h,this.decay),U(i,1-this.decay)),d=_e(U(i,this.learningRate),qt(ne(c,Y(St(p),this.epsilon)))),b=Y(U(l,this.momentum),d);u.assign(c),h.assign(p),l.assign(b);const v=ne(a,b);a.assign(v)}else{const h=Y(U(u,this.decay),U(St(i),1-this.decay)),p=Y(U(l,this.momentum),_e(U(i,this.learningRate),qt(Y(h,this.epsilon))));u.assign(h),l.assign(p);const d=ne(a,p);a.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&tt(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&tt(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&tt(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(n*2,n*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,n){return new e(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}sa.className="RMSProp";gn(sa);class rn{static sgd(e){return new es(e)}static momentum(e,n,r=!1){return new ra(e,n,r)}static rmsprop(e,n=.9,r=0,s=null,a=!1){return new sa(e,n,r,s,a)}static adam(e=.001,n=.9,r=.999,s=null){return new ta(e,n,r,s)}static adadelta(e=.001,n=.95,r=null){return new Qs(e,n,r)}static adamax(e=.002,n=.9,r=.999,s=null,a=0){return new na(e,n,r,s,a)}static adagrad(e,n=.1){return new ea(e,n)}}const KS={sgd:rn.sgd,momentum:rn.momentum,adadelta:rn.adadelta,adagrad:rn.adagrad,rmsprop:rn.rmsprop,adamax:rn.adamax,adam:rn.adam};const XS=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t())();function YS(){return new Promise(t=>XS(()=>t()))}function ZS(t,e){const n=t[0].length;t.forEach((s,a)=>{S(s.length===n,()=>`Error in concat${n}D: rank of tensors[${a}] must be the same as the rank of the rest (${n})`)}),S(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=t[0];t.forEach((s,a)=>{for(let o=0;o<n;o++)S(o===e||s[o]===r[o],()=>`Error in concat${n}D: Shape of tensors[${a}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`)})}function JS(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}const Ni=30;function QS(t){return t<=Ni?t:Ts(t,Math.floor(Math.sqrt(t)))}function eN(t,e,n){const r=n*(typeof t=="number"?t:t[0]),s=e*(typeof t=="number"?t:t[1]);return[r,s]}function tN(t,e,n,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(t[0]/n),s=s.concat(t.slice(1));else{s=s.concat(t[0]);const a=e.length;for(let o=0;o<a;++o)s=s.concat([t[o+1]/e[o],e[o]]);s=s.concat(t.slice(a+1))}return s}function nN(t,e,n=!0){const r=[];if(n){r.push(e);for(let s=e+1;s<t;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],a=[];for(let o=1;o<t;++o)o>=e*2+1||o%2===1?a.push(o):s.push(o);r.push(...s),r.push(0),r.push(...a)}return r}function rN(t,e,n,r=!0){const s=[];r?s.push(t[0]/n):s.push(t[0]*n);for(let a=1;a<t.length;++a)a<=e.length?r?s.push(e[a-1]*t[a]):s.push(t[a]/e[a-1]):s.push(t[a]);return s}function sN(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function aN(t,e,n){const r=t.slice(0,1);for(let s=0;s<n;++s)r.push(t[s+1]-e[s][0]-e[s][1]);return r}const oN=1.7580993408473768,iN=1.0507009873554805;const uN=.3275911,lN=.254829592,cN=-.284496736,hN=1.421413741,fN=-1.453152027,pN=1.061405429;function dN(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(t.length*2);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function mN(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function gN(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function yN(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function bN(t,e){const n=t[e*2],r=t[e*2+1];return{real:n,imag:r}}function wN(t,e,n,r){t[r*2]=e,t[r*2+1]=n}function vN(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let s=0;s<Math.ceil(t/2);s++){const a=(e?2:-2)*Math.PI*(s/t);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function SN(t,e,n){const r=(n?2:-2)*Math.PI*(t/e),s=Math.cos(r),a=Math.sin(r);return{real:s,imag:a}}const Na="->",NN=/->/g,uu=",",lu="...";function TN(t,e){t=t.replace(/\s/g,"");const n=(t.length-t.replace(NN,"").length)/Na.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Na}").`);const[r,s]=t.split(Na);S(r.indexOf(lu)===-1,()=>`The ellipsis notation ("${lu}") is not supported yet.`);const a=r.split(uu),o=a.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let p=0;p<s.length;++p){const d=s[p];if(!a.some(b=>b.indexOf(d)!==-1))throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);i.indexOf(d)===-1&&i.push(d)}for(let p=0;p<r.length;++p){const d=r[p];i.indexOf(d)===-1&&d!==uu&&i.push(d)}const u=new Array(a.length);for(let p=0;p<o;++p){if(new Set(a[p].split("")).size!==a[p].length)throw new Error(`Found duplicate axes in input component ${a[p]}. Support for duplicate axes in input is not implemented yet.`);u[p]=[];for(let d=0;d<a[p].length;++d)u[p].push(i.indexOf(a[p][d]))}const l=i.length,c=s.length,h=[];for(let p=c;p<l;++p)h.push(p);return{allDims:i,summedDims:h,idDims:u}}function EN(t,e){let n=new Array(t);n.fill(-1);for(let s=0;s<e.length;++s)n[e[s]]=s;const r=[];for(let s=0;s<t;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function kN(t,e,n){const r=new Array(t);for(let s=0;s<n.length;++s){const a=n[s].shape;for(let o=0;o<e[s].length;++o)r[e[s][o]]===void 0?r[e[s][o]]=a[o]:S(r[e[s][o]]===a[o],()=>`Expected dimension ${r[e[s][o]]} at axis ${o} of input shaped ${JSON.stringify(a)}, but got dimension ${a[o]}`)}}function _N(t,e){const n=t,r=[];let s=0;t.length===0&&n.push(-1),s=t.length+1;for(let o=0;o<s;++o)r.push([]);const a=[];for(let o=0;o<n.length;++o){const i=n[o],u=$N(e,i);for(const l of u)a.indexOf(l)===-1&&(r[o].push(l),a.push(l))}return{path:n,steps:r}}function xN(t){return t.every((e,n)=>e===n)}function $N(t,e){const n=[];for(let r=0;r<t.length;++r)(t[r].length===0||t[r].indexOf(e)!==-1||e===-1)&&n.push(r);return n}function AN(t,e,n=0){let r=[];if(typeof e=="number")S(t.shape[n]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(t.shape[n]/e);else{const s=e.reduce((o,i)=>(i===-1&&(o+=1),o),0);S(s<=1,()=>"There should be only one negative value in split array.");const a=e.indexOf(-1);if(a!==-1){const o=e.reduce((i,u)=>u>0?i+u:i);e[a]=t.shape[n]-o}S(t.shape[n]===e.reduce((o,i)=>o+i),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}function IN(t){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`}function ON(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function DN(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}function FN(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function CN(t,e){return`size ${t} must be non-negative, not ${e}`}function PN(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function RN(t,e){const n=Ae(t),r=Ae(e);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${t} outputShape= ${e}`}function BN(t,e){const n=Ae(t),r=Ae(e);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${t} outputShape=${e}`}function LN(){return"segment ids must be >= 0"}function MN(){return"segment ids are not increasing"}function zN(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function VN(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}function jN(t,e){let n=!1,r;for(t<=Ni?(r=t,n=!0):r=Ts(t,Math.floor(Math.sqrt(t)));!n;)r>e||r===t?n=!0:r=Ts(t,r+1);return r}function UN(t,e,n){const r=[],s=t.length;for(let a=0;a<s;a++)a!==e?r.push(t[a]):r.push(n);return r}function WN(t,e,n,r){const s=e.shape.length,a=t.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let h=0;h<r;++h)if(t.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${t.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const o=t.shape[n],i=[];let u=1,l=1,c=1;for(let h=0;h<r;++h)i.push(t.shape[h]),u*=t.shape[h];for(let h=r;h<n;h++)i.push(t.shape[h]),l*=t.shape[h];for(let h=r;h<s;h++)i.push(e.shape[h]);for(let h=n+1;h<a;h++)i.push(t.shape[h]),c*=t.shape[h];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:o,outputShape:i}}var qN=Object.freeze(Object.defineProperty({__proto__:null,segOpComputeOptimalWindowSize:jN,computeOutShape:UN,collectGatherOpShapeInfo:WN},Symbol.toStringTag,{value:"Module"}));function HN(t){try{return t.map(e=>xs(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function GN(t){return t.map(e=>jr(e))}var KN=Object.freeze(Object.defineProperty({__proto__:null,slice_util:Sf,segment_util:qN,fromUint8ToStringArray:HN,fromStringArrayToUint8:GN,upcastType:zs,axesAreInnerMostDims:qo,combineLocations:dp,computeOutAndReduceShapes:j1,expandShapeToKeepDim:Yr,assertAxesAreInnerMostDims:U1,getAxesPermutation:W1,getUndoAxesPermutation:q1,getInnerMostAxes:H1,getBroadcastDims:lf,getReductionAxes:Do,assertAndGetBroadcastShape:Me,assertParamsConsistent:ZS,computeOutShape:JS,computeDilation2DInfo:jb,computePool2DInfo:Rf,computePool3DInfo:Ub,computeConv2DInfo:Hr,computeConv3DInfo:Bf,computeDefaultPad:zo,tupleValuesAreOne:Pr,eitherStridesOrDilationsAreOne:Qt,convertConv2DDataFormat:Lf,checkPadOnDimRoundingMode:Tt,getFusedDyActivation:Xs,getFusedBiasGradient:Ys,applyActivation:Zs,shouldFuse:Js,PARALLELIZE_THRESHOLD:Ni,computeOptimalWindowSize:QS,getImageCenter:eN,getReshaped:tN,getPermuted:nN,getReshapedPermuted:rN,getSliceBeginCoords:sN,getSliceSize:aN,prepareAndValidate:hf,validateUpdateShape:Co,validateInput:Po,calculateShapes:ff,SELU_SCALEALPHA:oN,SELU_SCALE:iN,ERF_P:uN,ERF_A1:lN,ERF_A2:cN,ERF_A3:hN,ERF_A4:fN,ERF_A5:pN,warn:sn,log:Gg,mergeRealAndImagArrays:dN,splitRealAndImagArrays:mN,complexWithEvenIndex:gN,complexWithOddIndex:yN,getComplexWithIndex:bN,assignToTypedArray:wN,exponents:vN,exponent:SN,decodeEinsumEquation:TN,getEinsumPermutation:EN,checkEinsumDimSizes:kN,getEinsumComputePath:_N,isIdentityPermutation:xN,prepareSplitSize:AN,getSparseFillEmptyRowsIndicesDenseShapeMismatch:IN,getSparseFillEmptyRowsNegativeIndexErrorMessage:ON,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:DN,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:FN,getSparseReshapeNegativeOutputDimErrorMessage:CN,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:PN,getSparseReshapeInputOutputMultipleErrorMessage:RN,getSparseReshapeInputOutputMismatchErrorMessage:BN,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:LN,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:MN,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:zN,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:VN},Symbol.toStringTag,{value:"Module"}));var XN=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:Ld,nonMaxSuppressionV4Impl:Md,nonMaxSuppressionV5Impl:zd,whereImpl:xd},Symbol.toStringTag,{value:"Module"}));var Gd=Object.freeze(Object.defineProperty({__proto__:null,AdadeltaOptimizer:Qs,AdagradOptimizer:ea,AdamOptimizer:ta,AdamaxOptimizer:na,MomentumOptimizer:ra,Optimizer:bn,OptimizerConstructors:rn,RMSPropOptimizer:sa,SGDOptimizer:es,Tensor:be,TensorBuffer:$s,Variable:Or,get Rank(){return La},sumOutType:vy,upcastType:zs,get Reduction(){return Ze},customGrad:Ht,grad:ww,grads:vw,valueAndGrad:Sw,valueAndGrads:Nw,variableGrads:Ep,Environment:Ku,env:re,get ENV(){return po},nextFrame:YS,KernelBackend:Bu,DataStorage:ug,abs:at,acos:kf,acosh:_f,add:Y,addN:xf,all:$f,any:Af,argMax:Mo,argMin:If,asin:Of,asinh:Df,atan:Ff,atan2:Cf,atanh:Pf,avgPool:Vo,avgPool3d:Mf,basicLSTMCell:zf,batchToSpaceND:jo,batchNorm:Gr,batchNorm2d:Vf,batchNorm3d:jf,batchNorm4d:Uf,bincount:Uo,broadcastArgs:Wf,broadcastTo:xr,buffer:Wt,cast:we,ceil:qf,clipByValue:Hf,clone:Zt,complex:Jt,concat:qe,concat1d:Gf,concat2d:Kf,concat3d:Xf,concat4d:Yf,conv1d:Zf,conv2d:Kr,conv2dTranspose:Qf,conv3d:ep,conv3dTranspose:tp,cos:np,cosh:rp,cumprod:sp,cumsum:ap,denseBincount:op,depthToSpace:ip,depthwiseConv2d:js,diag:up,dilation2d:lp,div:_e,divNoNan:cp,dot:hp,einsum:fp,elu:Wo,equal:Xr,erf:pp,euclideanNorm:gp,exp:fn,expandDims:ot,expm1:yp,eye:Ho,fill:Jr,floor:Go,floorDiv:Lo,gather:Ko,greater:fr,greaterEqual:Xo,imag:Wr,isFinite:bp,isInf:wp,isNaN:vp,leakyRelu:Yo,less:Sp,lessEqual:Us,linspace:Np,localResponseNormalization:Tp,log:lr,log1p:Zo,logSigmoid:kp,logSoftmax:_p,logSumExp:Qo,logicalAnd:Rr,logicalNot:ei,logicalOr:ti,logicalXor:xp,lowerBound:$p,matMul:ye,max:xn,maxPool:ni,maxPool3d:Ap,maxPoolWithArgmax:Ip,maximum:ri,mean:Br,meshgrid:Op,min:Ds,minimum:si,mirrorPad:ai,mod:Dp,moments:Fp,mul:U,multiRNNCell:Cp,multinomial:Pp,neg:zt,notEqual:oi,oneHot:Fr,ones:ln,onesLike:Rp,outerProduct:Bp,pad:zn,pad1d:Lp,pad2d:Mp,pad3d:ii,pad4d:zp,pool:Vp,pow:ur,prelu:li,print:xo,prod:jp,rand:Up,randomGamma:Zp,randomNormal:fi,randomStandardNormal:Jp,randomUniform:pi,range:pn,real:ir,reciprocal:Qp,relu:Qr,relu6:di,reshape:B,reverse:dn,reverse1d:ed,reverse2d:td,reverse3d:nd,reverse4d:rd,round:mi,rsqrt:sd,scalar:se,selu:ad,separableConv2d:od,setdiff1dAsync:id,sigmoid:Vt,sign:ud,sin:ld,sinh:cd,slice:Ee,slice1d:hd,slice2d:fd,slice3d:pd,slice4d:dd,softmax:md,softplus:Jo,spaceToBatchND:ui,fft:Hs,ifft:Lr,irfft:gi,rfft:Gs,split:cr,sqrt:qt,square:St,squaredDifference:yi,squeeze:bt,stack:Gt,step:bi,stridedSlice:gd,sub:ne,sum:$e,tan:yd,tanh:Os,tensor:vt,tensor1d:wt,tensor2d:$n,tensor3d:Fo,tensor4d:bd,tensor5d:wd,tensor6d:vd,tile:nr,topk:Sd,truncatedNormal:Nd,unique:Td,unsortedSegmentSum:Ed,unstack:yn,upperBound:kd,variable:_d,where:Cn,whereAsync:wi,zeros:Pn,zerosLike:ut,op:E,OP_SCOPE_SUFFIX:To,booleanMaskAsync:$d,transpose:Cr,norm:Zr,movingAverage:Ad,scatterND:Id,searchSorted:qs,sparseToDense:Od,gatherND:Dd,dropout:Fd,enclosingPowerOfTwo:vi,cosineWindow:Ks,inTopKAsync:Cd,image:Rn,linalg:Ud,losses:Wd,spectral:Vd,fused:Pd,signal:jd,sparse:qd,string:Hd,train:KS,enableProdMode:$0,enableDebugMode:A0,disableDeprecationWarnings:I0,deprecationWarn:O0,disposeVariables:D0,engine:Oo,memory:F0,profile:C0,tidy:Z,dispose:tt,keep:Lt,time:P0,setBackend:R0,ready:B0,getBackend:of,removeBackend:L0,findBackend:M0,findBackendFactory:z0,registerBackend:V0,backend:uf,setPlatform:j0,getKernel:Es,getGradient:Ca,getKernelsForBackend:ks,registerKernel:Fh,registerGradient:Kg,unregisterKernel:Xg,unregisterGradient:Yg,copyRegisteredKernels:Zg,Abs:Yu,Acos:Zu,Acosh:Ju,Add:go,AddN:Qu,All:el,Any:tl,ArgMax:nl,ArgMin:rl,Asin:sl,Asinh:al,Atan:ol,Atanh:il,Atan2:ul,AvgPool:ll,AvgPoolGrad:Ag,AvgPool3D:cl,AvgPool3DGrad:Ig,BatchMatMul:hl,BatchToSpaceND:fl,Bincount:pl,BroadcastTo:Og,BroadcastArgs:dl,Cast:yo,Ceil:ml,ClipByValue:gl,Complex:yl,ComplexAbs:bl,Concat:wl,Conv2D:vl,Conv2DBackpropFilter:Sl,Conv2DBackpropInput:Nl,Conv3D:Tl,Conv3DBackpropFilterV2:Dg,Conv3DBackpropInputV2:El,Cos:kl,Cosh:_l,Cumprod:xl,Cumsum:$l,CropAndResize:Al,DenseBincount:Il,DepthToSpace:Ol,DepthwiseConv2dNative:Dl,DepthwiseConv2dNativeBackpropFilter:Fl,DepthwiseConv2dNativeBackpropInput:Cl,Diag:Pl,Dilation2D:Rl,Dilation2DBackpropInput:Fg,Dilation2DBackpropFilter:Cg,RealDiv:Bl,Einsum:Ll,Elu:Ml,EluGrad:Pg,Erf:zl,Equal:Vl,Exp:jl,ExpandDims:Ul,Expm1:Wl,FFT:ql,Fill:Hl,FlipLeftRight:Gl,Floor:Kl,FloorDiv:Xl,FusedBatchNorm:Yl,GatherV2:Zl,GatherNd:Jl,Greater:Ql,GreaterEqual:ec,Identity:bo,IFFT:tc,Imag:nc,IsFinite:rc,IsInf:sc,IsNan:ac,LeakyRelu:oc,Less:ic,LessEqual:uc,LinSpace:lc,Log:cc,Log1p:hc,LogicalAnd:fc,LogicalNot:pc,LogicalOr:dc,LogicalXor:Rg,LogSoftmax:Bg,LowerBound:Lg,LRN:mc,LRNGrad:Mg,Max:gc,Maximum:yc,MaxPool:bc,MaxPoolGrad:zg,MaxPool3D:wc,MaxPool3DGrad:Vg,MaxPoolWithArgmax:vc,Mean:Sc,Min:Nc,Minimum:Tc,MirrorPad:Ec,Mod:kc,Multinomial:_c,Multiply:xc,Neg:$c,NotEqual:Ac,NonMaxSuppressionV3:Ic,NonMaxSuppressionV4:Oc,NonMaxSuppressionV5:Dc,OnesLike:Fc,OneHot:Cc,Pack:Pc,PadV2:Rc,Pool:jg,Pow:Bc,Prelu:Lc,Prod:Mc,Range:zc,Real:Vc,Reciprocal:jc,Relu:Uc,Reshape:Wc,ResizeNearestNeighbor:qc,ResizeNearestNeighborGrad:Ug,ResizeBilinear:Hc,ResizeBilinearGrad:Wg,Relu6:Gc,Reverse:Kc,Round:Xc,Rsqrt:Yc,ScatterNd:Zc,SearchSorted:Jc,Select:Qc,Selu:eh,Slice:th,Sin:nh,Sinh:rh,Sign:sh,Sigmoid:ah,Softplus:oh,Sqrt:ih,Sum:uh,SpaceToBatchND:lh,SplitV:ch,Softmax:hh,SparseFillEmptyRows:fh,SparseReshape:ph,SparseSegmentMean:dh,SparseSegmentSum:mh,SparseToDense:gh,SquaredDifference:yh,Square:qg,StridedSlice:bh,StringNGrams:wh,StringSplit:vh,StringToHashBucketFast:Sh,Sub:Nh,Tan:Th,Tanh:Eh,Tile:wo,TopK:kh,Transform:_h,Transpose:ys,Unique:xh,Unpack:$h,UnsortedSegmentSum:Ah,UpperBound:Hg,ZerosLike:Ih,Step:Oh,FromPixels:Ia,RotateWithOffset:Dh,_FusedMatMul:Oa,FusedConv2D:Da,FusedDepthwiseConv2D:Fa,version_core:Eb,browser:nb,io:Io,math:X0,serialization:mb,test_util:Tb,util:uy,backend_util:KN,broadcast_util:Y0,tensor_util:Ty,slice_util:Sf,gather_util:rb,scatter_util:sb,device_util:Ay,kernel_impls:XN},Symbol.toStringTag,{value:"Module"}));const YN=re();YN.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var pt;(function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"})(pt||(pt={}));var cu;(function(t){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(cu||(cu={}));const ZN={};function Kd(t){return ZN[t]}function m(t,e,n,r,s){const a=e.inputParams[t];if(a&&a.inputIndexStart!==void 0){const i=a.inputIndexStart,u=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?i+1:a.inputIndexEnd;if(a.type==="tensor")return Je(e.inputNames[a.inputIndexStart],n,r,s);if(a.type==="tensors")return e.inputNames.slice(i,u).map(p=>Je(p,n,r,s));const l=Je(e.inputNames.slice(i)[0],n,r,s),c=l.dataSync();return a.type==="number"?c[0]:kn(l.shape,c)}const o=e.attrParams[t];return o&&o.value}function Je(t,e,n,r){const[s,a]=st(t);if(r!=null){const i=r.getHashTableHandleByName(s);if(i!=null)return i}const o=n.currentContextIds.find(i=>!!e[Fs(s,i)]);return o!==void 0?e[Fs(s,o)][a]:void 0}function JN(t,e,n){return e[Fs(t,n.currentContextId)]}function Bt(t,e){const[n,r,s]=st(t);return[Fs(n,e&&e.currentContextId),r,s]}function Fs(t,e){return e?`${t}-${e}`:t}function st(t){const e=t.split(":");if(e.length===1)return[t,0,void 0];const n=e[0],r=e.length===3?e[1]:void 0,s=Number(e[e.length-1]);return[n,s,r]}function vs(t,e,n){let r=m("pad",t,e,n);if(r==="explicit"){r=m("explicitPaddings",t,e,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)s[a][0]=r[a*2],s[a][1]=r[a*2+1];return s}return r}function Xt(t){return t.kept?t:Zt(t)}const QN=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var eT=Object.freeze(Object.defineProperty({__proto__:null,json:QN},Symbol.toStringTag,{value:"Module"}));const tT=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var nT=Object.freeze(Object.defineProperty({__proto__:null,json:tT},Symbol.toStringTag,{value:"Module"}));const rT=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var sT=Object.freeze(Object.defineProperty({__proto__:null,json:rT},Symbol.toStringTag,{value:"Module"}));const aT=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var oT=Object.freeze(Object.defineProperty({__proto__:null,json:aT},Symbol.toStringTag,{value:"Module"}));const iT=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var uT=Object.freeze(Object.defineProperty({__proto__:null,json:iT},Symbol.toStringTag,{value:"Module"}));const lT=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var cT=Object.freeze(Object.defineProperty({__proto__:null,json:lT},Symbol.toStringTag,{value:"Module"}));const hT=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var fT=Object.freeze(Object.defineProperty({__proto__:null,json:hT},Symbol.toStringTag,{value:"Module"}));const pT=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var dT=Object.freeze(Object.defineProperty({__proto__:null,json:pT},Symbol.toStringTag,{value:"Module"}));const mT=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var gT=Object.freeze(Object.defineProperty({__proto__:null,json:mT},Symbol.toStringTag,{value:"Module"}));const yT=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var bT=Object.freeze(Object.defineProperty({__proto__:null,json:yT},Symbol.toStringTag,{value:"Module"}));const wT=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var vT=Object.freeze(Object.defineProperty({__proto__:null,json:wT},Symbol.toStringTag,{value:"Module"}));const ST=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var NT=Object.freeze(Object.defineProperty({__proto__:null,json:ST},Symbol.toStringTag,{value:"Module"}));const TT=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var ET=Object.freeze(Object.defineProperty({__proto__:null,json:TT},Symbol.toStringTag,{value:"Module"}));const kT=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var _T=Object.freeze(Object.defineProperty({__proto__:null,json:kT},Symbol.toStringTag,{value:"Module"}));const xT=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var $T=Object.freeze(Object.defineProperty({__proto__:null,json:xT},Symbol.toStringTag,{value:"Module"}));const AT=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var IT=Object.freeze(Object.defineProperty({__proto__:null,json:AT},Symbol.toStringTag,{value:"Module"}));const OT=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var DT=Object.freeze(Object.defineProperty({__proto__:null,json:OT},Symbol.toStringTag,{value:"Module"}));const FT=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var CT=Object.freeze(Object.defineProperty({__proto__:null,json:FT},Symbol.toStringTag,{value:"Module"}));const PT=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var RT=Object.freeze(Object.defineProperty({__proto__:null,json:PT},Symbol.toStringTag,{value:"Module"}));class hu{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[eT,nT,sT,oT,uT,cT,fT,dT,gT,bT,vT,NT,ET,_T,$T,IT,DT,CT,RT],n=[].concat(...e.map(r=>r.json));this.opMappers=n.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(e,n={}){const r=e.node,s=[],a=[],o=[],i=r.reduce((v,N)=>(v[N.name]=this.mapNode(N),N.op.startsWith("Placeholder")?s.push(v[N.name]):N.op==="Const"?a.push(v[N.name]):(N.input==null||N.input.length===0)&&o.push(v[N.name]),v),{});let u=[];const l=[];let c={},h={};n!=null&&(c=this.mapSignatureEntries(n.inputs),h=this.mapSignatureEntries(n.outputs));const p=Object.keys(i);p.forEach(v=>{const N=i[v];N.inputNames.forEach((x,F)=>{const[_,,$]=Bt(x),A=i[_];if(A.outputs!=null){const C=A.outputs.indexOf($);if(C!==-1){const M=`${_}:${C}`;N.inputNames[F]=M}}N.inputs.push(A),A.children.push(N)})}),Object.keys(h).length===0?p.forEach(v=>{const N=i[v];N.children.length===0&&l.push(N)}):Object.keys(h).forEach(v=>{const[N]=Bt(v),x=i[N];x!=null&&(x.signatureKey=h[v],l.push(x))}),Object.keys(c).length>0?Object.keys(c).forEach(v=>{const[N]=Bt(v),x=i[N];x&&(x.signatureKey=c[v],u.push(x))}):u=s;let d={};e.library!=null&&e.library.function!=null&&(d=e.library.function.reduce((v,N)=>(v[N.signature.name]=this.mapFunction(N),v),{}));const b={nodes:i,inputs:u,outputs:l,weights:a,placeholders:s,signature:n,functions:d};return o.length>0&&(b.initNodes=o),b}mapSignatureEntries(e){return Object.keys(e||{}).reduce((n,r)=>(n[e[r].name]=r,n),{})}mapNode(e){const n=Kd(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:n.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:n.outputs};return n.inputs!=null&&(r.inputParams=n.inputs.reduce((s,a)=>(s[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},s),{})),n.attrs!=null&&(r.attrParams=n.attrs.reduce((s,a)=>{const o=a.type;let i;switch(a.type){case"string":i=Ja(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=Ja(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":i=ao(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=ao(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":i=eo(e.attr,a.tfName,a.defaultValue||0),i===void 0&&!!a.tfDeprecatedName&&(i=eo(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":i=so(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=so(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":i=Qa(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=Qa(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":i=io(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=io(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":i=ro(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=ro(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":i=oo(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=oo(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":i=to(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=to(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":i=no(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=no(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":i=fu(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=fu(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return s[a.name]={value:i,type:o},s},{})),r}mapFunction(e){const n=e.nodeDef,r=[],s=[];let a={};n!=null&&(a=n.reduce((h,p)=>(h[p.name]=this.mapNode(p),p.op==="Const"&&s.push(h[p.name]),h),{}));const o=[],i=[];e.signature.inputArg.forEach(h=>{const[p]=Bt(h.name),d={name:p,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Ti(h.type),type:"dtype"}},children:[]};d.signatureKey=h.name,o.push(d),a[p]=d}),Object.keys(a).forEach(h=>{const p=a[h];p.inputNames.forEach((d,b)=>{const[v,,N]=Bt(d),x=a[v];if(x.outputs!=null){const F=x.outputs.indexOf(N);if(F!==-1){const _=`${v}:${F}`;p.inputNames[b]=_}}p.inputs.push(x),x.children.push(p)})});const l=e.ret;e.signature.outputArg.forEach(h=>{const[p,d]=Bt(l[h.name]),b=a[p];b!=null&&(b.defaultOutput=d,i.push(b))});const c=this.mapArgsToSignature(e);return{nodes:a,inputs:o,outputs:i,weights:s,placeholders:r,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r),n),{}),outputs:e.signature.outputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r,e.ret),n),{})}}mapArgToTensorInfo(e,n){let r=e.name;return n!=null&&(r=n[r]),{name:r,dtype:e.type}}}function BT(t){const e=re().global;if(typeof e.atob<"u")return e.atob(t);if(typeof Buffer<"u")return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function Xd(t,e){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):BT(t);return e?n:n.toLowerCase()}function Ja(t,e,n,r=!1){const s=t[e];return s!=null?Xd(s.s,r):n}function Qa(t,e,n){const r=t[e];return r?r.b:n}function eo(t,e,n){const r=t[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:n;return typeof s=="number"?s:parseInt(s,10)}function Ti(t){switch(typeof t=="string"&&(t=pt[t]),t){case pt.DT_FLOAT:case pt.DT_HALF:return"float32";case pt.DT_INT32:case pt.DT_INT64:case pt.DT_INT8:case pt.DT_UINT8:return"int32";case pt.DT_BOOL:return"bool";case pt.DT_DOUBLE:return"float32";case pt.DT_STRING:return"string";default:return null}}function fu(t,e,n){const r=t[e];return r&&r.func?r.func.name:n}function to(t,e,n){const r=t[e];return r&&r.type?Ti(r.type):n}function no(t,e,n){const r=t[e];return r&&r.list&&r.list.type?r.list.type.map(s=>Ti(s)):n}function Yd(t){if(!t.unknownRank)return t.dim!=null?t.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function ro(t,e,n){const r=t[e];return r&&r.shape?Yd(r.shape):n}function so(t,e,n){const r=t[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):n}function ao(t,e,n,r=!1){const s=t[e];return s&&s.list&&s.list.s?s.list.s.map(a=>Xd(a,r)):n}function oo(t,e,n){const r=t[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>Yd(s)):n}function io(t,e,n){const r=t[e];return r&&r.list&&r.list.b?r.list.b:n}class LT{constructor(e,n,r){this.node=e,this.tensorMap=n,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,a)=>(s[a]=this.getAttr(a),s),{}))}getInput(e){return Je(e,this.tensorMap,this.context)}getAttr(e,n){const r=this.node.rawAttrs[e];if(r.tensor!=null)return Je(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return eo(this.node.rawAttrs,e,n);if(r.s!=null)return Ja(this.node.rawAttrs,e,n);if(r.b!=null)return Qa(this.node.rawAttrs,e,n);if(r.shape!=null)return ro(this.node.rawAttrs,e,n);if(r.type!=null)return to(this.node.rawAttrs,e,n);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return so(this.node.rawAttrs,e,n);if(r.list.s!=null)return ao(this.node.rawAttrs,e,n);if(r.list.shape!=null)return oo(this.node.rawAttrs,e,n);if(r.list.b!=null)return io(this.node.rawAttrs,e,n);if(r.list.type!=null)return no(this.node.rawAttrs,e,n)}return n}}var He=Object.freeze(Object.defineProperty({__proto__:null,abs:at,acos:kf,acosh:_f,add:Y,addN:xf,all:$f,any:Af,argMax:Mo,argMin:If,asin:Of,asinh:Df,atan:Ff,atan2:Cf,atanh:Pf,avgPool:Vo,avgPool3d:Mf,basicLSTMCell:zf,batchToSpaceND:jo,batchNorm:Gr,batchNorm2d:Vf,batchNorm3d:jf,batchNorm4d:Uf,bincount:Uo,broadcastArgs:Wf,broadcastTo:xr,buffer:Wt,cast:we,ceil:qf,clipByValue:Hf,clone:Zt,complex:Jt,concat:qe,concat1d:Gf,concat2d:Kf,concat3d:Xf,concat4d:Yf,conv1d:Zf,conv2d:Kr,conv2dTranspose:Qf,conv3d:ep,conv3dTranspose:tp,cos:np,cosh:rp,cumprod:sp,cumsum:ap,denseBincount:op,depthToSpace:ip,depthwiseConv2d:js,diag:up,dilation2d:lp,div:_e,divNoNan:cp,dot:hp,einsum:fp,elu:Wo,equal:Xr,erf:pp,euclideanNorm:gp,exp:fn,expandDims:ot,expm1:yp,eye:Ho,fill:Jr,floor:Go,floorDiv:Lo,gather:Ko,greater:fr,greaterEqual:Xo,imag:Wr,isFinite:bp,isInf:wp,isNaN:vp,leakyRelu:Yo,less:Sp,lessEqual:Us,linspace:Np,localResponseNormalization:Tp,log:lr,log1p:Zo,logSigmoid:kp,logSoftmax:_p,logSumExp:Qo,logicalAnd:Rr,logicalNot:ei,logicalOr:ti,logicalXor:xp,lowerBound:$p,matMul:ye,max:xn,maxPool:ni,maxPool3d:Ap,maxPoolWithArgmax:Ip,maximum:ri,mean:Br,meshgrid:Op,min:Ds,minimum:si,mirrorPad:ai,mod:Dp,moments:Fp,mul:U,multiRNNCell:Cp,multinomial:Pp,neg:zt,notEqual:oi,oneHot:Fr,ones:ln,onesLike:Rp,outerProduct:Bp,pad:zn,pad1d:Lp,pad2d:Mp,pad3d:ii,pad4d:zp,pool:Vp,pow:ur,prelu:li,print:xo,prod:jp,rand:Up,randomGamma:Zp,randomNormal:fi,randomStandardNormal:Jp,randomUniform:pi,range:pn,real:ir,reciprocal:Qp,relu:Qr,relu6:di,reshape:B,reverse:dn,reverse1d:ed,reverse2d:td,reverse3d:nd,reverse4d:rd,round:mi,rsqrt:sd,scalar:se,selu:ad,separableConv2d:od,setdiff1dAsync:id,sigmoid:Vt,sign:ud,sin:ld,sinh:cd,slice:Ee,slice1d:hd,slice2d:fd,slice3d:pd,slice4d:dd,softmax:md,softplus:Jo,spaceToBatchND:ui,fft:Hs,ifft:Lr,irfft:gi,rfft:Gs,split:cr,sqrt:qt,square:St,squaredDifference:yi,squeeze:bt,stack:Gt,step:bi,stridedSlice:gd,sub:ne,sum:$e,tan:yd,tanh:Os,tensor:vt,tensor1d:wt,tensor2d:$n,tensor3d:Fo,tensor4d:bd,tensor5d:wd,tensor6d:vd,tile:nr,topk:Sd,truncatedNormal:Nd,unique:Td,unsortedSegmentSum:Ed,unstack:yn,upperBound:kd,variable:_d,where:Cn,whereAsync:wi,zeros:Pn,zerosLike:ut,op:E,OP_SCOPE_SUFFIX:To,booleanMaskAsync:$d,transpose:Cr,norm:Zr,movingAverage:Ad,scatterND:Id,searchSorted:qs,sparseToDense:Od,gatherND:Dd,dropout:Fd,enclosingPowerOfTwo:vi,cosineWindow:Ks,inTopKAsync:Cd,image:Rn,linalg:Ud,losses:Wd,spectral:Vd,fused:Pd,signal:jd,sparse:qd,string:Hd},Symbol.toStringTag,{value:"Module"}));const MT=(t,e,n,r=He)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(m("a",t,e,n),m("b",t,e,n))];case"AddN":return[r.addN(m("tensors",t,e,n))];case"FloorMod":case"Mod":return[r.mod(m("a",t,e,n),m("b",t,e,n))];case"Mul":return[r.mul(m("a",t,e,n),m("b",t,e,n))];case"RealDiv":case"Div":return[r.div(m("a",t,e,n),m("b",t,e,n))];case"DivNoNan":return[r.divNoNan(m("a",t,e,n),m("b",t,e,n))];case"FloorDiv":return[r.floorDiv(m("a",t,e,n),m("b",t,e,n))];case"Sub":return[r.sub(m("a",t,e,n),m("b",t,e,n))];case"Minimum":return[r.minimum(m("a",t,e,n),m("b",t,e,n))];case"Maximum":return[r.maximum(m("a",t,e,n),m("b",t,e,n))];case"Pow":return[r.pow(m("a",t,e,n),m("b",t,e,n))];case"SquaredDifference":return[r.squaredDifference(m("a",t,e,n),m("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const zT=(t,e,n,r=He)=>{switch(t.op){case"Abs":case"ComplexAbs":return[r.abs(m("x",t,e,n))];case"Acos":return[r.acos(m("x",t,e,n))];case"Acosh":return[r.acosh(m("x",t,e,n))];case"Asin":return[r.asin(m("x",t,e,n))];case"Asinh":return[r.asinh(m("x",t,e,n))];case"Atan":return[r.atan(m("x",t,e,n))];case"Atan2":return[r.atan2(m("x",t,e,n),m("y",t,e,n))];case"Atanh":return[r.atanh(m("x",t,e,n))];case"Ceil":return[r.ceil(m("x",t,e,n))];case"Complex":return[r.complex(m("real",t,e,n),m("imag",t,e,n))];case"Cos":return[r.cos(m("x",t,e,n))];case"Cosh":return[r.cosh(m("x",t,e,n))];case"Elu":return[r.elu(m("x",t,e,n))];case"Erf":return[r.erf(m("x",t,e,n))];case"Exp":return[r.exp(m("x",t,e,n))];case"Expm1":return[r.expm1(m("x",t,e,n))];case"Floor":return[r.floor(m("x",t,e,n))];case"Log":return[r.log(m("x",t,e,n))];case"Log1p":return[r.log1p(m("x",t,e,n))];case"Imag":return[r.imag(m("x",t,e,n))];case"Neg":return[r.neg(m("x",t,e,n))];case"Reciprocal":return[r.reciprocal(m("x",t,e,n))];case"Real":return[r.real(m("x",t,e,n))];case"Relu":return[r.relu(m("x",t,e,n))];case"Round":return[r.round(m("x",t,e,n))];case"Selu":return[r.selu(m("x",t,e,n))];case"Sigmoid":return[r.sigmoid(m("x",t,e,n))];case"Sin":return[r.sin(m("x",t,e,n))];case"Sign":return[r.sign(m("x",t,e,n))];case"Sinh":return[r.sinh(m("x",t,e,n))];case"Softplus":return[r.softplus(m("x",t,e,n))];case"Sqrt":return[r.sqrt(m("x",t,e,n))];case"Square":return[r.square(m("x",t,e,n))];case"Tanh":return[r.tanh(m("x",t,e,n))];case"Tan":return[r.tan(m("x",t,e,n))];case"ClipByValue":return[r.clipByValue(m("x",t,e,n),m("clipValueMin",t,e,n),m("clipValueMax",t,e,n))];case"Relu6":return[r.relu6(m("x",t,e,n))];case"Rsqrt":return[r.rsqrt(Je(t.inputNames[0],e,n))];case"Prod":return[r.prod(m("x",t,e,n),m("axes",t,e,n))];case"LeakyRelu":return[r.leakyRelu(m("x",t,e,n),m("alpha",t,e,n))];case"Prelu":return[r.prelu(m("x",t,e,n),m("alpha",t,e,n))];case"IsNan":return[r.isNaN(Je(t.inputNames[0],e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function dt(t,e,n=""){if(!(typeof t=="number"||typeof e=="number")){S(t.length===e.length,()=>n+` Shapes ${t} and ${e} must match`);for(let r=0;r<t.length;r++){const s=t[r],a=e[r];S(s<0||a<0||s===a,()=>n+` Shapes ${t} and ${e} must match`)}}}function pu(t){return!(typeof t=="number"||t.some(e=>e<0))}function vr(t,e,n){let r=uo(t,n);const s=!pu(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(a=>{r=uo(a.shape,r)}),!pu(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function uo(t,e){if(typeof t=="number")return e;if(typeof e=="number")return t;if(t.length!==e.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);const n=[];for(let r=0;r<t.length;++r){const s=t[r],a=e[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);n[r]=s>=0?s:a}return n}class VT{constructor(e,n,r,s,a,o,i){this.name=e,this.dtype=n,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=a,this.dynamicSize=o,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=se(0),Lt(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const n=this.tensors[e];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(e){return e.map(n=>this.read(n))}write(e,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),dt(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=n,Lt(n),r.written=!0,this.tensors[e]=r}writeMany(e,n){if(e.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${n.length}.`);e.forEach((r,s)=>this.write(r,n[s]))}gather(e,n){if(!!n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return vt([],[0].concat(this.elementShape));const r=this.readMany(e);return dt(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Gt(r,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return vt([],[0].concat(this.elementShape));const n=[];for(let s=0;s<this.size();s++)n.push(s);const r=this.readMany(n);return dt(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),qe(r,0)}scatter(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,yn(n,0))}split(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let r=0;const s=e.map(u=>(r+=u,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const a=r===0?0:n.size/r,o=[];Z(()=>{n=B(n,[1,r,a]);for(let u=0;u<e.length;++u){const l=u===0?0:s[u-1],c=[0,l,0],h=[1,e[u],a];o[u]=B(Ee(n,c,h),this.elementShape)}return o});const i=[];for(let u=0;u<e.length;u++)i[u]=u;this.writeMany(i,o)}}class Bn{constructor(e,n,r,s=-1){this.tensors=e,this.elementShape=n,this.elementDtype=r,e?.forEach(a=>{if(r!==a.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${a.dtype}`);dt(n,a.shape,"TensorList shape mismatch: "),Lt(a)}),this.idTensor=se(0),this.maxNumElements=s,Lt(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Bn([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);dt(e,this.elementShape,"TensorList shape mismatch: ");const s=vr(this.elementShape,this.tensors,e);return Z(()=>{const a=this.tensors.map(o=>B(o,s));return Gt(a,0)})}popBack(e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=vr(this.elementShape,this.tensors,e),s=this.tensors.pop();return dt(s.shape,e,"TensorList shape mismatch: "),B(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(dt(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Lt(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const n=new Bn([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)n.tensors[r]=this.tensors[r];return n}getItem(e,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);dt(this.tensors[e].shape,n,"TensorList shape mismatch: ");const s=vr(this.elementShape,this.tensors,n);return B(this.tensors[e],s)}setItem(e,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);dt(this.elementShape,n.shape,"TensorList shape mismatch: "),Lt(n),this.tensors[e]=n}gather(e,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);dt(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=vr(this.elementShape,this.tensors,r);return e.length===0?vt([],[0].concat(s)):Z(()=>{const a=e.map(o=>B(this.tensors[o],s));return Gt(a,0)})}concat(e,n){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);dt(this.elementShape,n,"TensorList shape mismatch: ");const r=vr(this.elementShape,this.tensors,n);return this.size()===0?vt([],[0].concat(r)):Z(()=>{const s=this.tensors.map(a=>B(a,r));return qe(s,0)})}}function jT(t,e,n){const r=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);const s=t.shape.slice(1);dt(s,e,"TensorList shape mismatch: ");const a=yn(t);return new Bn(a,e,r)}function UT(t,e,n,r){return new Bn([],t,e,r)}function WT(t,e,n,r){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const a=new Bn([],n,t.dtype,r),o=yn(t,0);return e.forEach((i,u)=>{a.setItem(i,o[u])}),a}function qT(t,e,n){let r=0;const s=e.map(c=>(r+=c,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);const a=t.shape.slice(1),o=uo(a,n),i=r===0?0:t.size/r,u=Z(()=>{const c=[];t=B(t,[1,r,i]);for(let h=0;h<e.length;++h){const p=h===0?0:s[h-1],d=[0,p,0],b=[1,e[h],i];c[h]=B(Ee(t,d,b),o)}return t.dispose(),c}),l=new Bn([],n,t.dtype,e.length);for(let c=0;c<u.length;c++)l.setItem(c,u[c]);return l}const HT=async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{const r=m("thenBranch",t,e,n),s=m("elseBranch",t,e,n),a=m("cond",t,e,n),o=m("args",t,e,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=m("body",t,e,n),s=m("cond",t,e,n),a=m("args",t,e,n),o=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),i=a.map(c=>c.id);let u=await o[0].data();o.forEach(c=>{!c.kept&&i.indexOf(c.id)===-1&&c.dispose()});let l=a;for(;u[0];){const c=l;l=await n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const h=l.map(d=>d.id);c.forEach(d=>{!d.kept&&i.indexOf(d.id)===-1&&h.indexOf(d.id)===-1&&d.dispose()});const p=await n.functionMap[s].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);u=await p[0].data(),p.forEach(d=>{!d.kept&&i.indexOf(d.id)===-1&&h.indexOf(d.id)===-1&&d.dispose()})}return l}case"LoopCond":{const r=m("pred",t,e,n);return[Xt(r)]}case"Switch":{const r=m("pred",t,e,n);let s=m("data",t,e,n);return s.kept||(s=Xt(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=t.inputNames.find(s=>Je(s,e,n)!==void 0);if(r){const s=Je(r,e,n);return[Xt(s)]}return}case"Enter":{const r=m("frameName",t,e,n),s=m("tensor",t,e,n);return n.enterFrame(r),[Xt(s)]}case"Exit":{const r=m("tensor",t,e,n);return n.exitFrame(),[Xt(r)]}case"NextIteration":{const r=m("tensor",t,e,n);return n.nextIteration(),[Xt(r)]}case"TensorArrayV3":{const r=m("size",t,e,n),s=m("dtype",t,e,n),a=m("elementShape",t,e,n),o=m("dynamicSize",t,e,n),i=m("clearAfterRead",t,e,n),u=m("identicalElementShapes",t,e,n),l=m("name",t,e,n),c=new VT(l,s,r,a,u,o,i);return n.addTensorArray(c),[c.idTensor,se(1)]}case"TensorArrayWriteV3":{const r=m("tensorArrayId",t,e,n),s=m("index",t,e,n),a=m("tensor",t,e,n),o=n.getTensorArray(r.id);return o.write(s,a),[o.idTensor]}case"TensorArrayReadV3":{const r=m("tensorArrayId",t,e,n),s=m("index",t,e,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=m("tensorArrayId",t,e,n),s=m("indices",t,e,n),a=m("dtype",t,e,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{const r=m("tensorArrayId",t,e,n),s=m("indices",t,e,n),a=m("tensor",t,e,n),o=n.getTensorArray(r.id);return o.scatter(s,a),[o.idTensor]}case"TensorArrayConcatV3":{const r=m("tensorArrayId",t,e,n),s=n.getTensorArray(r.id),a=m("dtype",t,e,n);return[s.concat(a)]}case"TensorArraySplitV3":{const r=m("tensorArrayId",t,e,n),s=m("tensor",t,e,n),a=m("lengths",t,e,n),o=n.getTensorArray(r.id);return o.split(a,s),[o.idTensor]}case"TensorArraySizeV3":{const r=m("tensorArrayId",t,e,n),s=n.getTensorArray(r.id);return[se(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=m("tensorArrayId",t,e,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=m("tensorListId",t,e,n),s=m("index",t,e,n),a=m("tensor",t,e,n),o=n.getTensorList(r.id);return o.setItem(s,a),[o.idTensor]}case"TensorListGetItem":{const r=m("tensorListId",t,e,n),s=m("index",t,e,n),a=m("elementShape",t,e,n),o=m("elementDType",t,e,n);return[n.getTensorList(r.id).getItem(s,a,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=m("indices",t,e,n),s=m("tensor",t,e,n),a=m("elementShape",t,e,n),o=m("numElements",t,e,n),i=WT(s,r,a,o);return n.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=m("elementShape",t,e,n),s=m("elementDType",t,e,n);let a;t.op==="TensorListReserve"?a="numElements":a="maxNumElements";const o=m(a,t,e,n),i=t.op==="TensorListReserve"?-1:o,u=UT(r,s,o,i);return n.addTensorList(u),[u.idTensor]}case"TensorListGather":{const r=m("tensorListId",t,e,n),s=m("indices",t,e,n),a=m("elementShape",t,e,n),o=m("elementDType",t,e,n);return[n.getTensorList(r.id).gather(s,o,a)]}case"TensorListStack":{const r=m("tensorListId",t,e,n),s=m("elementShape",t,e,n),a=m("elementDType",t,e,n),o=m("numElements",t,e,n);return[n.getTensorList(r.id).stack(s,a,o)]}case"TensorListFromTensor":{const r=m("tensor",t,e,n),s=m("elementShape",t,e,n),a=m("elementDType",t,e,n),o=jT(r,s,a);return n.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=m("tensorListId",t,e,n),s=n.getTensorList(r.id),a=m("dtype",t,e,n),o=m("elementShape",t,e,n);return[s.concat(a,o)]}case"TensorListPushBack":{const r=m("tensorListId",t,e,n),s=m("tensor",t,e,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{const r=m("tensorListId",t,e,n),s=m("elementShape",t,e,n),a=m("elementDType",t,e,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{const r=m("tensor",t,e,n),s=m("elementShape",t,e,n),a=m("lengths",t,e,n),o=qT(r,a,s);return n.addTensorList(o),[o.idTensor]}case"TensorListLength":{const r=m("tensorListId",t,e,n),s=n.getTensorList(r.id);return[se(s.size(),"int32")]}case"TensorListResize":{const r=m("tensorListId",t,e,n),s=m("size",t,e,n),o=n.getTensorList(r.id).resize(s);return n.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};function du(t,e,n){const[r,s]=m("fusedOps",t,e,n),a=r==="biasadd",o=!a,i=s==="prelu",u=r==="fusedbatchnorm",l=m("numArgs",t,e,n);if(a){if(i&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&a&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=m("strides",t,e,n),h=vs(t,e,n),p=m("dataFormat",t,e,n).toUpperCase(),d=m("dilations",t,e,n);let[b,v]=m("args",t,e,n);o&&(v=b,b=void 0);const N=m("leakyreluAlpha",t,e,n);return{stride:c,pad:h,dataFormat:p,dilations:d,biasArg:b,preluArg:v,activationFunc:s,leakyreluAlpha:N}}const GT=(t,e,n,r=He)=>{switch(t.op){case"Conv1D":{const s=m("stride",t,e,n),a=m("pad",t,e,n),o=m("dataFormat",t,e,n).toUpperCase(),i=m("dilation",t,e,n);return[r.conv1d(m("x",t,e,n),m("filter",t,e,n),s,a,o,i)]}case"Conv2D":{const s=m("strides",t,e,n),a=vs(t,e,n),o=m("dataFormat",t,e,n).toUpperCase(),i=m("dilations",t,e,n);return[r.conv2d(m("x",t,e,n),m("filter",t,e,n),[s[1],s[2]],a,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:s,pad:a,dataFormat:o,dilations:i,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:h}=du(t,e,n);return[r.fused.conv2d({x:m("x",t,e,n),filter:m("filter",t,e,n),strides:[s[1],s[2]],pad:a,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:a,dataFormat:o,dilations:i,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:h}=du(t,e,n);return[r.fused.depthwiseConv2d({x:m("x",t,e,n),filter:m("filter",t,e,n),strides:[s[1],s[2]],pad:a,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=m("outputShape",t,e,n),a=m("strides",t,e,n),o=vs(t,e,n);return[r.conv2dTranspose(m("x",t,e,n),m("filter",t,e,n),s,[a[1],a[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=m("strides",t,e,n),a=vs(t,e,n),o=m("dilations",t,e,n),i=m("dataFormat",t,e,n).toUpperCase();return[r.depthwiseConv2d(m("input",t,e,n),m("filter",t,e,n),[s[1],s[2]],a,i,[o[1],o[2]])]}case"Conv3D":{const s=m("strides",t,e,n),a=m("pad",t,e,n),o=m("dataFormat",t,e,n).toUpperCase(),i=m("dilations",t,e,n);return[r.conv3d(m("x",t,e,n),m("filter",t,e,n),[s[1],s[2],s[3]],a,o,[i[1],i[2],i[3]])]}case"AvgPool":{const s=m("strides",t,e,n),a=m("pad",t,e,n),o=m("kernelSize",t,e,n);return[r.avgPool(m("x",t,e,n),[o[1],o[2]],[s[1],s[2]],a)]}case"MaxPool":{const s=m("strides",t,e,n),a=m("pad",t,e,n),o=m("kernelSize",t,e,n);return[r.maxPool(m("x",t,e,n),[o[1],o[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{const s=m("strides",t,e,n),a=m("pad",t,e,n),o=m("kernelSize",t,e,n),i=m("includeBatchInIndex",t,e,n),{result:u,indexes:l}=r.maxPoolWithArgmax(m("x",t,e,n),[o[1],o[2]],[s[1],s[2]],a,i);return[u,l]}case"AvgPool3D":{const s=m("strides",t,e,n),a=m("pad",t,e,n),o=m("kernelSize",t,e,n);return[r.avgPool3d(m("x",t,e,n),[o[1],o[2],o[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{const s=m("strides",t,e,n),a=m("pad",t,e,n),o=m("kernelSize",t,e,n);return[r.maxPool3d(m("x",t,e,n),[o[1],o[2],o[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{const s=m("strides",t,e,n),a=m("pad",t,e,n),o=m("dilations",t,e,n),i=s[1],u=s[2],l=o[1],c=o[2];return[r.dilation2d(m("x",t,e,n),m("filter",t,e,n),[i,u],a,[l,c],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const KT=(t,e,n,r=He)=>{switch(t.op){case"Fill":{const s=m("shape",t,e,n),a=m("dtype",t,e,n),o=m("value",t,e,n);return[r.fill(s,o,a)]}case"LinSpace":{const s=m("start",t,e,n),a=m("stop",t,e,n),o=m("num",t,e,n);return[r.linspace(s,a,o)]}case"Multinomial":{const s=m("logits",t,e,n),a=m("numSamples",t,e,n),o=m("seed",t,e,n);return[r.multinomial(s,a,o)]}case"OneHot":{const s=m("indices",t,e,n),a=m("depth",t,e,n),o=m("onValue",t,e,n),i=m("offValue",t,e,n);return[r.oneHot(s,a,o,i)]}case"Ones":return[r.ones(m("shape",t,e,n),m("dtype",t,e,n))];case"OnesLike":return[r.onesLike(m("x",t,e,n))];case"RandomStandardNormal":return[r.randomStandardNormal(m("shape",t,e,n),m("dtype",t,e,n),m("seed",t,e,n))];case"RandomUniform":return[r.randomUniform(m("shape",t,e,n),m("minval",t,e,n),m("maxval",t,e,n),m("dtype",t,e,n))];case"Range":{const s=m("start",t,e,n),a=m("stop",t,e,n),o=m("step",t,e,n);return[r.range(s,a,o,m("dtype",t,e,n))]}case"TruncatedNormal":{const s=m("shape",t,e,n),a=m("mean",t,e,n),o=m("stdDev",t,e,n),i=m("seed",t,e,n);return[r.truncatedNormal(s,a,o,m("dtype",t,e,n),i)]}case"Zeros":return[r.zeros(m("shape",t,e,n),m("dtype",t,e,n))];case"ZerosLike":return[r.zerosLike(m("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function Ta(t,e,n){const r=m("boxes",t,e,n),s=m("scores",t,e,n),a=m("maxOutputSize",t,e,n),o=m("iouThreshold",t,e,n),i=m("scoreThreshold",t,e,n),u=m("softNmsSigma",t,e,n);return{boxes:r,scores:s,maxOutputSize:a,iouThreshold:o,scoreThreshold:i,softNmsSigma:u}}const XT=async(t,e,n,r,s=He)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:l,softNmsSigma:c}=Ta(t,e,n),h=await s.image.nonMaxSuppressionWithScoreAsync(a,o,i,u,l,c);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:l}=Ta(t,e,n),c=m("padToMaxOutputSize",t,e,n),h=await s.image.nonMaxSuppressionPaddedAsync(a,o,i,u,l,c);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:l}=Ta(t,e,n);return[await s.image.nonMaxSuppressionAsync(a,o,i,u,l)]}case"Where":{const a=s.cast(m("condition",t,e,n),"bool"),o=[await s.whereAsync(a)];return a.dispose(),o}case"ListDiff":return s.setdiff1dAsync(m("x",t,e,n),m("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}};const YT=(t,e,n,r=He)=>{switch(t.op){case"LowerBound":{const s=m("sortedSequence",t,e,n),a=m("values",t,e,n);return[r.lowerBound(s,a)]}case"TopKV2":{const s=m("x",t,e,n),a=m("k",t,e,n),o=m("sorted",t,e,n),i=r.topk(s,a,o);return[i.values,i.indices]}case"UpperBound":{const s=m("sortedSequence",t,e,n),a=m("values",t,e,n);return[r.upperBound(s,a)]}case"Unique":{const s=m("x",t,e,n),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{const s=m("x",t,e,n),a=m("axis",t,e,n),o=r.unique(s,a);return[o.values,o.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const ZT=(t,e,n,r=He)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const s=m("default",t,e,n);return[Je(t.name,e,n)||s];case"Placeholder":return[Je(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=m("x",t,e,n);return[Xt(c)]}case"IdentityN":return m("x",t,e,n).map(c=>Xt(c));case"Snapshot":const a=m("x",t,e,n);return[Xt(a)];case"Shape":return[r.tensor1d(m("x",t,e,n).shape,"int32")];case"ShapeN":return m("x",t,e,n).map(c=>r.tensor1d(c.shape));case"Size":return[r.scalar(m("x",t,e,n).size,"int32")];case"Rank":return[r.scalar(m("x",t,e,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const o=m("x",t,e,n),i=m("data",t,e,n),u=m("message",t,e,n),l=m("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let c=0;c<i.length;c++)console.log(Array.prototype.slice.call(i[c].dataSync()).slice(0,l));return[o];default:throw TypeError(`Node type ${t.op} is not implemented`)}};class JT{constructor(e,n){this.keyDType=e,this.valueDType=n,this.handle=se(0),this.tensorMap=new Map,Lt(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return se(this.size(),"int32")}async import(e,n){this.checkKeyAndValueTensor(e,n);const r=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),Z(()=>{const s=yn(n),a=r.length,o=s.length;S(a===o,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${o} elements.`);for(let i=0;i<a;i++){const u=r[i],l=s[i];Lt(l),this.tensorMap.set(u,l)}return this.handle})}async find(e,n){this.checkKeyAndValueTensor(e,n);const r=await e.data();return Z(()=>{const s=[];for(let a=0;a<r.length;a++){const o=r[a],i=this.findWithDefault(o,n);s.push(i)}return Gt(s)})}findWithDefault(e,n){const r=this.tensorMap.get(e);return r??n}checkKeyAndValueTensor(e,n){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}const QT=async(t,e,n,r)=>{switch(t.op){case"HashTable":case"HashTableV2":{const s=m("keyDType",t,e,n),a=m("valueDType",t,e,n),o=new JT(s,a);return r.addHashTable(t.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const s=m("tableHandle",t,e,n,r),a=m("keys",t,e,n),o=m("values",t,e,n);return[await r.getHashTableById(s.id).import(a,o)]}case"LookupTableFind":case"LookupTableFindV2":{const s=m("tableHandle",t,e,n,r),a=m("keys",t,e,n),o=m("defaultValue",t,e,n);return[await r.getHashTableById(s.id).find(a,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=m("tableHandle",t,e,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const eE=(t,e,n,r=He)=>{switch(t.op){case"ResizeBilinear":{const s=m("images",t,e,n),a=m("size",t,e,n),o=m("alignCorners",t,e,n),i=m("halfPixelCenters",t,e,n);return[r.image.resizeBilinear(s,[a[0],a[1]],o,i)]}case"ResizeNearestNeighbor":{const s=m("images",t,e,n),a=m("size",t,e,n),o=m("alignCorners",t,e,n),i=m("halfPixelCenters",t,e,n);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],o,i)]}case"CropAndResize":{const s=m("image",t,e,n),a=m("boxes",t,e,n),o=m("boxInd",t,e,n),i=m("cropSize",t,e,n),u=m("method",t,e,n),l=m("extrapolationValue",t,e,n);return[r.image.cropAndResize(s,a,o,i,u,l)]}case"ImageProjectiveTransformV3":{const s=m("images",t,e,n),a=m("transforms",t,e,n),o=m("outputShape",t,e,n),i=m("fillValue",t,e,n),u=m("interpolation",t,e,n),l=m("fillMode",t,e,n);return[r.image.transform(s,a,u.toLowerCase(),l.toLowerCase(),i,o)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const tE=(t,e,n,r=He)=>{switch(t.op){case"Equal":return[r.equal(m("a",t,e,n),m("b",t,e,n))];case"NotEqual":return[r.notEqual(m("a",t,e,n),m("b",t,e,n))];case"Greater":return[r.greater(m("a",t,e,n),m("b",t,e,n))];case"GreaterEqual":return[r.greaterEqual(m("a",t,e,n),m("b",t,e,n))];case"Less":return[r.less(m("a",t,e,n),m("b",t,e,n))];case"LessEqual":return[r.lessEqual(m("a",t,e,n),m("b",t,e,n))];case"LogicalAnd":return[r.logicalAnd(m("a",t,e,n),m("b",t,e,n))];case"LogicalNot":return[r.logicalNot(m("a",t,e,n))];case"LogicalOr":return[r.logicalOr(m("a",t,e,n),m("b",t,e,n))];case"Select":case"SelectV2":return[r.where(m("condition",t,e,n),m("a",t,e,n),m("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const nE=(t,e,n,r=He)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(m("a",t,e,n),m("b",t,e,n),m("transposeA",t,e,n),m("transposeB",t,e,n))];case"Einsum":return[r.einsum(m("equation",t,e,n),...m("tensors",t,e,n))];case"Transpose":return[r.transpose(m("x",t,e,n),m("perm",t,e,n))];case"_FusedMatMul":const[s,a]=m("fusedOps",t,e,n),o=s==="biasadd",i=a==="prelu",u=m("numArgs",t,e,n),l=m("leakyreluAlpha",t,e,n);if(o){if(i&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,h]=m("args",t,e,n);return[r.fused.matMul({a:m("a",t,e,n),b:m("b",t,e,n),transposeA:m("transposeA",t,e,n),transposeB:m("transposeB",t,e,n),bias:c,activation:a,preluActivationWeights:h,leakyreluAlpha:l})];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const rE=(t,e,n,r=He)=>{switch(t.op){case"EuclideanNorm":return[r.euclideanNorm(m("x",t,e,n),m("axis",t,e,n),m("keepDims",t,e,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(m("x",t,e,n),m("mean",t,e,n),m("variance",t,e,n),m("offset",t,e,n),m("scale",t,e,n),m("epsilon",t,e,n))];case"FusedBatchNormV3":return[r.batchNorm(m("x",t,e,n),m("mean",t,e,n),m("variance",t,e,n),m("offset",t,e,n),m("scale",t,e,n),m("epsilon",t,e,n))];case"LRN":return[r.localResponseNormalization(m("x",t,e,n),m("radius",t,e,n),m("bias",t,e,n),m("alpha",t,e,n),m("beta",t,e,n))];case"Softmax":return[r.softmax(m("x",t,e,n))];case"LogSoftmax":return[r.logSoftmax(m("x",t,e,n))];case"SparseToDense":return[r.sparseToDense(m("sparseIndices",t,e,n),m("outputShape",t,e,n),m("sparseValues",t,e,n),m("defaultValue",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const sE=(t,e,n,r=He)=>{switch(t.op){case"Max":{const i=m("axis",t,e,n),u=m("keepDims",t,e,n);return[r.max(m("x",t,e,n),i,u)]}case"Mean":{const i=m("axis",t,e,n),u=m("keepDims",t,e,n);return[r.mean(m("x",t,e,n),i,u)]}case"Min":{const i=m("axis",t,e,n),u=m("keepDims",t,e,n);return[r.min(m("x",t,e,n),i,u)]}case"Sum":{const i=m("axis",t,e,n),u=m("keepDims",t,e,n);return[r.sum(m("x",t,e,n),i,u)]}case"All":{const i=m("axis",t,e,n),u=m("keepDims",t,e,n);return[r.all(m("x",t,e,n),i,u)]}case"Any":{const i=m("axis",t,e,n),u=m("keepDims",t,e,n);return[r.any(m("x",t,e,n),i,u)]}case"ArgMax":{const i=m("axis",t,e,n);return[r.argMax(m("x",t,e,n),i)]}case"ArgMin":{const i=m("axis",t,e,n);return[r.argMin(m("x",t,e,n),i)]}case"Prod":{const i=m("axis",t,e,n),u=m("keepDims",t,e,n);return[r.prod(m("x",t,e,n),i,u)]}case"Cumprod":{const i=m("axis",t,e,n),u=m("exclusive",t,e,n),l=m("reverse",t,e,n);return[r.cumprod(m("x",t,e,n),i,u,l)]}case"Cumsum":{const i=m("axis",t,e,n),u=m("exclusive",t,e,n),l=m("reverse",t,e,n);return[r.cumsum(m("x",t,e,n),i,u,l)]}case"Bincount":const s=m("x",t,e,n),a=m("weights",t,e,n),o=m("size",t,e,n);return[r.bincount(s,a,o)];case"DenseBincount":{const i=m("x",t,e,n),u=m("weights",t,e,n),l=m("size",t,e,n),c=m("binaryOutput",t,e,n);return[r.denseBincount(i,u,l,c)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const aE=(t,e,n,r=He)=>{switch(t.op){case"ConcatV2":case"Concat":{const s=m("n",t,e,n),a=m("axis",t,e,n);let o=m("tensors",t,e,n);return o=o.slice(0,s),[r.concat(o,a)]}case"Gather":{const s=m("x",t,e,n),a=m("indices",t,e,n);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{const s=m("axis",t,e,n),a=m("batchDims",t,e,n),o=m("x",t,e,n),i=m("indices",t,e,n);return[r.gather(o,r.cast(i,"int32"),s,a)]}case"Reverse":{const s=m("dims",t,e,n),a=[];for(let i=0;i<s.length;i++)s[i]&&a.push(i);const o=m("x",t,e,n);return[r.reverse(o,a)]}case"ReverseV2":{const s=m("axis",t,e,n),a=m("x",t,e,n);return[r.reverse(a,s)]}case"Slice":{const s=m("begin",t,e,n),a=m("size",t,e,n);return[r.slice(m("x",t,e,n),s,a)]}case"StridedSlice":{const s=m("begin",t,e,n),a=m("end",t,e,n),o=m("strides",t,e,n),i=m("beginMask",t,e,n),u=m("endMask",t,e,n),l=m("ellipsisMask",t,e,n),c=m("newAxisMask",t,e,n),h=m("shrinkAxisMask",t,e,n),p=m("x",t,e,n);return[r.stridedSlice(p,s,a,o,i,u,l,c,h)]}case"Pack":return Z(()=>{const s=m("axis",t,e,n),a=m("tensors",t,e,n),o=a[0].shape,i=r.squeeze(a[0]).shape,u=a.map(l=>{const c=jt(l.shape,o);if(!c&&!jt(r.squeeze(l).shape,i))throw new Error("the input tensors shape does not match");return c?l:r.reshape(l,o)});return[r.stack(u,s)]});case"Unpack":{const s=m("axis",t,e,n),a=m("tensor",t,e,n);return r.unstack(a,s)}case"Tile":{const s=m("reps",t,e,n);return[r.tile(m("x",t,e,n),s)]}case"Split":case"SplitV":{const s=m("axis",t,e,n),a=m("numOrSizeSplits",t,e,n),o=m("x",t,e,n);return r.split(o,a,s)}case"ScatterNd":{const s=m("indices",t,e,n),a=m("values",t,e,n),o=m("shape",t,e,n);return[r.scatterND(s,a,o)]}case"GatherNd":{const s=m("x",t,e,n),a=m("indices",t,e,n);return[r.gatherND(s,a)]}case"SparseToDense":{const s=m("sparseIndices",t,e,n),a=m("outputShape",t,e,n),o=m("sparseValues",t,e,n),i=m("defaultValue",t,e,n);return[r.sparseToDense(s,o,a,o.dtype===i.dtype?i:r.cast(i,o.dtype))]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const oE=(t,e,n,r=He)=>{switch(t.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:a,emptyRowIndicator:o,reverseIndexMap:i}=r.sparse.sparseFillEmptyRows(m("indices",t,e,n),m("values",t,e,n),m("denseShape",t,e,n),m("defaultValue",t,e,n));return[s,a,o,i]}case"SparseReshape":{const{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(m("inputIndices",t,e,n),m("inputShape",t,e,n),m("newShape",t,e,n));return[s,a]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(m("data",t,e,n),m("indices",t,e,n),m("segmentIds",t,e,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(m("data",t,e,n),m("indices",t,e,n),m("segmentIds",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const iE=(t,e,n,r=He)=>{switch(t.op){case"FFT":return[r.fft(m("x",t,e,n))];case"IFFT":return[r.ifft(m("x",t,e,n))];case"RFFT":return[r.rfft(m("x",t,e,n))];case"IRFFT":return[r.irfft(m("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const uE=(t,e,n,r=He)=>{switch(t.op){case"StringNGrams":{const{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(m("data",t,e,n),m("dataSplits",t,e,n),m("separator",t,e,n),m("nGramWidths",t,e,n),m("leftPad",t,e,n),m("rightPad",t,e,n),m("padWidth",t,e,n),m("preserveShortSequences",t,e,n));return[s,a]}case"StringSplit":{const{indices:s,values:a,shape:o}=r.string.stringSplit(m("input",t,e,n),m("delimiter",t,e,n),m("skipEmpty",t,e,n));return[s,a,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(m("input",t,e,n),m("numBuckets",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const lE=(t,e,n,r=He)=>{switch(t.op){case"Cast":return[r.cast(m("x",t,e,n),m("dtype",t,e,n))];case"ExpandDims":{const s=m("axis",t,e,n);return[r.expandDims(m("x",t,e,n),s)]}case"Squeeze":{const s=m("axis",t,e,n);return[r.squeeze(m("x",t,e,n),s)]}case"Reshape":return[r.reshape(m("x",t,e,n),m("shape",t,e,n))];case"MirrorPad":return[r.mirrorPad(m("x",t,e,n),m("padding",t,e,n),m("mode",t,e,n))];case"PadV2":case"Pad":return[r.pad(m("x",t,e,n),m("padding",t,e,n),m("constantValue",t,e,n))];case"SpaceToBatchND":{const s=m("blockShape",t,e,n),a=m("paddings",t,e,n);return[r.spaceToBatchND(m("x",t,e,n),s,a)]}case"BatchToSpaceND":{const s=m("blockShape",t,e,n),a=m("crops",t,e,n);return[r.batchToSpaceND(m("x",t,e,n),s,a)]}case"DepthToSpace":{const s=m("blockSize",t,e,n),a=m("dataFormat",t,e,n).toUpperCase();return[r.depthToSpace(m("x",t,e,n),s,a)]}case"BroadcastTo":return[r.broadcastTo(m("x",t,e,n),m("shape",t,e,n))];case"BroadcastArgs":return[r.broadcastArgs(m("s0",t,e,n),m("s1",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function mu(t,e,n,r,s=Z){const a=((o,i,u)=>{switch(o.category){case"arithmetic":return s(()=>MT(o,i,u));case"basic_math":return s(()=>zT(o,i,u));case"control":return HT(o,i,u);case"convolution":return s(()=>GT(o,i,u));case"creation":return s(()=>KT(o,i,u));case"dynamic":return XT(o,i,u);case"evaluation":return s(()=>YT(o,i,u));case"image":return s(()=>eE(o,i,u));case"graph":return s(()=>ZT(o,i,u));case"logical":return s(()=>tE(o,i,u));case"matrices":return s(()=>nE(o,i,u));case"normalization":return s(()=>rE(o,i,u));case"reduction":return s(()=>sE(o,i,u));case"slice_join":return s(()=>aE(o,i,u));case"sparse":return s(()=>oE(o,i,u));case"spectral":return s(()=>iE(o,i,u));case"string":return s(()=>uE(o,i,u));case"transformation":return s(()=>lE(o,i,u));case"hash_table":return QT(o,i,u,r);case"custom":const l=Kd(o.op);if(l&&l.customExecutor)return l.customExecutor(new LT(o,i,u));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return In(a)?a.then(o=>[].concat(o)):[].concat(a)}class gu{constructor(e={},n={},r={},s={}){this.weightMap=e,this.tensorArrayMap=n,this.tensorListMap=r,this.functionMap=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,n){return{id:e,frameName:n,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let n=0;n<this.contexts.length-1;n++){const r=this.contexts.slice(0,this.contexts.length-n);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(e);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(e)}}function yu(t,e,n,r){const s=new Set,a=[];let o=null,i=null;const u=new Set,l=Object.keys(t).map(p=>st(p)[0]);let c=[];r!=null&&(c=r.map(p=>st(p.name)[0]));const h=[...e];for(;h.length>0;){const p=h.pop();if((Zd(p)||dE(p)||mE(p))&&o==null&&(o=p,i=o.children.map(d=>d.name).filter(d=>s.has(d))),s.add(p.name),n[p.name]==null&&l.indexOf(p.name)===-1&&c.indexOf(p.name)===-1){if(p.inputs.length===0){a.push(p.name);continue}p.inputs.forEach(d=>{u.has(d.name)||(u.add(d.name),h.push(d))})}}return{inputs:t,outputs:e,usedNodes:s,missingInputs:a,dynamicNode:o,syncInputs:i}}function cE(t,e,n){const{usedNodes:r,inputs:s}=n,a=[],o=Object.keys(s).map(c=>st(c)[0]).map(c=>t.nodes[c]),i=t.initNodes;o.forEach(c=>{r.has(c.name)&&a.push(c)}),t.weights.forEach(c=>{r.has(c.name)&&a.push(c)}),i?.forEach(c=>{r.has(c.name)&&a.push(c)});const u=new Set,l=[];for(;a.length>0;){const c=a.pop();u.add(c.name),e[c.name]||l.push(c),c.children.forEach(h=>{!u.has(h.name)&&r.has(h.name)&&h.inputs.every(p=>u.has(p.name))&&a.push(h)})}return l}const hE=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],fE=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],pE=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Zd(t){return hE.indexOf(t.op)>=0}function dE(t){return fE.indexOf(t.op)>=0}function mE(t){return pE.indexOf(t.op)>=0}class Cs{constructor(e,n){this.graph=e,this.parent=n,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new Cs(e.functions[r],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const n=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...n),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const n=e.signatureKey||e.name;return e.defaultOutput?`${n}:${e.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((e,n)=>(e[n]=this._functions[n].signature,e),{})}getCompilationKey(e,n){const r=e.map(a=>a.name).sort(),s=n.map(a=>a.name).sort();return r.join(this.SEPERATOR)+"--"+s.join(this.SEPERATOR)}compile(e,n){const r=yu(e,n,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:a,syncInputs:o}=r;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(s.length>0){const i=n.map(l=>l.name),u=Object.keys(e);throw new Error(`Cannot compute the outputs [${i}] from the provided inputs [${u}]. Missing the following inputs: [${s}]`)}return cE(this.graph,this.weightMap,r)}execute(e,n){e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n);const s=r.map(h=>this.graph.nodes[st(h)[0]]),a=n.map(h=>st(h)[0]);let o=a.map(h=>this.graph.nodes[h]);this.resetIntermediateTensors(),o.length===0&&(o=this._outputs);const i=this.getCompilationKey(s,o);let u=this.compiledMap.get(i);u==null&&(u=this.compile(e,o),this.compiledMap.set(i,u));const l={},c={};return Z(()=>{const h=new gu(this.weightMap,l,c,this.functionExecutorMap),p=Object.assign({},this.weightMap);Object.keys(e).forEach(v=>{const[N,x]=st(v),F=[];F[x]=e[v],p[N]=F});const d=this.getFrozenTensorIds(p),b={};for(let v=0;v<u.length;v++){const N=u[v];if(!p[N.name]){const x=mu(N,p,h,this._resourceManager);if(In(x))throw new Error(`The execution of the op '${N.op}' returned a promise. Please use model.executeAsync() instead.`);p[N.name]=x,this.checkTensorForDisposal(N.name,N,p,h,d,a,b)}}return this.parent==null&&h.dispose(d),n.map(v=>Je(v,p,h))})}getFrozenTensorIds(e){const n=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(n)}checkTensorForDisposal(e,n,r,s,a,o,i){n.category==="control"||o.indexOf(e)!==-1||(r[e].forEach(u=>{u!=null&&(i[u.id]=(i[u.id]||0)+n.children.length)}),n.inputs.forEach(u=>{if(u.category!=="control"){const l=JN(u.name,r,s);l?.forEach(c=>{if(c&&!c.kept&&!a.has(c.id)){const h=i[c.id];if(h===1){if(!this.keepTensorForDebug)c.dispose();else{const[p,d]=Bt(n.name,s);this.intermediateTensors[p]?this.intermediateTensors[p][d]=c:(this.intermediateTensors[p]=[],this.intermediateTensors[p][d]=c)}delete i[c.id]}else h!=null&&i[c.id]--}})}}))}async executeAsync(e,n){return this._executeAsync(e,n)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach(e=>this.intermediateTensors[e].forEach(n=>n.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach(e=>{this.tensorsMap[e].forEach(r=>{r&&!r.kept&&!r.isDisposed&&!this.keepIds.has(r.id)&&r.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors)this.intermediateTensors[e].forEach(n=>n.dispose()),delete this.intermediateTensors[e]}async _executeAsync(e,n,r=!1,s={},a={}){r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepTensorForDebug=re().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){console.warn(c.message)}this.resetIntermediateTensors();const o=new gu(this.weightMap,s,a,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,o,n,r);const i=n.map(c=>Je(c,this.tensorsMap,o)),u=i.map(c=>c.id),l=Object.keys(e).map(c=>e[c].id);return this.keepIds=new Set([...u,...l,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&o.dispose(this.keepIds),i}async executeFunctionAsync(e,n,r){const s=e.reduce((a,o,i)=>(a[this.inputs[i].name]=o,a),{});return this._executeAsync(s,this.outputNodes,!0,n,r)}async executeWithControlFlow(e,n,r,s){const a=Object.keys(e),o=a.map(_=>this.graph.nodes[st(_)[0]]),i=r.map(_=>st(_)[0]);let u=i.map(_=>this.graph.nodes[_]);u.length===0&&(u=this._outputs);const{usedNodes:l,missingInputs:c,dynamicNode:h,syncInputs:p}=yu(e,u,this.weightMap,this._initNodes),d=[...o,...this.graph.weights,...this._initNodes||[]].map(_=>({node:_,contexts:n.currentContext})),b=Object.assign({},this.weightMap);Object.keys(e).forEach(_=>{const[$,A]=st(_),C=[];C[A]=e[_],b[$]=C});const v={},N=this.getFrozenTensorIds(b),x={};for(;d.length>0;){const _=this.processStack(o,d,n,b,x,N,i,v,l);await Promise.all(_)}h==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const F=u.filter(_=>!Zd(_)&&!Je(_.name,b,n)).map(_=>_.name);if(F.length>0){let _="";throw h!=null&&(_=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${F}] from the provided inputs [${a}]. Consider providing the following inputs: [${c}]. ${_}`)}return b}processStack(e,n,r,s,a,o,i,u,l){const c=[];for(;n.length>0;){const h=n.pop();r.currentContext=h.contexts;let p="";if(h.node.op==="Enter"&&m("isConstant",h.node,s,r)&&([p]=Bt(h.node.name,r)),s[h.node.name]==null){const d=mu(h.node,s,r,this._resourceManager);p||([p]=Bt(h.node.name,r));const b=r.currentContext;In(d)?c.push(d.then(v=>(s[p]=v,r.currentContext=b,this.checkTensorForDisposal(p,h.node,s,r,o,i,u),this.processChildNodes(h.node,n,r,s,a,l),v))):(s[p]=d,this.checkTensorForDisposal(p,h.node,s,r,o,i,u),this.processChildNodes(h.node,n,r,s,a,l))}else this.processChildNodes(h.node,n,r,s,a,l)}return c}processChildNodes(e,n,r,s,a,o){e.children.forEach(i=>{const[u]=Bt(i.name,r);a[u]||!o.has(i.name)||(i.op==="Merge"?i.inputNames.some(l=>!!Je(l,s,r))&&(a[u]=!0,n.push({contexts:r.currentContext,node:i})):i.inputNames.every(l=>!!Je(l,s,r))&&(a[u]=!0,n.push({contexts:r.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(n=>n.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(n=>{const r=e[n],[s]=st(n),a=this.graph.nodes[s];if(a.attrParams.shape&&a.attrParams.shape.value){const o=a.attrParams.shape.value,i=o.length===r.shape.length&&r.shape.every((u,l)=>o[l]===-1||o[l]===u);S(i,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${o}], but was [${r.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&S(r.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){const n={};for(const r in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[r]!=null){const s=this._signature.inputs[r];n[s.name]=e[r]}else n[r]=e[r];return n}checkInputs(e){const n=Object.keys(e).filter(r=>{const[s]=st(r);return this.graph.nodes[s]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(e){return e.map(n=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[n]!=null?this._signature.outputs[n].name:n,{})}checkOutputs(e){e.forEach(n=>{const[r]=st(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}}class gE{constructor(e={},n={}){this.hashTableNameToHandle=e,this.hashTableMap=n}addHashTable(e,n){this.hashTableNameToHandle[e]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const yE="?tfjs-format=file",bE="model.json";class wE{constructor(e,n={},r=Io){this.modelUrl=e,this.loadOptions=n,this.version="n/a",this.io=r,n==null&&(this.loadOptions={}),this.resourceManager=new gE}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const n=this.io.getLoadHandlers(e,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[e]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return In(e)?e.then(n=>this.loadSync(n)):this.loadSync(e)}loadSync(e){this.artifacts=e;const n=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const a=this.artifacts.userDefinedMetadata;a.signature!=null&&(r=a.signature),a.structuredOutputKeys!=null&&(this.structuredOutputKeys=a.structuredOutputKeys)}this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`;const s=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Cs(hu.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const a=hu.Instance.transformGraph(e.modelInitializer);this.initializer=new Cs(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,n){if(typeof e=="string"){const r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,n){const r=this.execute(e,this.outputNodes);if(this.structuredOutputKeys){const s=r instanceof be?[r]:r,a={};return s.forEach((o,i)=>a[this.structuredOutputKeys[i]]=o),a}return r}normalizeInputs(e){if(!(e instanceof be)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((n,r,s)=>(n[r]=e[s],n),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,n){e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const r=this.executor.execute(e,n);return r.length>1?r:r[0]}async executeAsync(e,n){e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const r=await this.executor.executeAsync(e,n);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((n,r)=>(n[r]=[e[r]],n),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function Ei(t,e={},n=Io){if(t==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof t=="string"&&(t=vE(t));const r=new wE(t,e,n);return await r.load(),r}function vE(t){return t.endsWith("/")||(t=t+"/"),`${t}${bE}${yE}`}(function(){var t;function e(f){var g=0;return function(){return g<f.length?{done:!1,value:f[g++]}:{done:!0}}}var n=typeof Object.defineProperties=="function"?Object.defineProperty:function(f,g,y){return f==Array.prototype||f==Object.prototype||(f[g]=y.value),f};function r(f){f=[typeof globalThis=="object"&&globalThis,f,typeof window=="object"&&window,typeof self=="object"&&self,typeof Mt=="object"&&Mt];for(var g=0;g<f.length;++g){var y=f[g];if(y&&y.Math==Math)return y}throw Error("Cannot find global object")}var s=r(this);function a(f,g){if(g)e:{var y=s;f=f.split(".");for(var T=0;T<f.length-1;T++){var I=f[T];if(!(I in y))break e;y=y[I]}f=f[f.length-1],T=y[f],g=g(T),g!=T&&g!=null&&n(y,f,{configurable:!0,writable:!0,value:g})}}a("Symbol",function(f){function g(L){if(this instanceof g)throw new TypeError("Symbol is not a constructor");return new y(T+(L||"")+"_"+I++,L)}function y(L,O){this.g=L,n(this,"description",{configurable:!0,writable:!0,value:O})}if(f)return f;y.prototype.toString=function(){return this.g};var T="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",I=0;return g}),a("Symbol.iterator",function(f){if(f)return f;f=Symbol("Symbol.iterator");for(var g="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),y=0;y<g.length;y++){var T=s[g[y]];typeof T=="function"&&typeof T.prototype[f]!="function"&&n(T.prototype,f,{configurable:!0,writable:!0,value:function(){return o(e(this))}})}return f});function o(f){return f={next:f},f[Symbol.iterator]=function(){return this},f}function i(f){var g=typeof Symbol<"u"&&Symbol.iterator&&f[Symbol.iterator];return g?g.call(f):{next:e(f)}}function u(f){if(!(f instanceof Array)){f=i(f);for(var g,y=[];!(g=f.next()).done;)y.push(g.value);f=y}return f}var l=typeof Object.create=="function"?Object.create:function(f){function g(){}return g.prototype=f,new g},c;if(typeof Object.setPrototypeOf=="function")c=Object.setPrototypeOf;else{var h;e:{var p={a:!0},d={};try{d.__proto__=p,h=d.a;break e}catch{}h=!1}c=h?function(f,g){if(f.__proto__=g,f.__proto__!==g)throw new TypeError(f+" is not extensible");return f}:null}var b=c;function v(f,g){if(f.prototype=l(g.prototype),f.prototype.constructor=f,b)b(f,g);else for(var y in g)if(y!="prototype")if(Object.defineProperties){var T=Object.getOwnPropertyDescriptor(g,y);T&&Object.defineProperty(f,y,T)}else f[y]=g[y];f.ea=g.prototype}function N(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.s=this.m=0,this.j=null}function x(f){if(f.l)throw new TypeError("Generator is already running");f.l=!0}N.prototype.o=function(f){this.h=f};function F(f,g){f.j={U:g,V:!0},f.g=f.m||f.s}N.prototype.return=function(f){this.j={return:f},this.g=this.s};function _(f,g,y){return f.g=y,{value:g}}function $(f){this.g=new N,this.h=f}function A(f,g){x(f.g);var y=f.g.i;return y?C(f,"return"in y?y.return:function(T){return{value:T,done:!0}},g,f.g.return):(f.g.return(g),M(f))}function C(f,g,y,T){try{var I=g.call(f.g.i,y);if(!(I instanceof Object))throw new TypeError("Iterator result "+I+" is not an object");if(!I.done)return f.g.l=!1,I;var L=I.value}catch(O){return f.g.i=null,F(f.g,O),M(f)}return f.g.i=null,T.call(f.g,L),M(f)}function M(f){for(;f.g.g;)try{var g=f.h(f.g);if(g)return f.g.l=!1,{value:g.value,done:!1}}catch(y){f.g.h=void 0,F(f.g,y)}if(f.g.l=!1,f.g.j){if(g=f.g.j,f.g.j=null,g.V)throw g.U;return{value:g.return,done:!0}}return{value:void 0,done:!0}}function P(f){this.next=function(g){return x(f.g),f.g.i?g=C(f,f.g.i.next,g,f.g.o):(f.g.o(g),g=M(f)),g},this.throw=function(g){return x(f.g),f.g.i?g=C(f,f.g.i.throw,g,f.g.o):(F(f.g,g),g=M(f)),g},this.return=function(g){return A(f,g)},this[Symbol.iterator]=function(){return this}}function D(f,g){return g=new P(new $(g)),b&&f.prototype&&b(g,f.prototype),g}function V(f,g){f instanceof String&&(f+="");var y=0,T=!1,I={next:function(){if(!T&&y<f.length){var L=y++;return{value:g(L,f[L]),done:!1}}return T=!0,{done:!0,value:void 0}}};return I[Symbol.iterator]=function(){return I},I}var z=typeof Object.assign=="function"?Object.assign:function(f,g){for(var y=1;y<arguments.length;y++){var T=arguments[y];if(T)for(var I in T)Object.prototype.hasOwnProperty.call(T,I)&&(f[I]=T[I])}return f};a("Object.assign",function(f){return f||z}),a("Promise",function(f){function g(O){this.h=0,this.i=void 0,this.g=[],this.o=!1;var R=this.j();try{O(R.resolve,R.reject)}catch(j){R.reject(j)}}function y(){this.g=null}function T(O){return O instanceof g?O:new g(function(R){R(O)})}if(f)return f;y.prototype.h=function(O){if(this.g==null){this.g=[];var R=this;this.i(function(){R.l()})}this.g.push(O)};var I=s.setTimeout;y.prototype.i=function(O){I(O,0)},y.prototype.l=function(){for(;this.g&&this.g.length;){var O=this.g;this.g=[];for(var R=0;R<O.length;++R){var j=O[R];O[R]=null;try{j()}catch(H){this.j(H)}}}this.g=null},y.prototype.j=function(O){this.i(function(){throw O})},g.prototype.j=function(){function O(H){return function(Q){j||(j=!0,H.call(R,Q))}}var R=this,j=!1;return{resolve:O(this.C),reject:O(this.l)}},g.prototype.C=function(O){if(O===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(O instanceof g)this.F(O);else{e:switch(typeof O){case"object":var R=O!=null;break e;case"function":R=!0;break e;default:R=!1}R?this.u(O):this.m(O)}},g.prototype.u=function(O){var R=void 0;try{R=O.then}catch(j){this.l(j);return}typeof R=="function"?this.G(R,O):this.m(O)},g.prototype.l=function(O){this.s(2,O)},g.prototype.m=function(O){this.s(1,O)},g.prototype.s=function(O,R){if(this.h!=0)throw Error("Cannot settle("+O+", "+R+"): Promise already settled in state"+this.h);this.h=O,this.i=R,this.h===2&&this.D(),this.A()},g.prototype.D=function(){var O=this;I(function(){if(O.B()){var R=s.console;typeof R<"u"&&R.error(O.i)}},1)},g.prototype.B=function(){if(this.o)return!1;var O=s.CustomEvent,R=s.Event,j=s.dispatchEvent;return typeof j>"u"?!0:(typeof O=="function"?O=new O("unhandledrejection",{cancelable:!0}):typeof R=="function"?O=new R("unhandledrejection",{cancelable:!0}):(O=s.document.createEvent("CustomEvent"),O.initCustomEvent("unhandledrejection",!1,!0,O)),O.promise=this,O.reason=this.i,j(O))},g.prototype.A=function(){if(this.g!=null){for(var O=0;O<this.g.length;++O)L.h(this.g[O]);this.g=null}};var L=new y;return g.prototype.F=function(O){var R=this.j();O.J(R.resolve,R.reject)},g.prototype.G=function(O,R){var j=this.j();try{O.call(R,j.resolve,j.reject)}catch(H){j.reject(H)}},g.prototype.then=function(O,R){function j(le,te){return typeof le=="function"?function(K){try{H(le(K))}catch(ee){Q(ee)}}:te}var H,Q,Se=new g(function(le,te){H=le,Q=te});return this.J(j(O,H),j(R,Q)),Se},g.prototype.catch=function(O){return this.then(void 0,O)},g.prototype.J=function(O,R){function j(){switch(H.h){case 1:O(H.i);break;case 2:R(H.i);break;default:throw Error("Unexpected state: "+H.h)}}var H=this;this.g==null?L.h(j):this.g.push(j),this.o=!0},g.resolve=T,g.reject=function(O){return new g(function(R,j){j(O)})},g.race=function(O){return new g(function(R,j){for(var H=i(O),Q=H.next();!Q.done;Q=H.next())T(Q.value).J(R,j)})},g.all=function(O){var R=i(O),j=R.next();return j.done?T([]):new g(function(H,Q){function Se(K){return function(ee){le[K]=ee,te--,te==0&&H(le)}}var le=[],te=0;do le.push(void 0),te++,T(j.value).J(Se(le.length-1),Q),j=R.next();while(!j.done)})},g}),a("Object.is",function(f){return f||function(g,y){return g===y?g!==0||1/g===1/y:g!==g&&y!==y}}),a("Array.prototype.includes",function(f){return f||function(g,y){var T=this;T instanceof String&&(T=String(T));var I=T.length;for(y=y||0,0>y&&(y=Math.max(y+I,0));y<I;y++){var L=T[y];if(L===g||Object.is(L,g))return!0}return!1}}),a("String.prototype.includes",function(f){return f||function(g,y){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(g instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(g,y||0)!==-1}}),a("Array.prototype.keys",function(f){return f||function(){return V(this,function(g){return g})}});var q=this||self;function G(f,g){f=f.split(".");var y=q;f[0]in y||typeof y.execScript>"u"||y.execScript("var "+f[0]);for(var T;f.length&&(T=f.shift());)f.length||g===void 0?y[T]&&y[T]!==Object.prototype[T]?y=y[T]:y=y[T]={}:y[T]=g}function X(f,g){return g=String.fromCharCode.apply(null,g),f==null?g:f+g}var oe,pe=typeof TextDecoder<"u",Te,De=typeof TextEncoder<"u";function Be(f){if(De)f=(Te||(Te=new TextEncoder)).encode(f);else{var g=void 0;g=g===void 0?!1:g;for(var y=0,T=new Uint8Array(3*f.length),I=0;I<f.length;I++){var L=f.charCodeAt(I);if(128>L)T[y++]=L;else{if(2048>L)T[y++]=L>>6|192;else{if(55296<=L&&57343>=L){if(56319>=L&&I<f.length){var O=f.charCodeAt(++I);if(56320<=O&&57343>=O){L=1024*(L-55296)+O-56320+65536,T[y++]=L>>18|240,T[y++]=L>>12&63|128,T[y++]=L>>6&63|128,T[y++]=L&63|128;continue}else I--}if(g)throw Error("Found an unpaired surrogate");L=65533}T[y++]=L>>12|224,T[y++]=L>>6&63|128}T[y++]=L&63|128}}f=T.subarray(0,y)}return f}var Ue={},nt=null;function Et(f,g){g===void 0&&(g=0),_t(),g=Ue[g];for(var y=Array(Math.floor(f.length/3)),T=g[64]||"",I=0,L=0;I<f.length-2;I+=3){var O=f[I],R=f[I+1],j=f[I+2],H=g[O>>2];O=g[(O&3)<<4|R>>4],R=g[(R&15)<<2|j>>6],j=g[j&63],y[L++]=H+O+R+j}switch(H=0,j=T,f.length-I){case 2:H=f[I+1],j=g[(H&15)<<2]||T;case 1:f=f[I],y[L]=g[f>>2]+g[(f&3)<<4|H>>4]+j+T}return y.join("")}function ct(f){var g=f.length,y=3*g/4;y%3?y=Math.floor(y):"=.".indexOf(f[g-1])!=-1&&(y="=.".indexOf(f[g-2])!=-1?y-2:y-1);var T=new Uint8Array(y),I=0;return kt(f,function(L){T[I++]=L}),T.subarray(0,I)}function kt(f,g){function y(j){for(;T<f.length;){var H=f.charAt(T++),Q=nt[H];if(Q!=null)return Q;if(!/^[\s\xa0]*$/.test(H))throw Error("Unknown base64 encoding at char: "+H)}return j}_t();for(var T=0;;){var I=y(-1),L=y(0),O=y(64),R=y(64);if(R===64&&I===-1)break;g(I<<2|L>>4),O!=64&&(g(L<<4&240|O>>2),R!=64&&g(O<<6&192|R))}}function _t(){if(!nt){nt={};for(var f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),g=["+/=","+/","-_=","-_.","-_"],y=0;5>y;y++){var T=f.concat(g[y].split(""));Ue[y]=T;for(var I=0;I<T.length;I++){var L=T[I];nt[L]===void 0&&(nt[L]=I)}}}}var xt=typeof Uint8Array.prototype.slice=="function",Ct;function tn(f,g,y){return g===y?Ct||(Ct=new Uint8Array(0)):xt?f.slice(g,y):new Uint8Array(f.subarray(g,y))}var rt=0,$t=0;function ns(f,g){g=g===void 0?{}:g,g=g.v===void 0?!1:g.v,this.h=null,this.g=this.i=this.j=0,this.l=!1,this.v=g,f&&xi(this,f)}function xi(f,g){g=g.constructor===Uint8Array?g:g.constructor===ArrayBuffer?new Uint8Array(g):g.constructor===Array?new Uint8Array(g):g.constructor===String?ct(g):g instanceof Uint8Array?new Uint8Array(g.buffer,g.byteOffset,g.byteLength):new Uint8Array(0),f.h=g,f.j=0,f.i=f.h.length,f.g=f.j}ns.prototype.reset=function(){this.g=this.j};function dr(f){var g=f.h,y=g[f.g],T=y&127;return 128>y?(f.g+=1,T):(y=g[f.g+1],T|=(y&127)<<7,128>y?(f.g+=2,T):(y=g[f.g+2],T|=(y&127)<<14,128>y?(f.g+=3,T):(y=g[f.g+3],T|=(y&127)<<21,128>y?(f.g+=4,T):(y=g[f.g+4],T|=(y&15)<<28,128>y?(f.g+=5,T>>>0):(f.g+=5,128<=g[f.g++]&&128<=g[f.g++]&&128<=g[f.g++]&&128<=g[f.g++]&&f.g++,T)))))}function At(f){var g=f.h[f.g],y=f.h[f.g+1],T=f.h[f.g+2],I=f.h[f.g+3];return f.g+=4,y=(g<<0|y<<8|T<<16|I<<24)>>>0,f=2*(y>>31)+1,g=y>>>23&255,y&=8388607,g==255?y?NaN:1/0*f:g==0?f*Math.pow(2,-149)*y:f*Math.pow(2,g-150)*(y+Math.pow(2,23))}var $i=[];function rs(){this.g=new Uint8Array(64),this.h=0}rs.prototype.push=function(f){if(!(this.h+1<this.g.length)){var g=this.g;this.g=new Uint8Array(Math.ceil(1+2*this.g.length)),this.g.set(g)}this.g[this.h++]=f},rs.prototype.length=function(){return this.h},rs.prototype.end=function(){var f=this.g,g=this.h;return this.h=0,tn(f,0,g)};function nn(f,g){for(;127<g;)f.push(g&127|128),g>>>=7;f.push(g)}function ss(f){var g={},y=g.N===void 0?!1:g.N;this.o={v:g.v===void 0?!1:g.v},this.N=y,g=this.o,$i.length?(y=$i.pop(),g&&(y.v=g.v),f&&xi(y,f),f=y):f=new ns(f,g),this.g=f,this.m=this.g.g,this.h=this.i=this.l=-1,this.j=!1}ss.prototype.reset=function(){this.g.reset(),this.h=this.l=-1};function Un(f){var g=f.g;if((g=g.g==g.i)||(g=f.j)||(g=f.g,g=g.l||0>g.g||g.g>g.i),g)return!1;f.m=f.g.g,g=dr(f.g);var y=g&7;return y!=0&&y!=5&&y!=1&&y!=2&&y!=3&&y!=4?(f.j=!0,!1):(f.i=g,f.l=g>>>3,f.h=y,!0)}function Wn(f){switch(f.h){case 0:if(f.h!=0)Wn(f);else{for(f=f.g;f.h[f.g]&128;)f.g++;f.g++}break;case 1:f.h!=1?Wn(f):(f=f.g,f.g+=8);break;case 2:if(f.h!=2)Wn(f);else{var g=dr(f.g);f=f.g,f.g+=g}break;case 5:f.h!=5?Wn(f):(f=f.g,f.g+=4);break;case 3:g=f.l;do{if(!Un(f)){f.j=!0;break}if(f.h==4){f.l!=g&&(f.j=!0);break}Wn(f)}while(1);break;default:f.j=!0}}function Ai(f,g,y){var T=f.g.i,I=dr(f.g);return I=f.g.g+I,f.g.i=I,y(g,f),f.g.g=I,f.g.i=T,g}function Ii(f){var g=dr(f.g);f=f.g;var y=f.g;f.g+=g,f=f.h;var T;if(pe)(T=oe)||(T=oe=new TextDecoder("utf-8",{fatal:!1})),T=T.decode(f.subarray(y,y+g));else{g=y+g;for(var I=[],L=null,O,R,j;y<g;)O=f[y++],128>O?I.push(O):224>O?y>=g?I.push(65533):(R=f[y++],194>O||(R&192)!==128?(y--,I.push(65533)):I.push((O&31)<<6|R&63)):240>O?y>=g-1?I.push(65533):(R=f[y++],(R&192)!==128||O===224&&160>R||O===237&&160<=R||((T=f[y++])&192)!==128?(y--,I.push(65533)):I.push((O&15)<<12|(R&63)<<6|T&63)):244>=O?y>=g-2?I.push(65533):(R=f[y++],(R&192)!==128||(O<<28)+(R-144)>>30!==0||((T=f[y++])&192)!==128||((j=f[y++])&192)!==128?(y--,I.push(65533)):(O=(O&7)<<18|(R&63)<<12|(T&63)<<6|j&63,O-=65536,I.push((O>>10&1023)+55296,(O&1023)+56320))):I.push(65533),8192<=I.length&&(L=X(L,I),I.length=0);T=X(L,I)}return T}function ua(){this.h=[],this.i=0,this.g=new rs}function qn(f,g){g.length!==0&&(f.h.push(g),f.i+=g.length)}function la(f){var g=f.i+f.g.length();if(g===0)return new Uint8Array(0);g=new Uint8Array(g);for(var y=f.h,T=y.length,I=0,L=0;L<T;L++){var O=y[L];O.length!==0&&(g.set(O,I),I+=O.length)}return y=f.g,T=y.h,T!==0&&(g.set(y.g.subarray(0,T),I),y.h=0),f.h=[g],g}function It(f,g,y){if(y!=null){nn(f.g,8*g+5),f=f.g;var T=y;T=(y=0>T?1:0)?-T:T,T===0?0<1/T?rt=$t=0:($t=0,rt=2147483648):isNaN(T)?($t=0,rt=2147483647):34028234663852886e22<T?($t=0,rt=(y<<31|2139095040)>>>0):11754943508222875e-54>T?(T=Math.round(T/Math.pow(2,-149)),$t=0,rt=(y<<31|T)>>>0):(g=Math.floor(Math.log(T)/Math.LN2),T*=Math.pow(2,-g),T=Math.round(8388608*T)&8388607,$t=0,rt=(y<<31|g+127<<23|T)>>>0),y=rt,f.push(y>>>0&255),f.push(y>>>8&255),f.push(y>>>16&255),f.push(y>>>24&255)}}var Nm=typeof Uint8Array=="function";function Oi(f,g,y){if(f!=null)return typeof f=="object"?Nm&&f instanceof Uint8Array?y(f):Di(f,g,y):g(f)}function Di(f,g,y){if(Array.isArray(f)){for(var T=Array(f.length),I=0;I<f.length;I++)T[I]=Oi(f[I],g,y);return Array.isArray(f)&&f.W&&mr(T),T}T={};for(I in f)T[I]=Oi(f[I],g,y);return T}function Tm(f){return typeof f=="number"?isFinite(f)?f:String(f):f}var Em={W:{value:!0,configurable:!0}};function mr(f){return Array.isArray(f)&&!Object.isFrozen(f)&&Object.defineProperties(f,Em),f}var Fi;function ft(f,g,y){var T=Fi;Fi=null,f||(f=T),T=this.constructor.ca,f||(f=T?[T]:[]),this.j=T?0:-1,this.i=null,this.g=f;e:{if(T=this.g.length,f=T-1,T&&(T=this.g[f],T!==null&&typeof T=="object"&&T.constructor===Object)){this.l=f-this.j,this.h=T;break e}g!==void 0&&-1<g?(this.l=Math.max(g,f+1-this.j),this.h=null):this.l=Number.MAX_VALUE}if(y)for(g=0;g<y.length;g++)f=y[g],f<this.l?(f+=this.j,(T=this.g[f])?mr(T):this.g[f]=as):(Ci(this),(T=this.h[f])?mr(T):this.h[f]=as)}var as=Object.freeze(mr([]));function Ci(f){var g=f.l+f.j;f.g[g]||(f.h=f.g[g]={})}function Re(f,g,y){return g===-1?null:(y===void 0?0:y)||g>=f.l?f.h?f.h[g]:void 0:f.g[g+f.j]}function Pi(f){var g=g===void 0?!1:g,y=Re(f,1,g);return y==null&&(y=as),y===as&&(y=mr([]),ve(f,1,y,g)),y}function Pt(f,g,y){return f=Re(f,g),f=f==null?f:+f,f??(y===void 0?0:y)}function ve(f,g,y,T){(T===void 0?0:T)||g>=f.l?(Ci(f),f.h[g]=y):f.g[g+f.j]=y}function ca(f,g){f.i||(f.i={});var y=f.i[1];if(!y){var T=Pi(f);y=[];for(var I=0;I<T.length;I++)y[I]=new g(T[I]);f.i[1]=y}return y}function Ri(f,g,y,T){var I=ca(f,y);g=g||new y,f=Pi(f),T!=null?(I.splice(T,0,g),f.splice(T,0,Hn(g))):(I.push(g),f.push(Hn(g)))}ft.prototype.toJSON=function(){var f=Hn(this);return Di(f,Tm,Et)};function Hn(f,g){if(f.i)for(var y in f.i){var T=f.i[y];if(Array.isArray(T))for(var I=0;I<T.length;I++)T[I]&&Hn(T[I]);else T&&Hn(T)}return f.g}ft.prototype.toString=function(){return Hn(this).toString()};function Bi(f,g){return f=Re(f,g),f??0}function Li(f,g){return f=Re(f,g),f??""}function ha(f,g){if(f=f.m){qn(g,g.g.end());for(var y=0;y<f.length;y++)qn(g,f[y])}}function gr(f,g){if(g.h==4)return!1;var y=g.m;return Wn(g),g.N||(g=tn(g.g.h,y,g.g.g),(y=f.m)?y.push(g):f.m=[g]),!0}function Ge(f,g){var y=void 0;return new(y||(y=Promise))(function(T,I){function L(j){try{R(g.next(j))}catch(H){I(H)}}function O(j){try{R(g.throw(j))}catch(H){I(H)}}function R(j){j.done?T(j.value):new y(function(H){H(j.value)}).then(L,O)}R((g=g.apply(f,void 0)).next())})}function yr(f){ft.call(this,f)}v(yr,ft);function km(f,g){for(;Un(g);)switch(g.i){case 8:var y=dr(g.g);ve(f,1,y);break;case 21:y=At(g.g),ve(f,2,y);break;case 26:y=Ii(g),ve(f,3,y);break;case 34:y=Ii(g),ve(f,4,y);break;default:if(!gr(f,g))return f}return f}function fa(f){ft.call(this,f,-1,_m)}v(fa,ft),fa.prototype.addClassification=function(f,g){Ri(this,f,yr,g)};var _m=[1];function br(f){ft.call(this,f)}v(br,ft);function xm(f,g){for(;Un(g);)switch(g.i){case 13:var y=At(g.g);ve(f,1,y);break;case 21:y=At(g.g),ve(f,2,y);break;case 29:y=At(g.g),ve(f,3,y);break;case 37:y=At(g.g),ve(f,4,y);break;case 45:y=At(g.g),ve(f,5,y);break;default:if(!gr(f,g))return f}return f}function Mi(f){ft.call(this,f,-1,$m)}v(Mi,ft);var $m=[1];function pa(f){ft.call(this,f)}v(pa,ft);function zi(f,g,y){if(y=f.createShader(y===0?f.VERTEX_SHADER:f.FRAGMENT_SHADER),f.shaderSource(y,g),f.compileShader(y),!f.getShaderParameter(y,f.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+f.getShaderInfoLog(y));return y}function Am(f){return ca(f,yr).map(function(g){return{index:Bi(g,1),Y:Pt(g,2),label:Re(g,3)!=null?Li(g,3):void 0,displayName:Re(g,4)!=null?Li(g,4):void 0}})}function Im(f){return{x:Pt(f,1),y:Pt(f,2),z:Pt(f,3),visibility:Re(f,4)!=null?Pt(f,4):void 0}}function da(f,g){this.h=f,this.g=g,this.l=0}function Vi(f,g,y){return Om(f,g),typeof f.g.canvas.transferToImageBitmap=="function"?Promise.resolve(f.g.canvas.transferToImageBitmap()):y?Promise.resolve(f.g.canvas):typeof createImageBitmap=="function"?createImageBitmap(f.g.canvas):(f.i===void 0&&(f.i=document.createElement("canvas")),new Promise(function(T){f.i.height=f.g.canvas.height,f.i.width=f.g.canvas.width,f.i.getContext("2d",{}).drawImage(f.g.canvas,0,0,f.g.canvas.width,f.g.canvas.height),T(f.i)}))}function Om(f,g){var y=f.g;if(f.m===void 0){var T=zi(y,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),I=zi(y,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),L=y.createProgram();if(y.attachShader(L,T),y.attachShader(L,I),y.linkProgram(L),!y.getProgramParameter(L,y.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+y.getProgramInfoLog(L));T=f.m=L,y.useProgram(T),I=y.getUniformLocation(T,"sampler0"),f.j={I:y.getAttribLocation(T,"aVertex"),H:y.getAttribLocation(T,"aTex"),da:I},f.s=y.createBuffer(),y.bindBuffer(y.ARRAY_BUFFER,f.s),y.enableVertexAttribArray(f.j.I),y.vertexAttribPointer(f.j.I,2,y.FLOAT,!1,0,0),y.bufferData(y.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),y.STATIC_DRAW),y.bindBuffer(y.ARRAY_BUFFER,null),f.o=y.createBuffer(),y.bindBuffer(y.ARRAY_BUFFER,f.o),y.enableVertexAttribArray(f.j.H),y.vertexAttribPointer(f.j.H,2,y.FLOAT,!1,0,0),y.bufferData(y.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),y.STATIC_DRAW),y.bindBuffer(y.ARRAY_BUFFER,null),y.uniform1i(I,0)}T=f.j,y.useProgram(f.m),y.canvas.width=g.width,y.canvas.height=g.height,y.viewport(0,0,g.width,g.height),y.activeTexture(y.TEXTURE0),f.h.bindTexture2d(g.glName),y.enableVertexAttribArray(T.I),y.bindBuffer(y.ARRAY_BUFFER,f.s),y.vertexAttribPointer(T.I,2,y.FLOAT,!1,0,0),y.enableVertexAttribArray(T.H),y.bindBuffer(y.ARRAY_BUFFER,f.o),y.vertexAttribPointer(T.H,2,y.FLOAT,!1,0,0),y.bindFramebuffer(y.DRAW_FRAMEBUFFER?y.DRAW_FRAMEBUFFER:y.FRAMEBUFFER,null),y.clearColor(0,0,0,0),y.clear(y.COLOR_BUFFER_BIT),y.colorMask(!0,!0,!0,!0),y.drawArrays(y.TRIANGLE_FAN,0,4),y.disableVertexAttribArray(T.I),y.disableVertexAttribArray(T.H),y.bindBuffer(y.ARRAY_BUFFER,null),f.h.bindTexture2d(0)}function Dm(f){this.g=f}var Fm=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function Cm(f,g){return g+f}function ji(f,g){window[f]=g}function Pm(f){var g=document.createElement("script");return g.setAttribute("src",f),g.setAttribute("crossorigin","anonymous"),new Promise(function(y){g.addEventListener("load",function(){y()},!1),g.addEventListener("error",function(){y()},!1),document.body.appendChild(g)})}function Rm(){return Ge(this,function f(){return D(f,function(g){switch(g.g){case 1:return g.m=2,_(g,WebAssembly.instantiate(Fm),4);case 4:g.g=3,g.m=0;break;case 2:return g.m=0,g.j=null,g.return(!1);case 3:return g.return(!0)}})})}function ma(f){if(this.g=f,this.listeners={},this.j={},this.F={},this.m={},this.s={},this.G=this.o=this.R=!0,this.C=Promise.resolve(),this.P="",this.B={},this.locateFile=f&&f.locateFile||Cm,typeof window=="object")var g=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")g=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.S=g,f.options){g=i(Object.keys(f.options));for(var y=g.next();!y.done;y=g.next()){y=y.value;var T=f.options[y].default;T!==void 0&&(this.j[y]=typeof T=="function"?T():T)}}}t=ma.prototype,t.close=function(){return this.i&&this.i.delete(),Promise.resolve()};function Bm(f,g){return f.g.files===void 0?[]:typeof f.g.files=="function"?f.g.files(g):f.g.files}function Lm(f){return Ge(f,function g(){var y=this,T,I,L,O,R,j,H,Q,Se,le,te;return D(g,function(K){switch(K.g){case 1:return T=y,y.R?(I=Bm(y,y.j),_(K,Rm(),2)):K.return();case 2:if(L=K.h,typeof window=="object")return ji("createMediapipeSolutionsWasm",{locateFile:y.locateFile}),ji("createMediapipeSolutionsPackedAssets",{locateFile:y.locateFile}),j=I.filter(function(ee){return ee.data!==void 0}),H=I.filter(function(ee){return ee.data===void 0}),Q=Promise.all(j.map(function(ee){var ue=os(T,ee.url);if(ee.path!==void 0){var fe=ee.path;ue=ue.then(function(je){return T.overrideFile(fe,je),Promise.resolve(je)})}return ue})),Se=Promise.all(H.map(function(ee){return ee.simd===void 0||ee.simd&&L||!ee.simd&&!L?Pm(T.locateFile(ee.url,T.S)):Promise.resolve()})).then(function(){return Ge(T,function ee(){var ue,fe,je=this;return D(ee,function(ke){if(ke.g==1)return ue=window.createMediapipeSolutionsWasm,fe=window.createMediapipeSolutionsPackedAssets,_(ke,ue(fe),2);je.h=ke.h,ke.g=0})})}),le=function(){return Ge(T,function ee(){var ue=this;return D(ee,function(fe){return ue.g.graph&&ue.g.graph.url?fe=_(fe,os(ue,ue.g.graph.url),0):(fe.g=0,fe=void 0),fe})})}(),_(K,Promise.all([Se,Q,le]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return O=I.filter(function(ee){return ee.simd===void 0||ee.simd&&L||!ee.simd&&!L}).map(function(ee){return T.locateFile(ee.url,T.S)}),importScripts.apply(null,u(O)),_(K,createMediapipeSolutionsWasm(Module),6);case 6:y.h=K.h,y.l=new OffscreenCanvas(1,1),y.h.canvas=y.l,R=y.h.GL.createContext(y.l,{antialias:!1,alpha:!1,ba:typeof WebGL2RenderingContext<"u"?2:1}),y.h.GL.makeContextCurrent(R),K.g=4;break;case 7:if(y.l=document.createElement("canvas"),te=y.l.getContext("webgl2",{}),!te&&(te=y.l.getContext("webgl",{}),!te))return alert("Failed to create WebGL canvas context when passing video frame."),K.return();y.D=te,y.h.canvas=y.l,y.h.createContext(y.l,!0,!0,{});case 4:y.i=new y.h.SolutionWasm,y.R=!1,K.g=0}})})}function Mm(f){return Ge(f,function g(){var y=this,T,I,L,O,R,j,H,Q;return D(g,function(Se){if(Se.g==1){if(y.g.graph&&y.g.graph.url&&y.P===y.g.graph.url)return Se.return();if(y.o=!0,!y.g.graph||!y.g.graph.url){Se.g=2;return}return y.P=y.g.graph.url,_(Se,os(y,y.g.graph.url),3)}for(Se.g!=2&&(T=Se.h,y.i.loadGraph(T)),I=i(Object.keys(y.B)),L=I.next();!L.done;L=I.next())O=L.value,y.i.overrideFile(O,y.B[O]);if(y.B={},y.g.listeners)for(R=i(y.g.listeners),j=R.next();!j.done;j=R.next())H=j.value,Um(y,H);Q=y.j,y.j={},y.setOptions(Q),Se.g=0})})}t.reset=function(){return Ge(this,function f(){var g=this;return D(f,function(y){g.i&&(g.i.reset(),g.m={},g.s={}),y.g=0})})},t.setOptions=function(f,g){var y=this;if(g=g||this.g.options){for(var T=[],I=[],L={},O=i(Object.keys(f)),R=O.next();!R.done;L={K:L.K,L:L.L},R=O.next()){var j=R.value;j in this.j&&this.j[j]===f[j]||(this.j[j]=f[j],R=g[j],R!==void 0&&(R.onChange&&(L.K=R.onChange,L.L=f[j],T.push(function(H){return function(){return Ge(y,function Q(){var Se,le=this;return D(Q,function(te){if(te.g==1)return _(te,H.K(H.L),2);Se=te.h,Se===!0&&(le.o=!0),te.g=0})})}}(L))),R.graphOptionXref&&(j={valueNumber:R.type===1?f[j]:0,valueBoolean:R.type===0?f[j]:!1,valueString:R.type===2?f[j]:""},R=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),R.graphOptionXref),j),I.push(R))))}(T.length!==0||I.length!==0)&&(this.o=!0,this.A=(this.A===void 0?[]:this.A).concat(I),this.u=(this.u===void 0?[]:this.u).concat(T))}};function zm(f){return Ge(f,function g(){var y=this,T,I,L,O,R,j,H;return D(g,function(Q){switch(Q.g){case 1:if(!y.o)return Q.return();if(!y.u){Q.g=2;break}T=i(y.u),I=T.next();case 3:if(I.done){Q.g=5;break}return L=I.value,_(Q,L(),4);case 4:I=T.next(),Q.g=3;break;case 5:y.u=void 0;case 2:if(y.A){for(O=new y.h.GraphOptionChangeRequestList,R=i(y.A),j=R.next();!j.done;j=R.next())H=j.value,O.push_back(H);y.i.changeOptions(O),O.delete(),y.A=void 0}y.o=!1,Q.g=0}})})}t.initialize=function(){return Ge(this,function f(){var g=this;return D(f,function(y){return y.g==1?_(y,Lm(g),2):y.g!=3?_(y,Mm(g),3):_(y,zm(g),0)})})};function os(f,g){return Ge(f,function y(){var T=this,I,L;return D(y,function(O){return g in T.F?O.return(T.F[g]):(I=T.locateFile(g,""),L=fetch(I).then(function(R){return R.arrayBuffer()}),T.F[g]=L,O.return(L))})})}t.overrideFile=function(f,g){this.i?this.i.overrideFile(f,g):this.B[f]=g},t.clearOverriddenFiles=function(){this.B={},this.i&&this.i.clearOverriddenFiles()},t.send=function(f,g){return Ge(this,function y(){var T=this,I,L,O,R,j,H,Q,Se,le;return D(y,function(te){switch(te.g){case 1:return T.g.inputs?(I=1e3*(g??performance.now()),_(te,T.C,2)):te.return();case 2:return _(te,T.initialize(),3);case 3:for(L=new T.h.PacketDataList,O=i(Object.keys(f)),R=O.next();!R.done;R=O.next())if(j=R.value,H=T.g.inputs[j]){e:{var K=T,ee=f[j];switch(H.type){case"video":var ue=K.m[H.stream];if(ue||(ue=new da(K.h,K.D),K.m[H.stream]=ue),K=ue,K.l===0&&(K.l=K.h.createTexture()),typeof HTMLVideoElement<"u"&&ee instanceof HTMLVideoElement){var fe=ee.videoWidth;ue=ee.videoHeight}else typeof HTMLImageElement<"u"&&ee instanceof HTMLImageElement?(fe=ee.naturalWidth,ue=ee.naturalHeight):(fe=ee.width,ue=ee.height);ue={glName:K.l,width:fe,height:ue},fe=K.g,fe.canvas.width=ue.width,fe.canvas.height=ue.height,fe.activeTexture(fe.TEXTURE0),K.h.bindTexture2d(K.l),fe.texImage2D(fe.TEXTURE_2D,0,fe.RGBA,fe.RGBA,fe.UNSIGNED_BYTE,ee),K.h.bindTexture2d(0),K=ue;break e;case"detections":for(ue=K.m[H.stream],ue||(ue=new Dm(K.h),K.m[H.stream]=ue),K=ue,K.data||(K.data=new K.g.DetectionListData),K.data.reset(ee.length),ue=0;ue<ee.length;++ue){fe=ee[ue];var je=K.data,ke=je.setBoundingBox,et=ue,Le=fe.T,ie=new pa;ve(ie,1,Le.Z),ve(ie,2,Le.$),ve(ie,3,Le.height),ve(ie,4,Le.width),ve(ie,5,Le.rotation),ve(ie,6,Le.X);var de=Le=new ua;It(de,1,Re(ie,1)),It(de,2,Re(ie,2)),It(de,3,Re(ie,3)),It(de,4,Re(ie,4)),It(de,5,Re(ie,5));var ge=Re(ie,6);if(ge!=null&&ge!=null){nn(de.g,48);var ae=de.g,me=ge;ge=0>me,me=Math.abs(me);var J=me>>>0;for(me=Math.floor((me-J)/4294967296),me>>>=0,ge&&(me=~me>>>0,J=(~J>>>0)+1,4294967295<J&&(J=0,me++,4294967295<me&&(me=0))),rt=J,$t=me,ge=rt,J=$t;0<J||127<ge;)ae.push(ge&127|128),ge=(ge>>>7|J<<25)>>>0,J>>>=7;ae.push(ge)}if(ha(ie,de),Le=la(Le),ke.call(je,et,Le),fe.O)for(je=0;je<fe.O.length;++je)ie=fe.O[je],de=!!ie.visibility,ke=K.data,et=ke.addNormalizedLandmark,Le=ue,ie=Object.assign(Object.assign({},ie),{visibility:de?ie.visibility:0}),de=new br,ve(de,1,ie.x),ve(de,2,ie.y),ve(de,3,ie.z),ie.visibility&&ve(de,4,ie.visibility),ae=ie=new ua,It(ae,1,Re(de,1)),It(ae,2,Re(de,2)),It(ae,3,Re(de,3)),It(ae,4,Re(de,4)),It(ae,5,Re(de,5)),ha(de,ae),ie=la(ie),et.call(ke,Le,ie);if(fe.M)for(je=0;je<fe.M.length;++je){if(ke=K.data,et=ke.addClassification,Le=ue,ie=fe.M[je],de=new yr,ve(de,2,ie.Y),ie.index&&ve(de,1,ie.index),ie.label&&ve(de,3,ie.label),ie.displayName&&ve(de,4,ie.displayName),ae=ie=new ua,J=Re(de,1),J!=null&&J!=null)if(nn(ae.g,8),ge=ae.g,0<=J)nn(ge,J);else{for(me=0;9>me;me++)ge.push(J&127|128),J>>=7;ge.push(1)}It(ae,2,Re(de,2)),ge=Re(de,3),ge!=null&&(ge=Be(ge),nn(ae.g,26),nn(ae.g,ge.length),qn(ae,ae.g.end()),qn(ae,ge)),ge=Re(de,4),ge!=null&&(ge=Be(ge),nn(ae.g,34),nn(ae.g,ge.length),qn(ae,ae.g.end()),qn(ae,ge)),ha(de,ae),ie=la(ie),et.call(ke,Le,ie)}}K=K.data;break e;default:K={}}}switch(Q=K,Se=H.stream,H.type){case"video":L.pushTexture2d(Object.assign(Object.assign({},Q),{stream:Se,timestamp:I}));break;case"detections":le=Q,le.stream=Se,le.timestamp=I,L.pushDetectionList(le);break;default:throw Error("Unknown input config type: '"+H.type+"'")}}return T.i.send(L),_(te,T.C,4);case 4:L.delete(),te.g=0}})})};function Vm(f,g,y){return Ge(f,function T(){var I,L,O,R,j,H,Q=this,Se,le,te,K,ee,ue,fe,je;return D(T,function(ke){switch(ke.g){case 1:if(!y)return ke.return(g);for(I={},L=0,O=i(Object.keys(y)),R=O.next();!R.done;R=O.next())j=R.value,H=y[j],typeof H!="string"&&H.type==="texture"&&g[H.stream]!==void 0&&++L;1<L&&(Q.G=!1),Se=i(Object.keys(y)),R=Se.next();case 2:if(R.done){ke.g=4;break}if(le=R.value,te=y[le],typeof te=="string")return fe=I,je=le,_(ke,jm(Q,le,g[te]),14);if(K=g[te.stream],te.type==="detection_list"){if(K){for(var et=K.getRectList(),Le=K.getLandmarksList(),ie=K.getClassificationsList(),de=[],ge=0;ge<et.size();++ge){var ae=et.get(ge);e:{var me=new pa;for(ae=new ss(ae);Un(ae);)switch(ae.i){case 13:var J=At(ae.g);ve(me,1,J);break;case 21:J=At(ae.g),ve(me,2,J);break;case 29:J=At(ae.g),ve(me,3,J);break;case 37:J=At(ae.g),ve(me,4,J);break;case 45:J=At(ae.g),ve(me,5,J);break;case 48:for(var Fe=ae.g,ze=128,ga=0,wn=J=0;4>wn&&128<=ze;wn++)ze=Fe.h[Fe.g++],ga|=(ze&127)<<7*wn;if(128<=ze&&(ze=Fe.h[Fe.g++],ga|=(ze&127)<<28,J|=(ze&127)>>4),128<=ze)for(wn=0;5>wn&&128<=ze;wn++)ze=Fe.h[Fe.g++],J|=(ze&127)<<7*wn+3;128>ze?(Fe=ga>>>0,ze=J>>>0,(J=ze&2147483648)&&(Fe=~Fe+1>>>0,ze=~ze>>>0,Fe==0&&(ze=ze+1>>>0)),Fe=4294967296*ze+(Fe>>>0),J=J?-Fe:Fe):(Fe.l=!0,J=void 0),ve(me,6,J);break;default:if(!gr(me,ae))break e}}me={Z:Pt(me,1),$:Pt(me,2),height:Pt(me,3),width:Pt(me,4),rotation:Pt(me,5,0),X:Bi(me,6)},J=Le.get(ge);e:for(ae=new Mi,J=new ss(J);Un(J);)switch(J.i){case 10:Fe=Ai(J,new br,xm),Ri(ae,Fe,br,void 0);break;default:if(!gr(ae,J))break e}ae=ca(ae,br).map(Im),Fe=ie.get(ge);e:for(J=new fa,Fe=new ss(Fe);Un(Fe);)switch(Fe.i){case 10:J.addClassification(Ai(Fe,new yr,km));break;default:if(!gr(J,Fe))break e}me={T:me,O:ae,M:Am(J)},de.push(me)}et=de}else et=[];I[le]=et,ke.g=7;break}if(te.type==="proto_list"){if(K){for(et=Array(K.size()),Le=0;Le<K.size();Le++)et[Le]=K.get(Le);K.delete()}else et=[];I[le]=et,ke.g=7;break}if(K===void 0){ke.g=3;break}if(te.type==="float_list"){I[le]=K,ke.g=7;break}if(te.type==="proto"){I[le]=K,ke.g=7;break}if(te.type!=="texture")throw Error("Unknown output config type: '"+te.type+"'");return ee=Q.s[le],ee||(ee=new da(Q.h,Q.D),Q.s[le]=ee),_(ke,Vi(ee,K,Q.G),13);case 13:ue=ke.h,I[le]=ue;case 7:te.transform&&I[le]&&(I[le]=te.transform(I[le])),ke.g=3;break;case 14:fe[je]=ke.h;case 3:R=Se.next(),ke.g=2;break;case 4:return ke.return(I)}})})}function jm(f,g,y){return Ge(f,function T(){var I=this,L;return D(T,function(O){return typeof y=="number"||y instanceof Uint8Array||y instanceof I.h.Uint8BlobList?O.return(y):y instanceof I.h.Texture2dDataOut?(L=I.s[g],L||(L=new da(I.h,I.D),I.s[g]=L),O.return(Vi(L,y,I.G))):O.return(void 0)})})}function Um(f,g){for(var y=g.name||"$",T=[].concat(u(g.wants)),I=new f.h.StringList,L=i(g.wants),O=L.next();!O.done;O=L.next())I.push_back(O.value);L=f.h.PacketListener.implement({onResults:function(R){for(var j={},H=0;H<g.wants.length;++H)j[T[H]]=R.get(H);var Q=f.listeners[y];Q&&(f.C=Vm(f,j,g.outs).then(function(Se){Se=Q(Se);for(var le=0;le<g.wants.length;++le){var te=j[T[le]];typeof te=="object"&&te.hasOwnProperty&&te.hasOwnProperty("delete")&&te.delete()}Se&&(f.C=Se)}))}}),f.i.attachMultiListener(I,L),I.delete()}t.onResults=function(f,g){this.listeners[g||"$"]=f},G("Solution",ma),G("OptionType",{BOOL:0,NUMBER:1,aa:2,0:"BOOL",1:"NUMBER",2:"STRING"});function Ui(f){switch(f===void 0&&(f=0),f){case 1:return"selfie_segmentation_landscape.tflite";default:return"selfie_segmentation.tflite"}}function Wi(f){var g=this;f=f||{},this.g=new ma({locateFile:f.locateFile,files:function(y){return[{simd:!0,url:"selfie_segmentation_solution_simd_wasm_bin.js"},{simd:!1,url:"selfie_segmentation_solution_wasm_bin.js"},{data:!0,url:Ui(y.modelSelection)}]},graph:{url:"selfie_segmentation.binarypb"},listeners:[{wants:["segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelSelection:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelSelection",fieldName:"int_value"},onChange:function(y){return Ge(g,function T(){var I,L,O=this,R;return D(T,function(j){return j.g==1?(I=Ui(y),L="third_party/mediapipe/modules/selfie_segmentation/"+I,_(j,os(O.g,I),2)):(R=j.h,O.g.overrideFile(L,R),j.return(!0))})})}}}})}t=Wi.prototype,t.close=function(){return this.g.close(),Promise.resolve()},t.onResults=function(f){this.g.onResults(f)},t.initialize=function(){return Ge(this,function f(){var g=this;return D(f,function(y){return _(y,g.g.initialize(),0)})})},t.reset=function(){this.g.reset()},t.send=function(f){return Ge(this,function g(){var y=this;return D(g,function(T){return _(T,y.g.send(f),0)})})},t.setOptions=function(f){this.g.setOptions(f)},G("SelfieSegmentation",Wi),G("VERSION","0.1.1632777926")}).call(Mt);var SE=SelfieSegmentation;VERSION;var lo=function(t,e){return lo=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,r){n.__proto__=r}||function(n,r){for(var s in r)r.hasOwnProperty(s)&&(n[s]=r[s])},lo(t,e)};function Jd(t,e){function n(){this.constructor=t}lo(t,e),t.prototype=e===null?Object.create(e):(n.prototype=e.prototype,new n)}var Ke=function(){return Ke=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var s in e=arguments[n])Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s]);return t},Ke.apply(this,arguments)};function ce(t,e,n,r){return new(n||(n=Promise))(function(s,a){function o(l){try{u(r.next(l))}catch(c){a(c)}}function i(l){try{u(r.throw(l))}catch(c){a(c)}}function u(l){var c;l.done?s(l.value):(c=l.value,c instanceof n?c:new n(function(h){h(c)})).then(o,i)}u((r=r.apply(t,e||[])).next())})}function he(t,e){var n,r,s,a,o={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return a={next:i(0),throw:i(1),return:i(2)},typeof Symbol=="function"&&(a[Symbol.iterator]=function(){return this}),a;function i(u){return function(l){return function(c){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(s=2&c[0]?r.return:c[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,c[1])).done)return s;switch(r=0,s&&(c=[2&c[0],s.value]),c[0]){case 0:case 1:s=c;break;case 4:return o.label++,{value:c[1],done:!1};case 5:o.label++,r=c[1],c=[0];continue;case 7:c=o.ops.pop(),o.trys.pop();continue;default:if(s=o.trys,!((s=s.length>0&&s[s.length-1])||c[0]!==6&&c[0]!==2)){o=0;continue}if(c[0]===3&&(!s||c[1]>s[0]&&c[1]<s[3])){o.label=c[1];break}if(c[0]===6&&o.label<s[1]){o.label=s[1],s=c;break}if(s&&o.label<s[2]){o.label=s[2],o.ops.push(c);break}s[2]&&o.ops.pop(),o.trys.pop();continue}c=e.call(t,o)}catch(h){c=[6,h],r=0}finally{n=s=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}([u,l])}}}function Ps(t){return t instanceof SVGAnimatedLength?t.baseVal.value:t}function ki(t){return ce(this,void 0,void 0,function(){var e,n;return he(this,function(r){switch(r.label){case 0:return e=document.createElement("canvas"),t instanceof be?[4,qr(t,e)]:[3,2];case 1:return r.sent(),[3,3];case 2:e.width=Ps(t.width),e.height=Ps(t.height),n=e.getContext("2d"),t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0),r.label=3;case 3:return[2,e]}})})}function Qd(t){return ce(this,void 0,void 0,function(){var e,n,r,s,a,o;return he(this,function(i){switch(i.label){case 0:return t instanceof be?(e=t.shape.slice(0,2),n=e[0],r=e[1],s=ImageData.bind,[4,qr(t)]):[3,2];case 1:return[2,new(s.apply(ImageData,[void 0,i.sent(),r,n]))];case 2:return a=document.createElement("canvas"),o=a.getContext("2d"),a.width=Ps(t.width),a.height=Ps(t.height),o.drawImage(t,0,0),[2,o.getImageData(0,0,a.width,a.height)]}})})}function em(t){return ce(this,void 0,void 0,function(){var e,n;return he(this,function(r){switch(r.label){case 0:return t instanceof SVGImageElement||t instanceof OffscreenCanvas?[4,ki(t)]:[3,2];case 1:return n=r.sent(),[3,3];case 2:n=t,r.label=3;case 3:return e=n,[2,Vs(e,4)]}})})}function aa(t){if(t<0||t>=256)throw new Error("Mask value must be in range [0, 255] but got "+t);if(!Number.isInteger(t))throw new Error("Mask value must be an integer but got "+t)}function tm(t){var e=t.shape[2],n=Mo(t,2),r=B(n,[-1]);return Fr(r,e)}function ls(t,e){return Z(function(){return we(fr(t,se(e)),"int32")})}function NE(t,e){var n=e.shape,r=n[0],s=n[1],a=n[2];return Z(function(){var o=tm(e),i=ot(pn(0,a,1,"int32"),1),u=we(ye(o,i),"int32"),l=B(u,[r,s]),c=Y(l,se(1,"int32"));return ne(function(h,p){return U(h,p)}(c,t),se(1,"int32"))})}var nm=function(){function t(e,n){this.model=e,this.outputStride=n;var r=this.model.inputs[0].shape;S(r[1]===-1&&r[2]===-1,function(){return"Input shape ["+r[1]+", "+r[2]+"] must both be equal to or -1"})}return t.prototype.predict=function(e){var n=this;return Z(function(){var r=n.preprocessInput(we(e,"float32")),s=ot(r,0),a=n.model.predict(s).map(function(i){return bt(i,[0])}),o=n.nameOutputResults(a);return{heatmapScores:Vt(o.heatmap),offsets:o.offsets,displacementFwd:o.displacementFwd,displacementBwd:o.displacementBwd,segmentation:o.segmentation,partHeatmaps:o.partHeatmaps,longOffsets:o.longOffsets,partOffsets:o.partOffsets}})},t.prototype.dispose=function(){this.model.dispose()},t}(),TE=function(t){function e(){return t!==null&&t.apply(this,arguments)||this}return Jd(e,t),e.prototype.preprocessInput=function(n){return Z(function(){return ne(_e(n,127.5),1)})},e.prototype.nameOutputResults=function(n){return{offsets:n[0],segmentation:n[1],partHeatmaps:n[2],longOffsets:n[3],heatmap:n[4],displacementFwd:n[5],displacementBwd:n[6],partOffsets:n[7]}},e}(nm),oa=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],Dt=oa.length,Rs=oa.reduce(function(t,e,n){return t[e]=n,t},{});[["leftHip","leftShoulder"],["leftElbow","leftShoulder"],["leftElbow","leftWrist"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["rightHip","rightShoulder"],["rightElbow","rightShoulder"],["rightElbow","rightWrist"],["rightHip","rightKnee"],["rightKnee","rightAnkle"],["leftShoulder","rightShoulder"],["leftHip","rightHip"]].map(function(t){var e=t[0],n=t[1];return[Rs[e],Rs[n]]});function _i(t,e,n){var r=t[0],s=t[1],a=e[0],o=e[1],i=n.top,u=n.bottom;return[o/(n.left+n.right+s),a/(i+u+r)]}function rm(t,e,n,r){return{y:r.get(t,e,n),x:r.get(t,e,n+Dt)}}function sm(t,e,n){var r=rm(t.heatmapY,t.heatmapX,t.id,n),s=r.y,a=r.x;return{x:t.heatmapX*e+a,y:t.heatmapY*e+s}}function bu(t,e,n){return t<e?e:t>n?n:t}function wu(t,e){return{x:t.x+e.x,y:t.y+e.y}}function EE(t,e,n){n===void 0&&(n=.3);for(var r=0,s=0,a=0;a<t.length;a++)e.keypoints[a].score>n&&(s+=1,r+=Math.pow(t[a].x-e.keypoints[a].position.x,2)+Math.pow(t[a].y-e.keypoints[a].position.y,2));return s===0?r=1/0:r/=s,r}function kE(t,e,n,r,s,a,o){for(var i=o[0],u=o[1],l=n(t),c=l.y*r+l.x,h=s[Dt*(2*c)+e],p=s[Dt*(2*c+1)+e],d=t.y+h,b=t.x+p,v=0;v<a;v++){d=Math.min(d,i-1);var N=n({x:b=Math.min(b,u-1),y:d}),x=N.y*r+N.x;d+=h=s[Dt*(2*x)+e],b+=p=s[Dt*(2*x+1)+e]}return{x:b,y:d}}function am(t,e,n,r,s,a,o,i,u,l){for(var c=s[0],h=s[1],p=a[0],d=a[1],b=i[0],v=i[1],N=[],x=function(P){return function(D,V,z,q){var G=V[0],X=V[1],oe=z[0],pe=z[1],Te=Math.round(((G+D.y+1)*pe-1)/q);return{x:Math.round(((X+D.x+1)*oe-1)/q),y:Te}}(P,[c,h],[p,d],u)},F=0;F<r;F++){var _=kE(t,F,x,o,e,l,[b,v]);N.push(_)}for(var $=-1,A=1/0,C=0;C<n.length;C++){var M=EE(N,n[C]);M<A&&($=C,A=M)}return $}function om(t,e){var n=t[0],r=t[1];return[Math.round((r-1)/e+1),Math.round((n-1)/e+1)]}function im(t,e,n,r,s,a,o,i,u,l,c){for(var h=o[0],p=o[1],d=t.shape,b=d[0],v=d[1],N=e.shape.slice(0,2),x=N[0],F=N[1],_=B(e,[x,F,2,Dt]),$=new Float32Array(c*Dt*3).fill(0),A=0;A<n.length;A++)for(var C=A*Dt*3,M=n[A],P=0;P<Dt;P++){var D=M.keypoints[P],V=C+3*P;$[V]=D.score,$[V+1]=D.position.y,$[V+2]=D.position.x}var z=_i([r,s],[h,p],i),q=z[0],G=z[1],X=vt($,[c,Dt,3]),oe=i.top,pe=i.left,Te={variableNames:["segmentation","longOffsets","poses"],outputShape:[b,v],userCode:`
    int convertToPositionInOutput(int pos, int pad, float scale, int stride) {
      return round(((float(pos + pad) + 1.0) * scale - 1.0) / float(stride));
    }

    float convertToPositionInOutputFloat(
        int pos, int pad, float scale, int stride) {
      return ((float(pos + pad) + 1.0) * scale - 1.0) / float(stride);
    }

    float dist(float x1, float y1, float x2, float y2) {
      return pow(x1 - x2, 2.0) + pow(y1 - y2, 2.0);
    }

    float sampleLongOffsets(float h, float w, int d, int k) {
      float fh = fract(h);
      float fw = fract(w);
      int clH = int(ceil(h));
      int clW = int(ceil(w));
      int flH = int(floor(h));
      int flW = int(floor(w));
      float o11 = getLongOffsets(flH, flW, d, k);
      float o12 = getLongOffsets(flH, clW, d, k);
      float o21 = getLongOffsets(clH, flW, d, k);
      float o22 = getLongOffsets(clH, clW, d, k);
      float o1 = mix(o11, o12, fw);
      float o2 = mix(o21, o22, fw);
      return mix(o1, o2, fh);
    }

    int findNearestPose(int h, int w) {
      float prob = getSegmentation(h, w);
      if (prob < 1.0) {
        return -1;
      }

      // Done(Tyler): convert from output space h/w to strided space.
      float stridedH = convertToPositionInOutputFloat(
        h, `+oe+", "+G+", "+a+`);
      float stridedW = convertToPositionInOutputFloat(
        w, `+pe+", "+q+", "+a+`);

      float minDist = 1000000.0;
      int iMin = -1;
      for (int i = 0; i < `+c+`; i++) {
        float curDistSum = 0.0;
        int numKpt = 0;
        for (int k = 0; k < `+Dt+`; k++) {
          float dy = sampleLongOffsets(stridedH, stridedW, 0, k);
          float dx = sampleLongOffsets(stridedH, stridedW, 1, k);

          float y = float(h) + dy;
          float x = float(w) + dx;

          for (int s = 0; s < `+u+`; s++) {
            int yRounded = round(min(y, float(`+(r-1)+`)));
            int xRounded = round(min(x, float(`+(s-1)+`)));

            float yStrided = convertToPositionInOutputFloat(
              yRounded, `+oe+", "+G+", "+a+`);
            float xStrided = convertToPositionInOutputFloat(
              xRounded, `+pe+", "+q+", "+a+`);

            float dy = sampleLongOffsets(yStrided, xStrided, 0, k);
            float dx = sampleLongOffsets(yStrided, xStrided, 1, k);

            y = y + dy;
            x = x + dx;
          }

          float poseScore = getPoses(i, k, 0);
          float poseY = getPoses(i, k, 1);
          float poseX = getPoses(i, k, 2);
          if (poseScore > `+l+`) {
            numKpt = numKpt + 1;
            curDistSum = curDistSum + dist(x, y, poseX, poseY);
          }
        }
        if (numKpt > 0 && curDistSum / float(numKpt) < minDist) {
          minDist = curDistSum / float(numKpt);
          iMin = i;
        }
      }
      return iMin;
    }

    void main() {
        ivec2 coords = getOutputCoords();
        int nearestPose = findNearestPose(coords[0], coords[1]);
        setOutput(float(nearestPose));
      }
  `};return uf().compileAndRun(Te,[t,_,X])}function um(){return of()==="webgl"}function _E(t,e,n,r,s,a,o,i,u,l,c,h){var p=o[0],d=o[1];return u===void 0&&(u=.2),l===void 0&&(l=8),c===void 0&&(c=.3),h===void 0&&(h=10),ce(this,void 0,void 0,function(){var b,v,N,x,F;return he(this,function(_){switch(_.label){case 0:return b=n.filter(function($){return $.score>=u}),um()?(N=Z(function(){var $=im(t,e,b,r,s,a,[p,d],i,l,c,h),A=Oo().makeTensorFromDataId($.dataId,$.shape,$.dtype);return b.map(function(C,M){return function(P,D){return Z(function(){return we(Xr(P,se(D)),"int32")})}(A,M)})}),[4,Promise.all(N.map(function($){return $.data()}))]):[3,2];case 1:return v=_.sent(),N.forEach(function($){return $.dispose()}),[3,5];case 2:return[4,t.data()];case 3:return x=_.sent(),[4,e.data()];case 4:F=_.sent(),v=function($,A,C,M,P,D,V,z,q,G){var X=V[0],oe=V[1];G===void 0&&(G=5);for(var pe=C.map(function(Ct){return new Uint8Array(M*P).fill(0)}),Te=z.top,De=z.left,Be=_i([M,P],[X,oe],z),Ue=Be[0],nt=Be[1],Et=om([X,oe],D)[0],ct=0;ct<M;ct+=1)for(var kt=0;kt<P;kt+=1){var _t=ct*P+kt;if($[_t]===1){var xt=am({x:kt,y:ct},A,C,G,[Te,De],[Ue,nt],Et,[M,P],D,q);xt>=0&&(pe[xt][_t]=1)}}return pe}(x,F,b,r,s,a,[p,d],i,l),_.label=5;case 5:return[2,v.map(function($,A){return{data:$,pose:b[A],width:s,height:r}})]}})})}function xE(t,e,n,r,s,a,o,i,u,l,c,h,p){var d=i[0],b=i[1];return l===void 0&&(l=.2),c===void 0&&(c=8),h===void 0&&(h=.3),p===void 0&&(p=10),ce(this,void 0,void 0,function(){var v,N,x,F,_,$;return he(this,function(A){switch(A.label){case 0:return v=r.filter(function(C){return C.score>=l}),um()?(x=Z(function(){var C=im(t,e,v,s,a,o,[d,b],u,c,h,p),M=Oo().makeTensorFromDataId(C.dataId,C.shape,C.dtype);return v.map(function(P,D){return function(V,z,q){return Z(function(){return ne(U(we(Xr(V,se(q)),"int32"),Y(z,1)),1)})}(M,n,D)})}),[4,Promise.all(x.map(function(C){return C.data()}))]):[3,2];case 1:return N=A.sent(),x.forEach(function(C){return C.dispose()}),[3,6];case 2:return[4,t.data()];case 3:return F=A.sent(),[4,e.data()];case 4:return _=A.sent(),[4,n.data()];case 5:$=A.sent(),N=function(C,M,P,D,V,z,q,G,X,oe,pe){var Te=G[0],De=G[1];pe===void 0&&(pe=5);for(var Be=D.map(function($t){return new Int32Array(V*z).fill(-1)}),Ue=X.top,nt=X.left,Et=_i([V,z],[Te,De],X),ct=Et[0],kt=Et[1],_t=om([Te,De],q)[0],xt=0;xt<V;xt+=1)for(var Ct=0;Ct<z;Ct+=1){var tn=xt*z+Ct;if(C[tn]===1){var rt=am({x:Ct,y:xt},M,D,pe,[Ue,nt],[ct,kt],_t,[V,z],q,oe);rt>=0&&(Be[rt][tn]=P[tn])}}return Be}(F,_,$,v,s,a,o,[d,b],u,c),A.label=6;case 6:return[2,N.map(function(C,M){return{pose:v[M],data:C,height:s,width:a}})]}})})}function Ea(t){return Math.floor(t/2)}var $E=function(){function t(e,n){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=n}return t.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},t.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},t.prototype.empty=function(){return this.numberOfElements===-1},t.prototype.size=function(){return this.numberOfElements+1},t.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},t.prototype.max=function(){return this.priorityQueue[0]},t.prototype.swim=function(e){for(;e>0&&this.less(Ea(e),e);)this.exchange(e,Ea(e)),e=Ea(e)},t.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var n=2*e;if(n<this.numberOfElements&&this.less(n,n+1)&&n++,!this.less(e,n))break;this.exchange(e,n),e=n}},t.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},t.prototype.less=function(e,n){return this.getValueAt(e)<this.getValueAt(n)},t.prototype.exchange=function(e,n){var r=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[n],this.priorityQueue[n]=r},t}();function AE(t,e,n,r,s,a){for(var o=a.shape,i=o[0],u=o[1],l=!0,c=Math.max(n-s,0),h=Math.min(n+s+1,i),p=c;p<h;++p){for(var d=Math.max(r-s,0),b=Math.min(r+s+1,u),v=d;v<b;++v)if(a.get(p,v,t)>e){l=!1;break}if(!l)break}return l}var lm=[["nose","leftEye"],["leftEye","leftEar"],["nose","rightEye"],["rightEye","rightEar"],["nose","leftShoulder"],["leftShoulder","leftElbow"],["leftElbow","leftWrist"],["leftShoulder","leftHip"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["nose","rightShoulder"],["rightShoulder","rightElbow"],["rightElbow","rightWrist"],["rightShoulder","rightHip"],["rightHip","rightKnee"],["rightKnee","rightAnkle"]].map(function(t){var e=t[0],n=t[1];return[Rs[e],Rs[n]]}),ka=lm.map(function(t){return t[1]}),vu=lm.map(function(t){return t[0]});function _a(t,e,n,r){return{y:bu(Math.round(t.y/e),0,n-1),x:bu(Math.round(t.x/e),0,r-1)}}function Su(t,e,n,r,s,a,o,i){i===void 0&&(i=2);for(var u=r.shape,l=u[0],c=u[1],h=function(F,_,$){var A=$.shape[2]/2;return{y:$.get(_.y,_.x,F),x:$.get(_.y,_.x,A+F)}}(t,_a(e.position,a,l,c),o),p=wu(e.position,h),d=0;d<i;d++){var b=_a(p,a,l,c),v=rm(b.y,b.x,n,s);p=wu({x:b.x*a,y:b.y*a},{x:v.x,y:v.y})}var N=_a(p,a,l,c),x=r.get(N.y,N.x,n);return{position:p,part:oa[n],score:x}}function IE(t,e,n,r,s,a){var o=e.shape[2],i=ka.length,u=new Array(o),l=t.part,c=t.score,h=sm(l,r,n);u[l.id]={score:c,part:oa[l.id],position:h};for(var p=i-1;p>=0;--p){var d=ka[p],b=vu[p];u[d]&&!u[b]&&(u[b]=Su(p,u[d],b,e,n,r,a))}for(p=0;p<i;++p)d=vu[p],b=ka[p],u[d]&&!u[b]&&(u[b]=Su(p,u[d],b,e,n,r,s));return u}function cm(t,e,n,r){var s=n.x,a=n.y;return t.some(function(o){var i,u,l,c,h,p,d=o.keypoints[r].position;return i=a,u=s,l=d.y,c=d.x,(h=l-i)*h+(p=c-u)*p<=e})}function OE(t,e,n){var r=n.reduce(function(s,a,o){var i=a.position,u=a.score;return cm(t,e,i,o)||(s+=u),s},0);return r/n.length}function cs(t,e,n,r,s,a,o,i){o===void 0&&(o=.5),i===void 0&&(i=20);for(var u=[],l=function(b,v,N){for(var x=N.shape,F=x[0],_=x[1],$=x[2],A=new $E(F*_*$,function(V){return V.score}),C=0;C<F;++C)for(var M=0;M<_;++M)for(var P=0;P<$;++P){var D=N.get(C,M,P);D<b||AE(P,D,C,M,v,N)&&A.enqueue({score:D,part:{heatmapY:C,heatmapX:M,id:P}})}return A}(o,1,t),c=i*i;u.length<a&&!l.empty();){var h=l.dequeue();if(!cm(u,c,sm(h.part,s,e),h.part.id)){var p=IE(h,t,e,s,n,r),d=OE(u,c,p);u.push({keypoints:p,score:d})}}return u}var Sr,DE=[-123.15,-115.9,-103.06],FE=function(t){function e(){return t!==null&&t.apply(this,arguments)||this}return Jd(e,t),e.prototype.preprocessInput=function(n){return Y(n,DE)},e.prototype.nameOutputResults=function(n){var r=n[0],s=n[1],a=n[2],o=n[3],i=n[4],u=n[5];return{offsets:i,segmentation:n[6],partHeatmaps:u,longOffsets:o,heatmap:a,displacementFwd:s,displacementBwd:r,partOffsets:n[7]}},e}(nm),Nu="https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/resnet50/",Tu="https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/";function Er(t){if(typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&t instanceof OffscreenCanvas||typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)return function(e){if("offsetHeight"in e&&e.offsetHeight!==0&&"offsetWidth"in e&&e.offsetWidth!==0)return[e.offsetHeight,e.offsetWidth];if(e.height!=null&&e.width!=null)return[e.height,e.width];throw new Error("HTMLImageElement must have height and width attributes set.")}(t);if(typeof ImageData<"u"&&t instanceof ImageData)return[t.height,t.width];if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)return function(e){return e.hasAttribute("height")&&e.hasAttribute("width")?[e.height,e.width]:[e.videoHeight,e.videoWidth]}(t);if(t instanceof be)return[t.shape[0],t.shape[1]];throw new Error("error: Unknown input type: "+t+".")}function Eu(t,e){return function(n,r){return(n-1)%r==0}(t,e)?t:Math.floor(t/e)*e+1}var kr={low:"low",medium:"medium",high:"high",full:"full"},CE=((Sr={})[kr.low]=.25,Sr[kr.medium]=.5,Sr[kr.high]=.75,Sr[kr.full]=1,Sr);function hs(t,e,n){var r=n[0],s=n[1],a=function(o){if(typeof o=="string"){var i=CE[o];return S(typeof i=="number",function(){return"string value of inputResolution must be one of "+Object.values(kr).join(",")+" but was "+o+"."}),i}return S(typeof o=="number"&&o<=2&&o>=.1,function(){return"inputResolution must be a string or number between 0.1 and 2, but was "+o}),o}(t);return[Eu(r*a,e),Eu(s*a,e)]}function Kn(t,e,n,r,s){var a=e[0],o=e[1],i=n[0],u=n[1],l=r[0],c=l[0],h=l[1],p=r[1],d=p[0],b=p[1];return s===void 0&&(s=!1),Z(function(){var v=Rn.resizeBilinear(t,[i,u],!0);return s&&(v=Vt(v)),function(N,x,F){var _=x[0],$=x[1],A=F[0],C=A[0],M=A[1],P=F[1],D=P[0],V=P[1];return Z(function(){var z=ot(N);return bt(Rn.cropAndResize(z,[[C/(_+C+M-1),D/($+D+V-1),(C+_-1)/(_+C+M-1),(D+$-1)/($+D+V-1)]],[0],[_,$]),[0])})}(v,[a,o],[[c,h],[d,b]])})}function fs(t,e){var n=e[0],r=e[1],s=Er(t),a=s[0],o=s[1],i=r/n,u=[0,0,0,0],l=u[0],c=u[1],h=u[2],p=u[3];o/a<i?(l=0,c=0,h=Math.round(.5*(i*a-o)),p=Math.round(.5*(i*a-o))):(l=Math.round(.5*(1/i*o-a)),c=Math.round(.5*(1/i*o-a)),h=0,p=0);var d=Z(function(){var b=function(v){return v instanceof be?v:Vs(v)}(t);return b=ii(b,[[l,c],[h,p],[0,0]]),Rn.resizeBilinear(b,[n,r])});return{resized:d,padding:{top:l,left:h,right:p,bottom:c}}}function ps(t){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,Promise.all(t.map(function(n){return n.buffer()}))]})})}function ds(t,e,n,r,s){var a=e[0],o=e[1],i=n[0],u=n[1],l=function(c,h,p,d,b){return d===void 0&&(d=0),b===void 0&&(b=0),p===1&&h===1&&d===0&&b===0?c:c.map(function(v){return function(N,x,F,_,$){return _===void 0&&(_=0),$===void 0&&($=0),{score:N.score,keypoints:N.keypoints.map(function(A){var C=A.score,M=A.part,P=A.position;return{score:C,part:M,position:{x:P.x*F+$,y:P.y*x+_}}})}}(v,h,p,d,b)})}(t,(a+r.top+r.bottom)/i,(o+r.left+r.right)/u,-r.top,-r.left);return s?function(c,h){return h<=0?c:c.map(function(p){return function(d,b){return{score:d.score,keypoints:d.keypoints.map(function(v){var N=v.score,x=v.part,F=v.position;return{score:N,part:x,position:{x:b-1-F.x,y:F.y}}})}}(p,h)})}(l,o):l}var ku={architecture:"MobileNetV1",outputStride:16,quantBytes:4,multiplier:.75},_u=["MobileNetV1","ResNet50"],xu={MobileNetV1:[8,16,32],ResNet50:[32,16]},$u={MobileNetV1:[.5,.75,1],ResNet50:[1]},Au=[1,2,4],ms={flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7,maxDetections:10,scoreThreshold:.4,nmsRadius:20},gs={flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7,maxDetections:10,scoreThreshold:.4,nmsRadius:20,minKeypointScore:.3,refineSteps:10};function Iu(t){var e=t.segmentationThreshold,n=t.maxDetections,r=t.scoreThreshold,s=t.nmsRadius;if(e<0||e>1)throw new Error("segmentationThreshold "+e+". Should be in range [0.0, 1.0]");if(n<=0)throw new Error("Invalid maxDetections "+n+". Should be > 0");if(r<0||r>1)throw new Error("Invalid scoreThreshold "+r+". Should be in range [0.0, 1.0]");if(s<=0)throw new Error("Invalid nmsRadius "+s+".")}function Ou(t){var e=t.segmentationThreshold,n=t.maxDetections,r=t.scoreThreshold,s=t.nmsRadius,a=t.minKeypointScore,o=t.refineSteps;if(e<0||e>1)throw new Error("segmentationThreshold "+e+". Should be in range [0.0, 1.0]");if(n<=0)throw new Error("Invalid maxDetections "+n+". Should be > 0");if(r<0||r>1)throw new Error("Invalid scoreThreshold "+r+". Should be in range [0.0, 1.0]");if(s<=0)throw new Error("Invalid nmsRadius "+s+".");if(a<0||a>1)throw new Error("Invalid minKeypointScore "+a+".Should be in range [0.0, 1.0]");if(o<=0||o>20)throw new Error("Invalid refineSteps "+o+".Should be in range [1, 20]")}var hm=function(){function t(e){this.baseModel=e}return t.prototype.predictForPersonSegmentation=function(e){var n=this.baseModel.predict(e);return{segmentLogits:n.segmentation,heatmapScores:n.heatmapScores,offsets:n.offsets,displacementFwd:n.displacementFwd,displacementBwd:n.displacementBwd}},t.prototype.predictForPersonSegmentationAndPart=function(e){var n=this.baseModel.predict(e);return{segmentLogits:n.segmentation,partHeatmapLogits:n.partHeatmaps,heatmapScores:n.heatmapScores,offsets:n.offsets,displacementFwd:n.displacementFwd,displacementBwd:n.displacementBwd}},t.prototype.predictForMultiPersonInstanceSegmentationAndPart=function(e){var n=this.baseModel.predict(e);return{segmentLogits:n.segmentation,longOffsets:n.longOffsets,heatmapScores:n.heatmapScores,offsets:n.offsets,displacementFwd:n.displacementFwd,displacementBwd:n.displacementBwd,partHeatmaps:n.partHeatmaps}},t.prototype.segmentPersonActivation=function(e,n,r){var s=this;r===void 0&&(r=.5);var a=Er(e),o=a[0],i=a[1],u=hs(n,this.baseModel.outputStride,[o,i]),l=fs(e,u),c=l.resized,h=l.padding,p=Z(function(){var F=s.predictForPersonSegmentation(c),_=F.segmentLogits,$=F.heatmapScores,A=F.offsets,C=F.displacementFwd,M=F.displacementBwd,P=c.shape,D=P[0],V=P[1],z=Kn(_,[o,i],[D,V],[[h.top,h.bottom],[h.left,h.right]],!0);return{segmentation:ls(bt(z),r),heatmapScores:$,offsets:A,displacementFwd:C,displacementBwd:M}}),d=p.segmentation,b=p.heatmapScores,v=p.offsets,N=p.displacementFwd,x=p.displacementBwd;return c.dispose(),{segmentation:d,heatmapScores:b,offsets:v,displacementFwd:N,displacementBwd:x,padding:h,internalResolutionHeightAndWidth:u}},t.prototype.segmentPerson=function(e,n){return n===void 0&&(n=ms),ce(this,void 0,void 0,function(){var r,s,a,o,i,u,l,c,h,p,d,b,v,N,x,F,_,$;return he(this,function(A){switch(A.label){case 0:return Iu(n=Ke(Ke({},ms),n)),r=this.segmentPersonActivation(e,n.internalResolution,n.segmentationThreshold),s=r.segmentation,a=r.heatmapScores,o=r.offsets,i=r.displacementFwd,u=r.displacementBwd,l=r.padding,c=r.internalResolutionHeightAndWidth,h=s.shape,p=h[0],d=h[1],[4,s.data()];case 1:return b=A.sent(),s.dispose(),[4,ps([a,o,i,u])];case 2:return v=A.sent(),N=v[0],x=v[1],F=v[2],_=v[3],$=ds($=cs(N,x,F,_,this.baseModel.outputStride,n.maxDetections,n.scoreThreshold,n.nmsRadius),[p,d],c,l,!1),a.dispose(),o.dispose(),i.dispose(),u.dispose(),[2,{height:p,width:d,data:b,allPoses:$}]}})})},t.prototype.segmentMultiPerson=function(e,n){return n===void 0&&(n=gs),ce(this,void 0,void 0,function(){var r,s,a,o,i,u,l,c,h,p,d,b,v,N,x,F,_,$,A,C,M,P=this;return he(this,function(D){switch(D.label){case 0:return Ou(n=Ke(Ke({},gs),n)),r=Er(e),s=r[0],a=r[1],o=hs(n.internalResolution,this.baseModel.outputStride,[s,a]),i=fs(e,o),u=i.resized,l=i.padding,c=Z(function(){var V,z=P.predictForMultiPersonInstanceSegmentationAndPart(u),q=z.segmentLogits,G=z.longOffsets,X=z.heatmapScores,oe=z.offsets,pe=z.displacementFwd,Te=z.displacementBwd,De=Kn(q,[s,a],o,[[l.top,l.bottom],[l.left,l.right]],!0);return V=G,{segmentation:ls(bt(De),n.segmentationThreshold),longOffsets:V,heatmapScoresRaw:X,offsetsRaw:oe,displacementFwdRaw:pe,displacementBwdRaw:Te}}),h=c.segmentation,p=c.longOffsets,d=c.heatmapScoresRaw,b=c.offsetsRaw,v=c.displacementFwdRaw,N=c.displacementBwdRaw,[4,ps([d,b,v,N])];case 1:return x=D.sent(),F=x[0],_=x[1],$=x[2],A=x[3],C=ds(C=cs(F,_,$,A,this.baseModel.outputStride,n.maxDetections,n.scoreThreshold,n.nmsRadius),[s,a],o,l,!1),[4,_E(h,p,C,s,a,this.baseModel.outputStride,o,l,n.scoreThreshold,n.refineSteps,n.minKeypointScore,n.maxDetections)];case 2:return M=D.sent(),u.dispose(),h.dispose(),p.dispose(),d.dispose(),b.dispose(),v.dispose(),N.dispose(),[2,M]}})})},t.prototype.segmentPersonPartsActivation=function(e,n,r){var s=this;r===void 0&&(r=.5);var a=Er(e),o=a[0],i=a[1],u=hs(n,this.baseModel.outputStride,[o,i]),l=fs(e,u),c=l.resized,h=l.padding,p=Z(function(){var F=s.predictForPersonSegmentationAndPart(c),_=F.segmentLogits,$=F.partHeatmapLogits,A=F.heatmapScores,C=F.offsets,M=F.displacementFwd,P=F.displacementBwd,D=c.shape,V=D[0],z=D[1],q=Kn(_,[o,i],[V,z],[[h.top,h.bottom],[h.left,h.right]],!0),G=Kn($,[o,i],[V,z],[[h.top,h.bottom],[h.left,h.right]],!0);return{partSegmentation:NE(ls(bt(q),r),G),heatmapScores:A,offsets:C,displacementFwd:M,displacementBwd:P}}),d=p.partSegmentation,b=p.heatmapScores,v=p.offsets,N=p.displacementFwd,x=p.displacementBwd;return c.dispose(),{partSegmentation:d,heatmapScores:b,offsets:v,displacementFwd:N,displacementBwd:x,padding:h,internalResolutionHeightAndWidth:u}},t.prototype.segmentPersonParts=function(e,n){return n===void 0&&(n=ms),ce(this,void 0,void 0,function(){var r,s,a,o,i,u,l,c,h,p,d,b,v,N,x,F,_,$;return he(this,function(A){switch(A.label){case 0:return Iu(n=Ke(Ke({},ms),n)),r=this.segmentPersonPartsActivation(e,n.internalResolution,n.segmentationThreshold),s=r.partSegmentation,a=r.heatmapScores,o=r.offsets,i=r.displacementFwd,u=r.displacementBwd,l=r.padding,c=r.internalResolutionHeightAndWidth,h=s.shape,p=h[0],d=h[1],[4,s.data()];case 1:return b=A.sent(),s.dispose(),[4,ps([a,o,i,u])];case 2:return v=A.sent(),N=v[0],x=v[1],F=v[2],_=v[3],$=ds($=cs(N,x,F,_,this.baseModel.outputStride,n.maxDetections,n.scoreThreshold,n.nmsRadius),[p,d],c,l,!1),a.dispose(),o.dispose(),i.dispose(),u.dispose(),[2,{height:p,width:d,data:b,allPoses:$}]}})})},t.prototype.segmentMultiPersonParts=function(e,n){return n===void 0&&(n=gs),ce(this,void 0,void 0,function(){var r,s,a,o,i,u,l,c,h,p,d,b,v,N,x,F,_,$,A,C,M,P,D=this;return he(this,function(V){switch(V.label){case 0:return Ou(n=Ke(Ke({},gs),n)),r=Er(e),s=r[0],a=r[1],o=hs(n.internalResolution,this.baseModel.outputStride,[s,a]),i=fs(e,o),u=i.resized,l=i.padding,c=Z(function(){var z=D.predictForMultiPersonInstanceSegmentationAndPart(u),q=z.segmentLogits,G=z.longOffsets,X=z.heatmapScores,oe=z.offsets,pe=z.displacementFwd,Te=z.displacementBwd,De=z.partHeatmaps,Be=Kn(q,[s,a],o,[[l.top,l.bottom],[l.left,l.right]],!0),Ue=Kn(De,[s,a],o,[[l.top,l.bottom],[l.left,l.right]],!0),nt=G,Et=ls(bt(Be),n.segmentationThreshold),ct=function(kt){var _t=kt.shape,xt=_t[0],Ct=_t[1],tn=_t[2];return Z(function(){var rt=tm(kt),$t=ot(pn(0,tn,1,"int32"),1),ns=we(ye(rt,$t),"int32");return B(ns,[xt,Ct])})}(Ue);return{segmentation:Et,longOffsets:nt,heatmapScoresRaw:X,offsetsRaw:oe,displacementFwdRaw:pe,displacementBwdRaw:Te,partSegmentation:ct}}),h=c.segmentation,p=c.longOffsets,d=c.heatmapScoresRaw,b=c.offsetsRaw,v=c.displacementFwdRaw,N=c.displacementBwdRaw,x=c.partSegmentation,[4,ps([d,b,v,N])];case 1:return F=V.sent(),_=F[0],$=F[1],A=F[2],C=F[3],M=ds(M=cs(_,$,A,C,this.baseModel.outputStride,n.maxDetections,n.scoreThreshold,n.nmsRadius),[s,a],o,l,!1),[4,xE(h,p,x,M,s,a,this.baseModel.outputStride,o,l,n.scoreThreshold,n.refineSteps,n.minKeypointScore,n.maxDetections)];case 2:return P=V.sent(),u.dispose(),h.dispose(),p.dispose(),d.dispose(),b.dispose(),v.dispose(),N.dispose(),x.dispose(),[2,P]}})})},t.prototype.dispose=function(){this.baseModel.dispose()},t}();function PE(t){return ce(this,void 0,void 0,function(){var e,n,r,s,a,o;return he(this,function(i){switch(i.label){case 0:if(e=t.outputStride,n=t.quantBytes,r=t.multiplier,Gd==null)throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this
        model.`);return s=function(u,l,c){var h={1:"100",.75:"075",.5:"050"},p="model-stride"+u+".json";return c===4?Tu+"float/"+h[l]+"/"+p:Tu+"quant"+c+"/"+h[l]+"/"+p}(e,r,n),[4,Ei(t.modelUrl||s)];case 1:return a=i.sent(),o=new TE(a,e),[2,new hm(o)]}})})}function RE(t){return ce(this,void 0,void 0,function(){var e,n,r,s,a;return he(this,function(o){switch(o.label){case 0:if(e=t.outputStride,n=t.quantBytes,Gd==null)throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this
        model.`);return r=function(i,u){var l="model-stride"+i+".json";return u===4?Nu+"float/"+l:Nu+"quant"+u+"/"+l}(e,n),[4,Ei(t.modelUrl||r)];case 1:return s=o.sent(),a=new FE(s,e),[2,new hm(a)]}})})}function BE(t){return t===void 0&&(t=ku),ce(this,void 0,void 0,function(){return he(this,function(e){return(t=function(n){if((n=n||ku).architecture==null&&(n.architecture="MobileNetV1"),_u.indexOf(n.architecture)<0)throw new Error("Invalid architecture "+n.architecture+". Should be one of "+_u);if(n.outputStride==null&&(n.outputStride=16),xu[n.architecture].indexOf(n.outputStride)<0)throw new Error("Invalid outputStride "+n.outputStride+". Should be one of "+xu[n.architecture]+" for architecture "+n.architecture+".");if(n.multiplier==null&&(n.multiplier=1),$u[n.architecture].indexOf(n.multiplier)<0)throw new Error("Invalid multiplier "+n.multiplier+". Should be one of "+$u[n.architecture]+" for architecture "+n.architecture+".");if(n.quantBytes==null&&(n.quantBytes=4),Au.indexOf(n.quantBytes)<0)throw new Error("Invalid quantBytes "+n.quantBytes+". Should be one of "+Au+" for architecture "+n.architecture+".");return n}(t)).architecture==="ResNet50"?[2,RE(t)]:t.architecture==="MobileNetV1"?[2,PE(t)]:[2,null]})})}var co=["left_face","right_face","left_upper_arm_front","left_upper_arm_back","right_upper_arm_front","right_upper_arm_back","left_lower_arm_front","left_lower_arm_back","right_lower_arm_front","right_lower_arm_back","left_hand","right_hand","torso_front","torso_back","left_upper_leg_front","left_upper_leg_back","right_upper_leg_front","right_upper_leg_back","left_lower_leg_front","left_lower_leg_back","right_lower_leg_front","right_lower_leg_back","left_feet","right_feet"],Du=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,ki(this.mask)]})})},t.prototype.toImageData=function(){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,this.mask]})})},t.prototype.toTensor=function(){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,em(this.mask)]})})},t.prototype.getUnderlyingType=function(){return"imagedata"},t}();function LE(t){if(aa(t),t!==255)throw new Error("Foreground id must be 255 but got "+t);return"person"}function ME(t){if(aa(t),t>=co.length)throw new Error("Invalid body part value "+t);return co[t]}var zE=function(){function t(e){this.bodyPixModel=e}return t.prototype.segmentPeople=function(e,n){return ce(this,void 0,void 0,function(){var r,s,a,o;return he(this,function(i){switch(i.label){case 0:return e instanceof ImageBitmap&&((r=document.createElement("canvas")).getContext("2d").drawImage(e,0,0),e=r),n.segmentBodyParts?n.multiSegmentation?[4,this.bodyPixModel.segmentMultiPersonParts(e,n)]:[3,2]:[3,5];case 1:return a=i.sent(),[3,4];case 2:return[4,this.bodyPixModel.segmentPersonParts(e,n)];case 3:a=[i.sent()],i.label=4;case 4:return s=a.map(function(u){var l=u.data,c=u.width,h=u.height,p=new Uint8ClampedArray(c*h*4).fill(0);return l.forEach(function(d,b){d===-1?(p[4*b]=co.length,p[4*b+3]=0):(p[4*b]=d,p[4*b+3]=255)}),{maskValueToLabel:ME,mask:new Du(new ImageData(p,c,h))}}),[3,10];case 5:return n.multiSegmentation?[4,this.bodyPixModel.segmentMultiPerson(e,n)]:[3,7];case 6:return o=i.sent(),[3,9];case 7:return[4,this.bodyPixModel.segmentPerson(e,n)];case 8:o=[i.sent()],i.label=9;case 9:s=o.map(function(u){var l=u.data,c=u.width,h=u.height,p=new Uint8ClampedArray(c*h*4).fill(0);return l.forEach(function(d,b){d===0?(p[4*b]=0,p[4*b+3]=0):(p[4*b]=255,p[4*b+3]=255)}),{maskValueToLabel:LE,mask:new Du(new ImageData(p,c,h))}}),i.label=10;case 10:return[2,s]}})})},t.prototype.dispose=function(){this.bodyPixModel.dispose()},t.prototype.reset=function(){},t}();function VE(t){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,BE(t).then(function(n){return new zE(n)})]})})}var Fu={runtime:"mediapipe",modelType:"general"},jE=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,this.mask]})})},t.prototype.toImageData=function(){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,Qd(this.mask)]})})},t.prototype.toTensor=function(){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,em(this.mask)]})})},t.prototype.getUnderlyingType=function(){return"canvasimagesource"},t}();function UE(t){return aa(t),"person"}var WE=function(){function t(e){var n,r=this;this.selfieMode=!1,this.selfieSegmentationSolution=new SE({locateFile:function(s,a){return e.solutionPath?e.solutionPath.replace(/\/+$/,"")+"/"+s:a+"/"+s}}),e.modelType==="landscape"?n=1:n=0,this.selfieSegmentationSolution.setOptions({modelSelection:n,selfieMode:this.selfieMode}),this.selfieSegmentationSolution.onResults(function(s){r.segmentation=[{maskValueToLabel:UE,mask:new jE(s.segmentationMask)}]})}return t.prototype.segmentPeople=function(e,n){return ce(this,void 0,void 0,function(){var r,s;return he(this,function(a){switch(a.label){case 0:return n&&n.flipHorizontal&&n.flipHorizontal!==this.selfieMode&&(this.selfieMode=n.flipHorizontal,this.selfieSegmentationSolution.setOptions({selfieMode:this.selfieMode})),e instanceof be?(s=ImageData.bind,[4,qr(e)]):[3,2];case 1:return r=new(s.apply(ImageData,[void 0,a.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:r=e,a.label=3;case 3:return e=r,[4,this.selfieSegmentationSolution.send({image:e})];case 4:return a.sent(),[2,this.segmentation]}})})},t.prototype.dispose=function(){this.selfieSegmentationSolution.close()},t.prototype.reset=function(){this.selfieSegmentationSolution.reset(),this.segmentation=null,this.selfieMode=!1},t.prototype.initialize=function(){return this.selfieSegmentationSolution.initialize()},t}();function qE(t){return ce(this,void 0,void 0,function(){var e,n;return he(this,function(r){switch(r.label){case 0:return e=function(s){if(s==null)return Ke({},Fu);var a=Ke({},s);return a.runtime="mediapipe",a.modelType==null&&(a.modelType=Fu.modelType),a}(t),[4,(n=new WE(e)).initialize()];case 1:return r.sent(),[2,n]}})})}function HE(t,e,n,r){var s=t.width,a=t.height,o=r?-1:1,i=Math.cos(t.rotation),u=Math.sin(t.rotation),l=t.xCenter,c=t.yCenter,h=1/e,p=1/n,d=new Array(16);return d[0]=s*i*o*h,d[1]=-a*u*h,d[2]=0,d[3]=(-.5*s*i*o+.5*a*u+l)*h,d[4]=s*u*o*p,d[5]=a*i*p,d[6]=0,d[7]=(-.5*a*i-.5*s*u*o+c)*p,d[8]=0,d[9]=0,d[10]=s*h,d[11]=0,d[12]=0,d[13]=0,d[14]=0,d[15]=1,function(b){if(b.length!==16)throw new Error("Array length must be 16 but got "+b.length);return[[b[0],b[1],b[2],b[3]],[b[4],b[5],b[6],b[7]],[b[8],b[9],b[10],b[11]],[b[12],b[13],b[14],b[15]]]}(d)}function fm(t){return t instanceof be?{height:t.shape[0],width:t.shape[1]}:{height:t.height,width:t.width}}function xa(t,e){S(t.width!==0,function(){return e+" width cannot be 0."}),S(t.height!==0,function(){return e+" height cannot be 0."})}function GE(t,e){var n=function(r,s,a,o){var i=s-r,u=o-a;if(i===0)throw new Error("Original min and max are both "+r+", range cannot be 0.");var l=u/i;return{scale:l,offset:a-r*l}}(0,255,e[0],e[1]);return Z(function(){return Y(U(t,n.scale),n.offset)})}function KE(t,e,n){var r=e.outputTensorSize,s=e.keepAspectRatio,a=e.borderMode,o=e.outputTensorFloatRange,i=fm(t),u=function(p,d){return d?{xCenter:d.xCenter*p.width,yCenter:d.yCenter*p.height,width:d.width*p.width,height:d.height*p.height,rotation:d.rotation}:{xCenter:.5*p.width,yCenter:.5*p.height,width:p.width,height:p.height,rotation:0}}(i,n),l=function(p,d,b){if(b===void 0&&(b=!1),!b)return{top:0,left:0,right:0,bottom:0};var v=d.height,N=d.width;xa(d,"targetSize"),xa(p,"roi");var x,F,_=v/N,$=p.height/p.width,A=0,C=0;return _>$?(x=p.width,F=p.width*_,C=(1-$/_)/2):(x=p.height/_,F=p.height,A=(1-_/$)/2),p.width=x,p.height=F,{top:C,left:A,right:A,bottom:C}}(u,r,s),c=HE(u,i.width,i.height,!1),h=Z(function(){var p,d=(p=t)instanceof be?p:Vs(p),b=$n(function(x,F,_){return xa(_,"inputResolution"),[1/_.width*x[0][0]*F.width,1/_.height*x[0][1]*F.width,x[0][3]*F.width,1/_.width*x[1][0]*F.height,1/_.height*x[1][1]*F.height,x[1][3]*F.height,0,0]}(c,i,r),[1,8]),v=a==="zero"?"constant":"nearest",N=Rn.transform(ot(we(d,"float32")),b,"bilinear",v,0,[r.height,r.width]);return o!=null?GE(N,o):N});return{imageTensor:h,padding:l,transformationMatrix:c}}function XE(t,e,n){return Z(function(){var r=bt(t,[0]),s=r.shape[2];if(s===1){var a=r;switch(e.activation){case"none":break;case"sigmoid":a=Vt(a);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported ("+e.activation+")")}var o=n?Rn.resizeBilinear(a,[n.height,n.width]):a;return bt(o,[2])}throw new Error("Unsupported number of tensor channels "+s)})}var Cu={runtime:"tfjs",modelType:"general",modelUrl:"https://tfhub.dev/mediapipe/tfjs-model/selfie_segmentation/general/1"},Pu={flipHorizontal:!1},YE={outputTensorSize:{width:256,height:256},keepAspectRatio:!1,borderMode:"zero",outputTensorFloatRange:[0,1]},ZE={outputTensorSize:{width:256,height:144},keepAspectRatio:!1,borderMode:"zero",outputTensorFloatRange:[0,1]},JE={activation:"none"},QE=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,ki(this.mask)]})})},t.prototype.toImageData=function(){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,Qd(this.mask)]})})},t.prototype.toTensor=function(){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,this.mask]})})},t.prototype.getUnderlyingType=function(){return"tensor"},t}();function ek(t){return aa(t),"person"}var Mr,tk=function(){function t(e,n){this.modelType=e,this.model=n}return t.prototype.segmentPeople=function(e,n){return ce(this,void 0,void 0,function(){var r,s=this;return he(this,function(a){return n=function(o){if(o==null)return Ke({},Pu);var i=Ke({},o);return i.flipHorizontal==null&&(i.flipHorizontal=Pu.flipHorizontal),i}(n),e==null?(this.reset(),[2,[]]):(r=Z(function(){var o=KE(e,s.modelType==="general"?YE:ZE).imageTensor,i=Ee(s.model.predict(o),[0,0,0,1],-1),u=fm(e),l=XE(i,JE,u),c=ot(l,2),h=zn(c,[[0,0],[0,0],[0,1]]);return ai(h,[[0,0],[0,0],[0,2]],"symmetric")}),[2,[{maskValueToLabel:ek,mask:new QE(r)}]])})})},t.prototype.dispose=function(){this.model.dispose()},t.prototype.reset=function(){},t}();function nk(t){return ce(this,void 0,void 0,function(){var e,n,r;return he(this,function(s){switch(s.label){case 0:return e=function(a){if(a==null)return Ke({},Cu);var o=Ke({},a);if(o.runtime="tfjs",o.modelType==null&&(o.modelType=Cu.modelType),o.modelType!=="general"&&o.modelType!=="landscape")throw new Error("Model type must be one of general or landscape, but got "+o.modelType);return o.modelUrl==null&&(o.modelType==="general"?o.modelUrl="https://tfhub.dev/mediapipe/tfjs-model/selfie_segmentation/general/1":o.modelUrl="https://tfhub.dev/mediapipe/tfjs-model/selfie_segmentation/landscape/1"),o}(t),n=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,Ei(e.modelUrl,{fromTFHub:n})];case 1:return r=s.sent(),[2,new tk(e.modelType,r)]}})})}function rk(t,e){return ce(this,void 0,void 0,function(){var n,r;return he(this,function(s){switch(t){case Mr.MediaPipeSelfieSegmentation:if(n=void 0,(r=e)!=null){if(r.runtime==="tfjs")return[2,nk(r)];if(r.runtime==="mediapipe")return[2,qE(r)];n=r.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got "+n);case Mr.BodyPix:return[2,VE(r=e)];default:throw new Error(t+" is not a supported model name.")}})})}(function(t){t.BodyPix="BodyPix",t.MediaPipeSelfieSegmentation="MediaPipeSelfieSegmentation"})(Mr||(Mr={}));var sk="blurred",ak="blurred-mask",ok="mask",ik="draw-image",$a={};function ia(t){if(typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&t instanceof OffscreenCanvas||typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)return function(e){if("offsetHeight"in e&&e.offsetHeight!==0&&"offsetWidth"in e&&e.offsetWidth!==0)return[e.offsetHeight,e.offsetWidth];if(e.height!=null&&e.width!=null)return[e.height,e.width];throw new Error("HTMLImageElement must have height and width attributes set.")}(t);if(typeof ImageData<"u"&&t instanceof ImageData)return[t.height,t.width];if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)return function(e){return e.hasAttribute("height")&&e.hasAttribute("width")?[e.height,e.width]:[e.videoHeight,e.videoWidth]}(t);if(t instanceof be)return[t.shape[0],t.shape[1]];throw new Error("error: Unknown input type: "+t+".")}function pm(t){return $a[t]||($a[t]=function(){if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(0,0);throw new Error("Cannot create a canvas in this context")}()),$a[t]}function dm(t,e){var n=pm(e);return function(r,s){s.width=r.width,s.height=r.height,s.getContext("2d").putImageData(r,0,0)}(t,n),n}function ts(t,e,n,r,s,a){return ce(this,void 0,void 0,function(){var o,i,u,l;return he(this,function(c){switch(c.label){case 0:return e instanceof be?[4,qr(e)]:[3,2];case 1:o=c.sent(),i=ia(e),u=i[0],l=i[1],e=new ImageData(o,l,u),c.label=2;case 2:return e instanceof ImageData&&(e=dm(e,ik)),s==null||a==null?t.drawImage(e,n,r):t.drawImage(e,n,r,s,a),[2]}})})}function uk(t,e){return ce(this,void 0,void 0,function(){var n,r,s;return he(this,function(a){switch(a.label){case 0:return n=ia(t),r=n[0],s=n[1],e.width=s,e.height=r,[4,ts(e.getContext("2d"),t,0,0,s,r)];case 1:return a.sent(),[2]}})})}function lk(t){var e=t.getContext("2d");e.scale(-1,1),e.translate(-t.width,0)}function Ru(t,e,n){return ce(this,void 0,void 0,function(){return he(this,function(r){switch(r.label){case 0:return t.globalCompositeOperation=n,[4,ts(t,e,0,0)];case 1:return r.sent(),[2]}})})}function ck(t,e,n){return ce(this,void 0,void 0,function(){var r,s,a,o,i,u,l,c;return he(this,function(h){switch(h.label){case 0:for(r=t.getContext("2d"),s=0,a=5,o=1/(2*Math.PI*a*a),i=n<3?1:2,l=-n;l<=n;l+=i)for(c=-n;c<=n;c+=i)u=o*Math.exp(-(c*c+l*l)/(2*a*a)),s+=u;l=-n,h.label=1;case 1:if(!(l<=n))return[3,6];c=-n,h.label=2;case 2:return c<=n?(r.globalAlpha=o*Math.exp(-(c*c+l*l)/(2*a*a))/s*n,[4,ts(r,e,c,l)]):[3,5];case 3:h.sent(),h.label=4;case 4:return c+=i,[3,2];case 5:return l+=i,[3,1];case 6:return r.globalAlpha=1,[2]}})})}function hk(t,e,n){return ce(this,void 0,void 0,function(){var r,s,a,o;return he(this,function(i){switch(i.label){case 0:return r=ia(t),s=r[0],a=r[1],o=n.getContext("2d"),n.width=a,n.height=s,o.clearRect(0,0,a,s),o.save(),/^((?!chrome|android).)*safari/i.test(navigator.userAgent)?[4,ck(n,t,e)]:[3,2];case 1:return i.sent(),[3,4];case 2:return o.filter="blur("+e+"px)",[4,ts(o,t,0,0,a,s)];case 3:i.sent(),i.label=4;case 4:return o.restore(),[2]}})})}function mm(t,e,n){return ce(this,void 0,void 0,function(){var r;return he(this,function(s){switch(s.label){case 0:return r=pm(n),e!==0?[3,2]:[4,uk(t,r)];case 1:return s.sent(),[3,4];case 2:return[4,hk(t,e,r)];case 3:s.sent(),s.label=4;case 4:return[2,r]}})})}function fk(t,e,n,r,s,a){a===void 0&&(a={r:0,g:255,b:255,a:255});for(var o=-s;o<=s;o++)for(var i=-s;i<=s;i++)if(o!==0&&i!==0){var u=(e+o)*r+(n+i);t[4*u+0]=a.r,t[4*u+1]=a.g,t[4*u+2]=a.b,t[4*u+3]=a.a}}function pk(t,e,n,r,s,a,o){o===void 0&&(o=1);for(var i=0,u=-o;u<=o;u++)for(var l=-o;l<=o;l++)if(u!==0&&l!==0){var c=(e+u)*r+(n+l);(!s[t[4*c]]||t[4*c+3]<a)&&(i+=1)}return i>0}function dk(t,e,n,r,s,a){return e===void 0&&(e={r:0,g:0,b:0,a:0}),n===void 0&&(n={r:0,g:0,b:0,a:255}),r===void 0&&(r=!1),s===void 0&&(s=.5),a===void 0&&(a=Array.from(Array(256).keys())),ce(this,void 0,void 0,function(){var o,i,u,l,c,h,p,d,b,v,N,x,F,_;return he(this,function($){switch($.label){case 0:return(o=Array.isArray(t)?t:[t]).length===0?[2,null]:[4,Promise.all(o.map(function(A){return A.mask.toImageData()}))];case 1:for(i=$.sent(),u=i[0],l=u.width,c=u.height,h=new Uint8ClampedArray(l*c*4),p=Math.round(255*s),d=new Array(256).fill(!1),a.forEach(function(A){return d[A]=!0}),b=0;b<c;b++)for(v=0;v<l;v++)for(h[4*(N=b*l+v)+0]=n.r,h[4*N+1]=n.g,h[4*N+2]=n.b,h[4*N+3]=n.a,x=0,F=i;x<F.length;x++)_=F[x],d[_.data[4*N]]&&_.data[4*N+3]>=p&&(h[4*N]=e.r,h[4*N+1]=e.g,h[4*N+2]=e.b,h[4*N+3]=e.a,r&&b-1>=0&&b+1<c&&v-1>=0&&v+1<l&&pk(_.data,b,v,l,d,p)&&fk(h,b,v,l,1));return[2,new ImageData(h,l,c)]}})})}function mk(t,e,n){return ce(this,void 0,void 0,function(){var r,s;return he(this,function(a){switch(a.label){case 0:return[4,dk(t,{r:0,g:0,b:0,a:255},{r:0,g:0,b:0,a:0},!1,e)];case 1:return r=a.sent(),s=dm(r,ok),n===0?[2,s]:[2,mm(s,n,ak)]}})})}function gk(t,e,n,r,s,a,o){return r===void 0&&(r=.5),s===void 0&&(s=3),a===void 0&&(a=3),o===void 0&&(o=!1),ce(this,void 0,void 0,function(){var i,u,l,c,h,p;return he(this,function(d){switch(d.label){case 0:return[4,mm(e,s,sk)];case 1:return i=d.sent(),t.width=i.width,t.height=i.height,u=t.getContext("2d"),Array.isArray(n)&&n.length===0?(u.drawImage(i,0,0),[2]):[4,mk(n,r,a)];case 2:return l=d.sent(),u.save(),o&&lk(t),c=ia(e),h=c[0],p=c[1],[4,ts(u,e,0,0,p,h)];case 3:return d.sent(),[4,Ru(u,l,"destination-in")];case 4:return d.sent(),[4,Ru(u,i,"destination-over")];case 5:return d.sent(),u.restore(),[2]}})})}var gm,ym,Jn,Ss,bm,wm,vm,Sm;({camera:Ss}=Xn);gm="video";Jn=0;Kt.camera_visible=!0;document.addEventListener("visibilitychange",()=>Kt.camera_visible=!document.hidden);wm=.5;ym=20;bm=3;Sm=`precision highp float;
attribute vec2 pos;
attribute vec2 uv;
varying vec2 vUv;
uniform float flipX;
uniform float flipY;

void main(void) {
  vUv = uv;
  gl_Position = vec4(pos.x*flipX, pos.y*flipY, 0.0, 1.0);
}`;vm=`precision highp float;
uniform vec2 singleStepOffset;
uniform sampler2D texture;
uniform vec4 params;
uniform float brightness;
varying vec2 vUv;
const highp vec3 W = vec3(0.299,0.587,0.114);
const mat3 saturateMatrix = mat3(1.1102,-0.0598,-0.061,-0.0774,1.0826,-0.1186,-0.0228,-0.0228,1.1772);
vec2 blurCoordinates[24];

float hardLight(float color){
  if(color <= 0.5){
  color = color * color * 2.0;
  } else {
  color = 1.0 - ((1.0 - color)*(1.0 - color) * 2.0);
  }
  return color;
}
void main(){
  vec3 centralColor = texture2D(texture, vUv).rgb;
  blurCoordinates[0] = vUv.xy + singleStepOffset * vec2(0.0, -10.0);
  blurCoordinates[1] = vUv.xy + singleStepOffset * vec2(0.0, 10.0);
  blurCoordinates[2] = vUv.xy + singleStepOffset * vec2(-10.0, 0.0);
  blurCoordinates[3] = vUv.xy + singleStepOffset * vec2(10.0, 0.0);
  blurCoordinates[4] = vUv.xy + singleStepOffset * vec2(5.0, -8.0);
  blurCoordinates[5] = vUv.xy + singleStepOffset * vec2(5.0, 8.0);
  blurCoordinates[6] = vUv.xy + singleStepOffset * vec2(-5.0, 8.0);
  blurCoordinates[7] = vUv.xy + singleStepOffset * vec2(-5.0, -8.0);
  blurCoordinates[8] = vUv.xy + singleStepOffset * vec2(8.0, -5.0);
  blurCoordinates[9] = vUv.xy + singleStepOffset * vec2(8.0, 5.0);
  blurCoordinates[10] = vUv.xy + singleStepOffset * vec2(-8.0, 5.0);
  blurCoordinates[11] = vUv.xy + singleStepOffset * vec2(-8.0, -5.0);
  blurCoordinates[12] = vUv.xy + singleStepOffset * vec2(0.0, -6.0);
  blurCoordinates[13] = vUv.xy + singleStepOffset * vec2(0.0, 6.0);
  blurCoordinates[14] = vUv.xy + singleStepOffset * vec2(6.0, 0.0);
  blurCoordinates[15] = vUv.xy + singleStepOffset * vec2(-6.0, 0.0);
  blurCoordinates[16] = vUv.xy + singleStepOffset * vec2(-4.0, -4.0);
  blurCoordinates[17] = vUv.xy + singleStepOffset * vec2(-4.0, 4.0);
  blurCoordinates[18] = vUv.xy + singleStepOffset * vec2(4.0, -4.0);
  blurCoordinates[19] = vUv.xy + singleStepOffset * vec2(4.0, 4.0);
  blurCoordinates[20] = vUv.xy + singleStepOffset * vec2(-2.0, -2.0);
  blurCoordinates[21] = vUv.xy + singleStepOffset * vec2(-2.0, 2.0);
  blurCoordinates[22] = vUv.xy + singleStepOffset * vec2(2.0, -2.0);
  blurCoordinates[23] = vUv.xy + singleStepOffset * vec2(2.0, 2.0);

  float sampleColor = centralColor.g * 22.0;
  sampleColor += texture2D(texture, blurCoordinates[0]).g;
  sampleColor += texture2D(texture, blurCoordinates[1]).g;
  sampleColor += texture2D(texture, blurCoordinates[2]).g;
  sampleColor += texture2D(texture, blurCoordinates[3]).g;
  sampleColor += texture2D(texture, blurCoordinates[4]).g;
  sampleColor += texture2D(texture, blurCoordinates[5]).g;
  sampleColor += texture2D(texture, blurCoordinates[6]).g;
  sampleColor += texture2D(texture, blurCoordinates[7]).g;
  sampleColor += texture2D(texture, blurCoordinates[8]).g;
  sampleColor += texture2D(texture, blurCoordinates[9]).g;
  sampleColor += texture2D(texture, blurCoordinates[10]).g;
  sampleColor += texture2D(texture, blurCoordinates[11]).g;
  sampleColor += texture2D(texture, blurCoordinates[12]).g * 2.0;
  sampleColor += texture2D(texture, blurCoordinates[13]).g * 2.0;
  sampleColor += texture2D(texture, blurCoordinates[14]).g * 2.0;
  sampleColor += texture2D(texture, blurCoordinates[15]).g * 2.0;
  sampleColor += texture2D(texture, blurCoordinates[16]).g * 2.0;
  sampleColor += texture2D(texture, blurCoordinates[17]).g * 2.0;
  sampleColor += texture2D(texture, blurCoordinates[18]).g * 2.0;
  sampleColor += texture2D(texture, blurCoordinates[19]).g * 2.0;
  sampleColor += texture2D(texture, blurCoordinates[20]).g * 3.0;
  sampleColor += texture2D(texture, blurCoordinates[21]).g * 3.0;
  sampleColor += texture2D(texture, blurCoordinates[22]).g * 3.0;
  sampleColor += texture2D(texture, blurCoordinates[23]).g * 3.0;
  sampleColor = sampleColor / 62.0;
  float highPass = centralColor.g - sampleColor + 0.5;
  
  for(int i = 0; i < 5;i++){
    highPass = hardLight(highPass);
  }

  float luminance = dot(centralColor, W);
  float alpha = pow(luminance, params.r);
  vec3 smoothColor = centralColor + (centralColor-vec3(highPass))*alpha*0.1;

  smoothColor.r = clamp(pow(smoothColor.r, params.g),0.0,1.0);
  smoothColor.g = clamp(pow(smoothColor.g, params.g),0.0,1.0);
  smoothColor.b = clamp(pow(smoothColor.b, params.g),0.0,1.0);
  
  vec3 screen = vec3(1.0) - (vec3(1.0)-smoothColor) * (vec3(1.0)-centralColor);
  vec3 lighten = max(smoothColor, centralColor);
  vec3 softLight = 2.0 * centralColor*smoothColor + centralColor*centralColor - 2.0 * centralColor*centralColor * smoothColor;
  
  gl_FragColor = vec4(mix(centralColor, screen, alpha), 1.0);
  gl_FragColor.rgb = mix(gl_FragColor.rgb, lighten, alpha);
  gl_FragColor.rgb = mix(gl_FragColor.rgb, softLight, params.b);

  vec3 satColor = gl_FragColor.rgb * saturateMatrix;
  gl_FragColor.rgb = mix(gl_FragColor.rgb, satColor, params.a);
  gl_FragColor.rgb = vec3(gl_FragColor.rgb + vec3(brightness));
}`;var yk={setup:()=>{var t,e,n,r,s,a,o,i,u,l,c,h,p,d,b,v,N,x,F,_,$,A,C,M;return A=Rt(),l=Rt(),N=Rt(),C=Rt(),o=Rt(localStorage.beauty!==void 0?localStorage.beauty-0:0),a=Rt(0),x=Rt(localStorage.mirror!==void 0?localStorage.mirror-0:0),p=Rt("..."),F=void 0,u=void 0,c=void 0,d=void 0,Jn!==void 0&&window.cancelAnimationFrame(Jn),Jn=void 0,i={beautyParams:{beauty:.59,brightness:.5,ruddy:.54},brightness:void 0,params:void 0,singleStepOffset:void 0,flipX:void 0,flipY:void 0,pos:0,uv:0,initialled:!1,sourceTexture:void 0,vertexBuffer:void 0,program:void 0,width:0,height:0,applied:!1},r=()=>{var P,D,V,z,q;i.initialled!==!0&&(q=d.createShader(d.VERTEX_SHADER),P=d.createShader(d.FRAGMENT_SHADER),d.shaderSource(q,Sm),d.shaderSource(P,vm),d.compileShader(q),d.compileShader(P),d.getShaderParameter(q,d.COMPILE_STATUS)||console.error("vtx_shader init failed",d.getShaderInfoLog(q)),d.getShaderParameter(P,d.COMPILE_STATUS)||console.error("frag_shader init failed",d.getShaderInfoLog(P)),D=d.createProgram(),d.attachShader(D,q),d.attachShader(D,P),d.linkProgram(D),d.useProgram(D),i.program=D,i.pos=d.getAttribLocation(D,"pos"),i.uv=d.getAttribLocation(D,"uv"),i.singleStepOffset=d.getUniformLocation(D,"singleStepOffset"),i.params=d.getUniformLocation(D,"params"),i.brightness=d.getUniformLocation(D,"brightness"),i.flipX=d.getUniformLocation(D,"flipX"),i.flipY=d.getUniformLocation(D,"flipY"),V=Float32Array.BYTES_PER_ELEMENT,z=4*V,d.enableVertexAttribArray(i.pos),d.vertexAttribPointer(i.pos,2,d.FLOAT,!1,z,0),d.enableVertexAttribArray(i.uv),d.vertexAttribPointer(i.uv,2,d.FLOAT,!1,z,2*V),i.initialled=!0)},s=()=>{var P,D;i.vertexBuffer===void 0&&(D=new Float32Array([-1,-1,0,1,1,-1,1,1,-1,1,0,0,-1,1,0,0,1,-1,1,1,1,1,1,0]),i.vertexBuffer=d.createBuffer(),d.bindBuffer(d.ARRAY_BUFFER,i.vertexBuffer),d.bufferData(d.ARRAY_BUFFER,D,d.STATIC_DRAW),d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0)),d.viewport(0,0,i.width,i.height),d.bindTexture(d.TEXTURE_2D,i.sourceTexture),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.NEAREST),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,d.NEAREST),i.applied===!0?d.texSubImage2D(d.TEXTURE_2D,0,0,0,d.RGB,d.UNSIGNED_BYTE,A.value):(d.texImage2D(d.TEXTURE_2D,0,d.RGB,d.RGB,d.UNSIGNED_BYTE,A.value),i.applied=!0),r(),d.uniform2f(i.singleStepOffset,2/i.width,2/i.height),P=new Float32Array([1-.8*i.beautyParams.beauty,1-.6*i.beautyParams.beauty,.1+.45*i.beautyParams.ruddy,.1+.45*i.beautyParams.ruddy]),d.uniform4fv(i.params,P),d.uniform1f(i.brightness,.12*i.beautyParams.brightness),d.bindTexture(d.TEXTURE_2D,i.sourceTexture),d.bindFramebuffer(d.FRAMEBUFFER,null),d.uniform1f(i.flipX,1),d.uniform1f(i.flipY,1),d.drawArrays(d.TRIANGLES,0,6)},e=async P=>{for(var D,V;;){try{V=await ng(P)}catch(z){D=z,console.error(P,D),p.value=""+{audio:"",video:""}[P],await sg(1e3);continue}return V}},_=async()=>{var P,D,V;F===void 0&&(P=Mr.MediaPipeSelfieSegmentation,V="/mediapipe",D={runtime:"mediapipe",solutionPath:V,modelType:"general"},F=await rk(P,D))},h=async()=>{var P,D,V,z,q,G;try{A.value.readyState===4&&(p.value=!1,u===void 0&&(u=l.value.getContext("2d"),l.value.width=A.value.videoWidth,l.value.height=A.value.videoHeight),d===void 0&&(c=new OffscreenCanvas(A.value.videoWidth,A.value.videoHeight),d=c.getContext("webgl"),i.sourceTexture=d.createTexture(),i.width=A.value.videoWidth,i.height=A.value.videoHeight),o.value-0===1?(s(),q=c):q=A.value,D=x.value-0,a.value-0===0?(u.save(),V=D===1?-1:1,G=D===1?-1*l.value.width:0,u.scale(V,1),u.drawImage(q,G,0),u.restore()):(await _(),z=await F.segmentPeople(q),await gk(l.value,q,z,wm,ym,bm,D===1)))}catch(X){P=X,console.error(P)}Jn=window.requestAnimationFrame(h)},b=Kt.src==="camera",M=function(P){var D,V;D=0,V=!1,document.onmousedown=z=>{V=!1,z.target===P&&(V=!0,Ss.record_ori_height(),{screenY:D}=z,document.onmousemove=q=>{var G,X;!V||({screenX:G,screenY:X}=q,Ss.zoom_window(D-X))},document.onmouseup=q=>{V=!1,document.onmousemove=null,document.onmouseup=null})}},Wm(async()=>{var P,D,V,z,q,G,X,oe,pe,Te;if(p.value="...",ag(N.value),M(C.value),X=await e(gm),A.value.srcObject=X,G=l.value,b){V={},q=!1;try{oe=await eg(Kt.sys_audio)}catch(De){p=De,console.error("camera mode: ",p),oe=[],await Xn.confirm.show_err("","",{:""+p},"","")}try{D=await e("audio"),q=!0}catch(De){p=De,q=!1,console.error("camera: failed to get audio from:",localStorage.audio,"err:",p),V={:""+p,:localStorage.audio}}await Xn.permission("microphone")&&(q=!1,V={:"",:localStorage.audio}),z=D?D.getTracks():[],pe=G.captureStream(30),Te=pe?pe.getVideoTracks():[],P=X?X.getVideoTracks():[],P=P.concat(Te),setTimeout(async()=>{var De;De=new MediaStream([...Te,...tg(z,oe)]),qm(async()=>{var Be,Ue,nt,Et,ct;ct=!!Kt.video;for(Ue of P)Ue.enabled=ct;Be=!!Kt.audio;for(Ue of z)Ue.enabled=Be;nt=!!localStorage.recing,nt&&Be&&!q&&(await Xn.confirm.show_err("","",V)?Xn.recbar.send_quick_stop():Xn.recbar.send_quick_resume(),Kt.audio=""),Et=Kt.sys_audio;for(Ue of oe)Ue.enabled=Et}),(await Hm(()=>import("./$..js"),["$..js","1.js","$5.js","c.js","2.js","7.js","3.js","0.js","v.js","e.js","d.css","q.js"])).default(De,z)})}Jn=window.requestAnimationFrame(h)}),$=Rt(outerWidth),n=()=>{localStorage.beauty=(o.value=!o.value)-0},t=()=>{a.value=1-a.value},v=Rt(!b),{v:A,cvs:l,main:N,size:$,mirror:x,beauty:o,background:a,err:p,is_circle:v,zoom:C,w:P=>{localStorage.face_area_size=P,$.value=P,Ss.size(P)},turn:()=>{localStorage.mirror=(x.value=!x.value)-0},makeup:()=>{n()},blur:()=>{t()},x:()=>{Kt.video=""}}}};const jn=t=>(Ym("data-v-65ca6ff2"),t=t(),Zm(),t),bk={class:"zoom",ref:"zoom"},wk={style:{display:"none"},autoplay:"",ref:"v"},vk={ref:"cvs",id:"canvasOutput"},Sk=jn(()=>Ne("svg",{fill:"none",height:"11",viewBox:"0 0 10 11",width:"10",xmlns:"http://www.w3.org/2000/svg"},[Ne("circle",{cx:"5",cy:"5.5",opacity:"0.6",r:"4.5",stroke:"var(--c)"})],-1)),Nk=jn(()=>Ne("svg",{class:"now",fill:"none",height:"24",viewBox:"0 0 24 24",width:"24",xmlns:"http://www.w3.org/2000/svg"},[Ne("circle",{cx:"12",cy:"12",fill:"var(--c)",opacity:"0.7",r:"4.5",stroke:"var(--c)"})],-1)),Tk=[Sk,Nk],Ek=jn(()=>Ne("svg",{fill:"none",height:"15",viewBox:"0 0 14 15",width:"14",xmlns:"http://www.w3.org/2000/svg"},[Ne("circle",{cx:"7",cy:"7.5",opacity:"0.7",r:"6.5",stroke:"var(--c)"})],-1)),kk=jn(()=>Ne("svg",{class:"now",fill:"none",height:"25",viewBox:"0 0 24 25",width:"24",xmlns:"http://www.w3.org/2000/svg"},[Ne("circle",{cx:"12",cy:"12.5",fill:"var(--c)",opacity:"0.7",r:"6.5",stroke:"var(--c)"})],-1)),_k=[Ek,kk],xk=jn(()=>Ne("svg",{fill:"none",height:"25",viewBox:"0 0 24 25",width:"24",xmlns:"http://www.w3.org/2000/svg"},[Ne("g",{opacity:"0.6"},[Ne("path",{d:"M10 18.5V6.5L3 18.5H10Z",fill:"var(--c)",stroke:"var(--c)","stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"1.5"}),Ne("path",{d:"M14 18.5V6.5L21 18.5H14Z",stroke:"var(--c)","stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"1.5"})])],-1)),$k=[xk],Ak=Jm('<svg fill="none" height="25" viewBox="0 0 24 25" width="24" xmlns="http://www.w3.org/2000/svg" data-v-65ca6ff2><g opacity="0.6" data-v-65ca6ff2><circle cx="9" cy="10.5" r="1" fill="var(--c)" data-v-65ca6ff2></circle><circle cx="15" cy="10.5" r="1" fill="var(--c)" data-v-65ca6ff2></circle><path d="M19.5448 9.83333C19.8396 10.6674 20 11.565 20 12.5C20 16.9183 16.4183 20.5 12 20.5C7.58172 20.5 4 16.9183 4 12.5C4 8.08172 7.58172 4.5 12 4.5C12.935 4.5 13.8326 4.66041 14.6667 4.95522" stroke="var(--c)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-v-65ca6ff2></path><path d="M15.2427 14.7427C13.5858 16.3995 10.8995 16.3995 9.24268 14.7427" stroke="var(--c)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-v-65ca6ff2></path><path fill-rule="evenodd" clip-rule="evenodd" d="M17.5 4.5C18.0509 5.90137 18.5605 6.48753 20 7C18.5605 7.51247 18.0509 8.09863 17.5 9.5C16.9875 8.06046 16.4014 7.55095 15 7C16.4014 6.44905 16.9875 5.93954 17.5 4.5Z" fill="var(--c)" data-v-65ca6ff2></path></g></svg>',1),Ik=[Ak],Ok=jn(()=>Ne("svg",{fill:"none",height:"25",viewBox:"0 0 24 25",width:"24",xmlns:"http://www.w3.org/2000/svg"},[Ne("g",{opacity:"0.6"},[Ne("path",{d:"M19 5.5H12.875M19 5.5L5 19.5M19 5.5V11.625M5 19.5V13.375M5 19.5H11.125M5 13.375V10.75V8.5C5 6.84315 6.34315 5.5 8 5.5H10.25H12.875M5 13.375L12.875 5.5M19 11.625L11.125 19.5M19 11.625V14.25V16.5C19 18.1569 17.6569 19.5 16 19.5H13.75H11.125",stroke:"var(--c)","stroke-width":"1.5","stroke-linecap":"round","stroke-linejoin":"round"})])],-1)),Dk=[Ok],Fk=jn(()=>Ne("svg",{fill:"none",height:"25",viewBox:"0 0 24 25",width:"24",xmlns:"http://www.w3.org/2000/svg"},[Ne("g",{opacity:"0.6"},[Ne("path",{d:"M16 8.5L8 16.5",stroke:"var(--c)","stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"1.5"}),Ne("path",{d:"M16 16.5L8 8.5",stroke:"var(--c)","stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"1.5"})])],-1)),Ck=[Fk];function Pk(t,e){return Xm(),Gm("main",{ref:"main",class:Gn({err:t.err!=!1,is_circle:t.is_circle==!0})},[Ne("a",bk,null,512),Ne("h3",null,Km(t.err),1),Ne("video",wk,null,512),Ne("canvas",vk,null,512),Ne("nav",null,[Ne("a",{class:Gn(["circle",{now:t.size<=250}]),onClick:e[0]||(e[0]=n=>t.w(204))},Tk,2),Ne("a",{class:Gn(["circle",{now:t.size>=310}]),onClick:e[1]||(e[1]=n=>t.w(324))},_k,2),Ne("a",{class:Gn({mirror:t.mirror}),onClick:e[2]||(e[2]=(...n)=>t.turn&&t.turn(...n))},$k,2),Ne("a",{class:Gn({beauty:t.beauty}),onClick:e[3]||(e[3]=(...n)=>t.makeup&&t.makeup(...n))},Ik,2),Ne("a",{class:Gn({background:t.background}),onClick:e[4]||(e[4]=(...n)=>t.blur&&t.blur(...n))},Dk,2),Ne("a",{onClick:e[5]||(e[5]=(...n)=>t.x&&t.x(...n))},Ck)])],2)}var Hk=Qm(yk,[["render",Pk],["__scopeId","data-v-65ca6ff2"]]);export{Hk as default};
