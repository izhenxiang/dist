import{s as tn,o as Um,k as Wm,l as qm,a as Hm,e as Ne,t as Gm,m as Hn,d as Km,p as Xm,i as Ym,q as Zm,_ as Jm}from"./a.js";import{c as Gn}from"./q.js";import{g as Qm,m as eg,a as tg}from"./8.js";import{i as ng}from"./0.js";import{c as Bt}from"./l.js";import"./f.js";import"./-.js";import"./.js";import"./o.js";function rg(t,e){return e.forEach(function(n){n&&typeof n!="string"&&!Array.isArray(n)&&Object.keys(n).forEach(function(r){if(r!=="default"&&!(r in t)){var s=Object.getOwnPropertyDescriptor(n,r);Object.defineProperty(t,r,s.get?s:{enumerable:!0,get:function(){return n[r]}})}})}),Object.freeze(Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}))}var sg=t=>new Promise(e=>setTimeout(e,t)),ag=t=>{};const og=1e-7,ig=1e-4;class ug{constructor(e,n){this.backend=e,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,n){this.dataIdsCount++,this.data.set(e,n)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Pu{refCount(e){return ut("refCount")}incRef(e){return ut("incRef")}timerAvailable(){return!0}time(e){return ut("time")}read(e){return ut("read")}readSync(e){return ut("readSync")}readToGPU(e,n){return ut("readToGPU")}numDataIds(){return ut("numDataIds")}disposeData(e,n){return ut("disposeData")}write(e,n,r){return ut("write")}move(e,n,r,s,a){return ut("move")}memory(){return ut("memory")}floatPrecision(){return ut("floatPrecision")}epsilon(){return this.floatPrecision()===32?og:ig}dispose(){return ut("dispose")}}function ut(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Ru(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,vs(t,e,n)}function lg(t,e){if(t.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${t.length}Second array length was ${e.length}`);let n=t.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,vs(t,n,r),vs(e,n,r)}function _r(t,e,n){return Math.max(t,Math.min(e,n))}function cg(t){return t%2===0?t:t+1}function vs(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function hg(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function fg(t,e){const n=Math.random();return e*n+(1-n)*t}function pg(t,e){let n=0;for(let r=0;r<t.length;r++){const s=Number(t[r])-Number(e[r]);n+=s*s}return n}function S(t,e){if(!t)throw new Error(typeof e=="string"?e:e())}function Je(t,e,n=""){S(zt(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function Bn(t){S(t!=null,()=>"The input to the tensor constructor must be a non-null value.")}function $n(t,e=[],n=!1){if(e==null&&(e=[]),Array.isArray(t)||Ue(t)&&!n)for(let r=0;r<t.length;++r)$n(t[r],e,n);else e.push(t);return e}function $e(t){if(t.length===0)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function dg(t){return t.length===0}function zt(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function nr(t){return t%1===0}function mg(t){if(Math.tanh!=null)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const e=Math.exp(2*t);return(e-1)/(e+1)}}function gg(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function yg(t){const e=new Uint32Array(t);for(let n=0;n<t;++n)e[n]=n;return Ru(e),e}function kr(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function bg(t,e=r=>0,n){return new Promise((r,s)=>{let a=0;const o=()=>{if(t()){r();return}a++;const i=e(a);if(n!=null&&a>=n){s();return}setTimeout(o,i)};o()})}function wg(t,e){let n=1,r=-1;for(let a=0;a<t.length;++a)if(t[a]>=0)n*=t[a];else if(t[a]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(t[a]<0)throw Error(`Shapes can not be < 0. Found ${t[a]} at dim ${a}`);if(r===-1){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(n===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const s=t.slice();return s[r]=e/n,s}function Mr(t,e){const n=e.length;return t=t==null?e.map((r,s)=>s):[].concat(t),S(t.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),S(t.every(r=>nr(r)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(r=>r<0?n+r:r)}function Bu(t,e){const n=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,a=e==null||s?null:Mr(e,t).sort();let o=0;for(let i=0;i<t.length;++i){if(a!=null){if(a[o]===i&&t[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${t[i]}' is not 1`);(a[o]==null||a[o]>i)&&t[i]===1&&(n.push(t[i]),r.push(i)),a[o]<=i&&o++}t[i]!==1&&(n.push(t[i]),r.push(i))}return{newShape:n,keptDims:r}}function Lu(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else throw new Error(`Unknown data type ${t}`);return n}function Mu(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else if(t==="string")n=new Array(e);else throw new Error(`Unknown data type ${t}`);return n}function zu(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function Vu(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function vg(t,e){return!(e==="complex64"||e==="float32"&&t!=="complex64"||e==="int32"&&t!=="float32"&&t!=="complex64"||e==="bool"&&t==="bool")}function Ue(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}function _a(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function ju(t){if(t==null)return 0;let e=0;return t.forEach(n=>e+=n.length),e}function an(t){return typeof t=="string"||t instanceof String}function Uu(t){return typeof t=="boolean"}function Wu(t){return typeof t=="number"}function Ps(t){return Array.isArray(t)?Ps(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":Wu(t)?"float32":an(t)?"string":Uu(t)?"bool":"float32"}function cn(t){return!!(t&&t.constructor&&t.call&&t.apply)}function Ss(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function cr(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function qu(t,e,n,r=!1){const s=new Array;if(e.length===1){const a=e[0]*(r?2:1);for(let o=0;o<a;o++)s[o]=n[t+o]}else{const a=e[0],o=e.slice(1),i=o.reduce((u,l)=>u*l)*(r?2:1);for(let u=0;u<a;u++)s[u]=qu(t+u*i,o,n,r)}return s}function En(t,e,n=!1){if(t.length===0)return e[0];const r=t.reduce((s,a)=>s*a)*(n?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return qu(0,t,e,n)}function lo(t,e){const n=Rs(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function Rs(t,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function Sg(t,e){const n=t.reduce((r,s)=>r*s,1);if(e==null||e==="float32")return En(t,new Float32Array(n));if(e==="int32")return En(t,new Int32Array(n));if(e==="bool")return En(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function co(t){t.forEach(e=>{S(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function Ng(t,e,n){if(e===0)return 0;if(e===1)return t[0];let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=n[s]*t[s];return r}function Tg(t,e,n){if(e===0)return[];if(e===1)return[t];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(t/n[s]),t-=r[s]*n[s];return r[r.length-1]=t,r}function An(t){return t&&t.then&&typeof t.then=="function"}const Ui="tfjsflags";class Hu{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Eg,this.populateURLFlags()}setPlatform(e,n){this.platform!=null&&(re().getBool("IS_TEST")||re().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=n}registerFlag(e,n,r){if(this.flagRegistry[e]={evaluationFn:n,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];re().getBool("IS_TEST")||re().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const n=this.evaluateFlag(e);if(An(n))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=n,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,n){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=n,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(n)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);Ui in e&&e[Ui].split(",").forEach(r=>{const[s,a]=r.split(":");this.urlFlags[s]=xg(s,a)})}}function Eg(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(kg(e,r[0],r[1]),r.join("="))),e}function kg(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function xg(t,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}function re(){return ho}let ho=null;function _g(t){ho=t}let ma;function Gu(){if(ma==null){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else if(typeof self<"u")t=self;else throw new Error("Could not find a global object");ma=t}return ma}function $g(){const t=Gu();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function fo(t,e){const n=$g();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const Ku="Abs",Xu="Acos",Yu="Acosh",po="Add",Zu="AddN",Ju="All",Qu="Any",el="ArgMax",tl="ArgMin",nl="Asin",rl="Asinh",sl="Atan",al="Atanh",ol="Atan2",il="AvgPool",Ag="AvgPoolGrad",ul="AvgPool3D",Ig="AvgPool3DGrad",ll="BatchMatMul",cl="BatchToSpaceND",hl="Bincount",Og="BroadcastTo",fl="BroadcastArgs",mo="Cast",pl="Ceil",dl="ClipByValue",ml="Complex",gl="ComplexAbs",yl="Concat",bl="Conv2D",wl="Conv2DBackpropFilter",vl="Conv2DBackpropInput",Sl="Conv3D",Dg="Conv3DBackpropFilterV2",Nl="Conv3DBackpropInputV2",Tl="Cos",El="Cosh",kl="Cumprod",xl="Cumsum",_l="CropAndResize",$l="DenseBincount",Al="DepthToSpace",Il="DepthwiseConv2dNative",Ol="DepthwiseConv2dNativeBackpropFilter",Dl="DepthwiseConv2dNativeBackpropInput",Fl="Diag",Cl="Dilation2D",Fg="Dilation2DBackpropInput",Cg="Dilation2DBackpropFilter",Pl="RealDiv",Rl="Einsum",Bl="Elu",Pg="EluGrad",Ll="Erf",Ml="Equal",zl="Exp",Vl="ExpandDims",jl="Expm1",Ul="FFT",Wl="Fill",ql="FlipLeftRight",Hl="Floor",Gl="FloorDiv",Kl="FusedBatchNorm",Xl="GatherV2",Yl="GatherNd",Zl="Greater",Jl="GreaterEqual",go="Identity",Ql="IFFT",ec="Imag",tc="IsFinite",nc="IsInf",rc="IsNan",sc="LeakyRelu",ac="Less",oc="LessEqual",ic="LinSpace",uc="Log",lc="Log1p",cc="LogicalAnd",hc="LogicalNot",fc="LogicalOr",Rg="LogicalXor",Bg="LogSoftmax",Lg="LowerBound",pc="LRN",Mg="LRNGrad",dc="Max",mc="Maximum",gc="MaxPool",zg="MaxPoolGrad",yc="MaxPool3D",Vg="MaxPool3DGrad",bc="MaxPoolWithArgmax",wc="Mean",vc="Min",Sc="Minimum",Nc="MirrorPad",Tc="Mod",Ec="Multinomial",kc="Multiply",xc="Neg",_c="NotEqual",$c="NonMaxSuppressionV3",Ac="NonMaxSuppressionV4",Ic="NonMaxSuppressionV5",Oc="OnesLike",Dc="OneHot",Fc="Pack",Cc="PadV2",jg="Pool",Pc="Pow",Rc="Prelu",Bc="Prod",Lc="Range",Mc="Real",zc="Reciprocal",Vc="Relu",jc="Reshape",Uc="ResizeNearestNeighbor",Ug="ResizeNearestNeighborGrad",Wc="ResizeBilinear",Wg="ResizeBilinearGrad",qc="Relu6",Hc="Reverse",Gc="Round",Kc="Rsqrt",Xc="ScatterNd",Yc="SearchSorted",Zc="Select",Jc="Selu",Qc="Slice",eh="Sin",th="Sinh",nh="Sign",rh="Sigmoid",sh="Softplus",ah="Sqrt",oh="Sum",ih="SpaceToBatchND",uh="SplitV",lh="Softmax",ch="SparseFillEmptyRows",hh="SparseReshape",fh="SparseSegmentMean",ph="SparseSegmentSum",dh="SparseToDense",mh="SquaredDifference",qg="Square",gh="StridedSlice",yh="StringNGrams",bh="StringSplit",wh="StringToHashBucketFast",vh="Sub",Sh="Tan",Nh="Tanh",yo="Tile",Th="TopK",Eh="Transform",gs="Transpose",kh="Unique",xh="Unpack",_h="UnsortedSegmentSum",Hg="UpperBound",$h="ZerosLike",Ah="Step",$a="FromPixels",Ih="RotateWithOffset",Aa="_FusedMatMul",Ia="FusedConv2D",Oa="FusedDepthwiseConv2D";function rn(...t){re().getBool("IS_TEST")||re().getBool("PROD")||console.warn(...t)}function Gg(...t){re().getBool("IS_TEST")||re().getBool("PROD")||console.log(...t)}const rr=fo("kernelRegistry",()=>new Map),$r=fo("gradRegistry",()=>new Map);function Ns(t,e){const n=bo(t,e);return rr.get(n)}function Da(t){return $r.get(t)}function Ts(t){const e=rr.entries(),n=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[a,o]=s,[i]=a.split("_");i===t&&n.push(o)}return n}function Oh(t){const{kernelName:e,backendName:n}=t,r=bo(e,n);rr.has(r)&&rn(`The kernel '${e}' for backend '${n}' is already registered`),rr.set(r,t)}function Kg(t){const{kernelName:e}=t;$r.has(e)&&re().getBool("DEBUG")&&rn(`Overriding the gradient for '${e}'`),$r.set(e,t)}function Xg(t,e){const n=bo(t,e);if(!rr.has(n))throw new Error(`The kernel '${t}' for backend '${e}' is not registered`);rr.delete(n)}function Yg(t){if(!$r.has(t))throw new Error(`The gradient '${t}' for backend is not registered`);$r.delete(t)}function Zg(t,e){Ts(t).forEach(r=>{const s=Object.assign({},r,{backendName:e});Oh(s)})}function bo(t,e){return`${e}_${t}`}var Fa=Ae,ft=null;try{ft=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Ae(t,e,n){this.low=t|0,this.high=e|0,this.unsigned=!!n}Ae.prototype.__isLong__;Object.defineProperty(Ae.prototype,"__isLong__",{value:!0});function it(t){return(t&&t.__isLong__)===!0}Ae.isLong=it;var Wi={},qi={};function Ln(t,e){var n,r,s;return e?(t>>>=0,(s=0<=t&&t<256)&&(r=qi[t],r)?r:(n=Ie(t,(t|0)<0?-1:0,!0),s&&(qi[t]=n),n)):(t|=0,(s=-128<=t&&t<128)&&(r=Wi[t],r)?r:(n=Ie(t,t<0?-1:0,!1),s&&(Wi[t]=n),n))}Ae.fromInt=Ln;function pt(t,e){if(isNaN(t))return e?Nn:dt;if(e){if(t<0)return Nn;if(t>=Dh)return Ph}else{if(t<=-Gi)return at;if(t+1>=Gi)return Ch}return t<0?pt(-t,e).neg():Ie(t%sr|0,t/sr|0,e)}Ae.fromNumber=pt;function Ie(t,e,n){return new Ae(t,e,n)}Ae.fromBits=Ie;var Es=Math.pow;function wo(t,e,n){if(t.length===0)throw Error("empty string");if(t==="NaN"||t==="Infinity"||t==="+Infinity"||t==="-Infinity")return dt;if(typeof e=="number"?(n=e,e=!1):e=!!e,n=n||10,n<2||36<n)throw RangeError("radix");var r;if((r=t.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return wo(t.substring(1),e,n).neg();for(var s=pt(Es(n,8)),a=dt,o=0;o<t.length;o+=8){var i=Math.min(8,t.length-o),u=parseInt(t.substring(o,o+i),n);if(i<8){var l=pt(Es(n,i));a=a.mul(l).add(pt(u))}else a=a.mul(s),a=a.add(pt(u))}return a.unsigned=e,a}Ae.fromString=wo;function It(t,e){return typeof t=="number"?pt(t,e):typeof t=="string"?wo(t,e):Ie(t.low,t.high,typeof e=="boolean"?e:t.unsigned)}Ae.fromValue=It;var Hi=1<<16,Jg=1<<24,sr=Hi*Hi,Dh=sr*sr,Gi=Dh/2,Ki=Ln(Jg),dt=Ln(0);Ae.ZERO=dt;var Nn=Ln(0,!0);Ae.UZERO=Nn;var Jn=Ln(1);Ae.ONE=Jn;var Fh=Ln(1,!0);Ae.UONE=Fh;var Ca=Ln(-1);Ae.NEG_ONE=Ca;var Ch=Ie(-1,2147483647,!1);Ae.MAX_VALUE=Ch;var Ph=Ie(-1,-1,!0);Ae.MAX_UNSIGNED_VALUE=Ph;var at=Ie(0,-2147483648,!1);Ae.MIN_VALUE=at;var W=Ae.prototype;W.toInt=function(){return this.unsigned?this.low>>>0:this.low};W.toNumber=function(){return this.unsigned?(this.high>>>0)*sr+(this.low>>>0):this.high*sr+(this.low>>>0)};W.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(at)){var n=pt(e),r=this.div(n),s=r.mul(n).sub(this);return r.toString(e)+s.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var a=pt(Es(e,6),this.unsigned),o=this,i="";;){var u=o.div(a),l=o.sub(u.mul(a)).toInt()>>>0,c=l.toString(e);if(o=u,o.isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}};W.getHighBits=function(){return this.high};W.getHighBitsUnsigned=function(){return this.high>>>0};W.getLowBits=function(){return this.low};W.getLowBitsUnsigned=function(){return this.low>>>0};W.getNumBitsAbs=function(){if(this.isNegative())return this.eq(at)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,n=31;n>0&&(e&1<<n)==0;n--);return this.high!=0?n+33:n+1};W.isZero=function(){return this.high===0&&this.low===0};W.eqz=W.isZero;W.isNegative=function(){return!this.unsigned&&this.high<0};W.isPositive=function(){return this.unsigned||this.high>=0};W.isOdd=function(){return(this.low&1)===1};W.isEven=function(){return(this.low&1)===0};W.equals=function(e){return it(e)||(e=It(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};W.eq=W.equals;W.notEquals=function(e){return!this.eq(e)};W.neq=W.notEquals;W.ne=W.notEquals;W.lessThan=function(e){return this.comp(e)<0};W.lt=W.lessThan;W.lessThanOrEqual=function(e){return this.comp(e)<=0};W.lte=W.lessThanOrEqual;W.le=W.lessThanOrEqual;W.greaterThan=function(e){return this.comp(e)>0};W.gt=W.greaterThan;W.greaterThanOrEqual=function(e){return this.comp(e)>=0};W.gte=W.greaterThanOrEqual;W.ge=W.greaterThanOrEqual;W.compare=function(e){if(it(e)||(e=It(e)),this.eq(e))return 0;var n=this.isNegative(),r=e.isNegative();return n&&!r?-1:!n&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};W.comp=W.compare;W.negate=function(){return!this.unsigned&&this.eq(at)?at:this.not().add(Jn)};W.neg=W.negate;W.add=function(e){it(e)||(e=It(e));var n=this.high>>>16,r=this.high&65535,s=this.low>>>16,a=this.low&65535,o=e.high>>>16,i=e.high&65535,u=e.low>>>16,l=e.low&65535,c=0,h=0,p=0,d=0;return d+=a+l,p+=d>>>16,d&=65535,p+=s+u,h+=p>>>16,p&=65535,h+=r+i,c+=h>>>16,h&=65535,c+=n+o,c&=65535,Ie(p<<16|d,c<<16|h,this.unsigned)};W.subtract=function(e){return it(e)||(e=It(e)),this.add(e.neg())};W.sub=W.subtract;W.multiply=function(e){if(this.isZero())return dt;if(it(e)||(e=It(e)),ft){var n=ft.mul(this.low,this.high,e.low,e.high);return Ie(n,ft.get_high(),this.unsigned)}if(e.isZero())return dt;if(this.eq(at))return e.isOdd()?at:dt;if(e.eq(at))return this.isOdd()?at:dt;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(Ki)&&e.lt(Ki))return pt(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,s=this.high&65535,a=this.low>>>16,o=this.low&65535,i=e.high>>>16,u=e.high&65535,l=e.low>>>16,c=e.low&65535,h=0,p=0,d=0,b=0;return b+=o*c,d+=b>>>16,b&=65535,d+=a*c,p+=d>>>16,d&=65535,d+=o*l,p+=d>>>16,d&=65535,p+=s*c,h+=p>>>16,p&=65535,p+=a*l,h+=p>>>16,p&=65535,p+=o*u,h+=p>>>16,p&=65535,h+=r*c+s*l+a*u+o*i,h&=65535,Ie(d<<16|b,h<<16|p,this.unsigned)};W.mul=W.multiply;W.divide=function(e){if(it(e)||(e=It(e)),e.isZero())throw Error("division by zero");if(ft){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var n=(this.unsigned?ft.div_u:ft.div_s)(this.low,this.high,e.low,e.high);return Ie(n,ft.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Nn:dt;var r,s,a;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Nn;if(e.gt(this.shru(1)))return Fh;a=Nn}else{if(this.eq(at)){if(e.eq(Jn)||e.eq(Ca))return at;if(e.eq(at))return Jn;var o=this.shr(1);return r=o.div(e).shl(1),r.eq(dt)?e.isNegative()?Jn:Ca:(s=this.sub(e.mul(r)),a=r.add(s.div(e)),a)}else if(e.eq(at))return this.unsigned?Nn:dt;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=dt}for(s=this;s.gte(e);){r=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(r)/Math.LN2),u=i<=48?1:Es(2,i-48),l=pt(r),c=l.mul(e);c.isNegative()||c.gt(s);)r-=u,l=pt(r,this.unsigned),c=l.mul(e);l.isZero()&&(l=Jn),a=a.add(l),s=s.sub(c)}return a};W.div=W.divide;W.modulo=function(e){if(it(e)||(e=It(e)),ft){var n=(this.unsigned?ft.rem_u:ft.rem_s)(this.low,this.high,e.low,e.high);return Ie(n,ft.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};W.mod=W.modulo;W.rem=W.modulo;W.not=function(){return Ie(~this.low,~this.high,this.unsigned)};W.and=function(e){return it(e)||(e=It(e)),Ie(this.low&e.low,this.high&e.high,this.unsigned)};W.or=function(e){return it(e)||(e=It(e)),Ie(this.low|e.low,this.high|e.high,this.unsigned)};W.xor=function(e){return it(e)||(e=It(e)),Ie(this.low^e.low,this.high^e.high,this.unsigned)};W.shiftLeft=function(e){return it(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Ie(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Ie(0,this.low<<e-32,this.unsigned)};W.shl=W.shiftLeft;W.shiftRight=function(e){return it(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Ie(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Ie(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};W.shr=W.shiftRight;W.shiftRightUnsigned=function(e){if(it(e)&&(e=e.toInt()),e&=63,e===0)return this;var n=this.high;if(e<32){var r=this.low;return Ie(r>>>e|n<<32-e,n>>>e,this.unsigned)}else return e===32?Ie(n,0,this.unsigned):Ie(n>>>e-32,0,this.unsigned)};W.shru=W.shiftRightUnsigned;W.shr_u=W.shiftRightUnsigned;W.toSigned=function(){return this.unsigned?Ie(this.low,this.high,!1):this};W.toUnsigned=function(){return this.unsigned?this:Ie(this.low,this.high,!0)};W.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};W.toBytesLE=function(){var e=this.high,n=this.low;return[n&255,n>>>8&255,n>>>16&255,n>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};W.toBytesBE=function(){var e=this.high,n=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,n>>>24,n>>>16&255,n>>>8&255,n&255]};Ae.fromBytes=function(e,n,r){return r?Ae.fromBytesLE(e,n):Ae.fromBytesBE(e,n)};Ae.fromBytesLE=function(e,n){return new Ae(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,n)};Ae.fromBytesBE=function(e,n){return new Ae(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],n)};var Qg=rg({__proto__:null,default:Fa},[Fa]);const Sn=Fa||Qg;function zr(t){return Sn.fromString(t,!0,16)}const Rh=zr("c3a5c85c97cb3127"),vn=zr("b492b66fbe98f273"),Xe=zr("9ae16a3b2f90404f");function Pa(t){return t.xor(t.shru(47))}function Bh(t,e,n){const r=t.slice(e,e+n);return Sn.fromBytes(Array.from(r),!0,!0)}function xe(t,e){return Bh(t,e,8)}function Xi(t,e){return Bh(t,e,4)}function Me(t,e){return e===0?t:t.shru(e).or(t.shl(64-e))}function ln(t,e,n=zr("9ddfea08eb382d69")){let r=t.xor(e).mul(n);r=r.xor(r.shru(47));let s=e.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function ey(t,e,n,r,s,a){s=s.add(t),a=Me(a.add(s).add(r),21);const o=s;return s=s.add(e),s=s.add(n),a=a.add(Me(s,44)),[s.add(r),a.add(o)]}function os(t,e,n,r){return ey(xe(t,e),xe(t,e+8),xe(t,e+16),xe(t,e+24),n,r)}function ty(t,e=t.length){if(e>=8){const n=Xe.add(e*2),r=xe(t,0).add(Xe),s=xe(t,e-8),a=Me(s,37).mul(n).add(r),o=Me(r,25).add(s).mul(n);return ln(a,o,n)}if(e>=4){const n=Xe.add(e*2),r=Xi(t,0);return ln(r.shl(3).add(e),Xi(t,e-4),n)}if(e>0){const n=t[0],r=t[e>>1],s=t[e-1],a=n+(r<<8),o=e+(s<<2);return Pa(Xe.mul(a).xor(Rh.mul(o))).mul(Xe)}return Xe}function ny(t,e=t.length){const n=Xe.add(e*2),r=xe(t,0).mul(vn),s=xe(t,8),a=xe(t,e-8).mul(n),o=xe(t,e-16).mul(Xe);return ln(Me(r.add(s),43).add(Me(a,30)).add(o),r.add(Me(s.add(Xe),18)).add(a),n)}function ry(t,e=t.length){const n=Xe.add(e*2),r=xe(t,0).mul(Xe),s=xe(t,8),a=xe(t,e-8).mul(n),o=xe(t,e-16).mul(Xe),i=Me(r.add(s),43).add(Me(a,30)).add(o),u=ln(i,r.add(Me(s.add(Xe),18)).add(a),n),l=xe(t,16).mul(n),c=xe(t,24),h=i.add(xe(t,e-32)).mul(n),p=u.add(xe(t,e-24)).mul(n);return ln(Me(l.add(c),43).add(Me(h,30)).add(p),l.add(Me(c.add(r),18)).add(h),n)}function sy(t,e=t.length){const n=Sn.fromNumber(81,!0);if(e<=32)return e<=16?ty(t,e):ny(t,e);if(e<=64)return ry(t,e);let r=n,s=n.mul(vn).add(113),a=Pa(s.mul(Xe).add(113)).mul(Xe),o=[Sn.UZERO,Sn.UZERO],i=[Sn.UZERO,Sn.UZERO];r=r.mul(Xe).add(xe(t,0));let u=0;const l=(e-1>>6)*64,c=l+(e-1&63)-63;do r=Me(r.add(s).add(o[0]).add(xe(t,u+8)),37).mul(vn),s=Me(s.add(o[1]).add(xe(t,u+48)),42).mul(vn),r=r.xor(i[1]),s=s.add(o[0]).add(xe(t,u+40)),a=Me(a.add(i[0]),33).mul(vn),o=os(t,u,o[1].mul(vn),r.add(i[0])),i=os(t,u+32,a.add(i[1]),s.add(xe(t,u+16))),[a,r]=[r,a],u+=64;while(u!==l);const h=vn.add(a.and(255).shl(1));return u=c,i[0]=i[0].add(e-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),r=Me(r.add(s).add(o[0]).add(xe(t,u+8)),37).mul(h),s=Me(s.add(o[1]).add(xe(t,u+48)),42).mul(h),r=r.xor(i[1].mul(9)),s=s.add(o[0].mul(9).add(xe(t,u+40))),a=Me(a.add(i[0]),33).mul(h),o=os(t,u,o[1].mul(h),r.add(i[0])),i=os(t,u+32,a.add(i[1]),s.add(xe(t,u+16))),[a,r]=[r,a],ln(ln(o[0],i[0],h).add(Pa(s).mul(Rh)).add(a),ln(o[1],i[1],h).add(r),h)}function ay(t,e){return e==="string"?Vr(t):Bs([t],e)}function oy(t,e){return t instanceof Float32Array&&e==="float32"||t instanceof Int32Array&&e==="int32"||t instanceof Uint8Array&&e==="bool"}function Bs(t,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=$n(t)),re().getBool("DEBUG")&&zu(t,e),oy(t,e))return t;if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool"){const n=new Uint8Array(t.length);for(let r=0;r<n.length;++r)Math.round(t[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${e}`)}function Ar(){return re().platform.now()}function iy(t,e){return re().platform.fetch(t,e)}function Vr(t,e="utf-8"){return e=e||"utf-8",re().platform.encode(t,e)}function ks(t,e="utf-8"){return e=e||"utf-8",re().platform.decode(t,e)}var uy=Object.freeze(Object.defineProperty({__proto__:null,createScalarValue:ay,toTypedArray:Bs,now:Ar,fetch:iy,encodeString:Vr,decodeString:ks,shuffle:Ru,shuffleCombo:lg,clamp:_r,nearestLargerEven:cg,swap:vs,sum:hg,randUniform:fg,distSquared:pg,assert:S,assertShapesMatch:Je,assertNonNull:Bn,flatten:$n,sizeFromShape:$e,isScalarShape:dg,arraysEqual:zt,isInt:nr,tanh:mg,sizeToSquarishShape:gg,createShuffledIndices:yg,rightPad:kr,repeatedTry:bg,inferFromImplicitShape:wg,parseAxisParam:Mr,squeezeShape:Bu,getTypedArrayFromDType:Lu,getArrayFromDType:Mu,checkConversionForErrors:zu,isValidDtype:Vu,hasEncodingLoss:vg,isTypedArray:Ue,bytesPerElement:_a,bytesFromStringArray:ju,isString:an,isBoolean:Uu,isNumber:Wu,inferDtype:Ps,isFunction:cn,nearestDivisor:Ss,computeStrides:cr,toNestedArray:En,makeOnesTypedArray:lo,makeZerosTypedArray:Rs,makeZerosNestedTypedArray:Sg,assertNonNegativeIntegerDimensions:co,locToIndex:Ng,indexToLoc:Tg,isPromise:An,hexToLong:zr,fingerPrint64:sy},Symbol.toStringTag,{value:"Module"}));class ly{constructor(e,n){this.backendTimer=e,this.logger=n,n==null&&(this.logger=new hy)}profileKernel(e,n,r){let s;const a=()=>{s=r()};let o;const i=Ar();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(a);else{a();for(const l of s)l.dataSync();o=Promise.resolve({kernelMs:Ar()-i})}if(re().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<s.length;l++){const c=s[l];c.data().then(h=>{cy(h,c.dtype,e)})}return{kernelName:e,outputs:s,inputs:n,timeMs:o.then(l=>l.kernelMs),extraInfo:o.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:n,outputs:r,timeMs:s,inputs:a,extraInfo:o}=e;r.forEach(i=>{Promise.all([i.data(),s,o]).then(u=>{this.logger.logKernelProfile(n,i,u[0],u[1],a,u[2])})})}}function cy(t,e,n){if(e!=="float32")return!1;for(let r=0;r<t.length;r++){const s=t[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}class hy{logKernelProfile(e,n,r,s,a,o){const i=typeof s=="number"?kr(`${s}ms`,9):s.error,u=kr(e,25),l=n.rank,c=n.size,h=kr(n.shape.toString(),14);let p="";for(const d in a){const b=a[d];if(b!=null){const v=b.shape||n.shape,N=v.length;p+=`${d}: ${N}D ${N>0?v:""} `}}console.log(`%c${u}	%c${i}	%c${l}D ${h}	%c${c}	%c${p}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function fy(t,e,n){const r={},s={};for(let u=0;u<e.length;u++)r[e[u].id]=!0;for(let u=0;u<t.length;u++){const l=t[u],c=l.inputs;for(const h in c){const p=c[h];let d=!1;for(let b=0;b<e.length;b++)if(r[p.id]){l.outputs.forEach(v=>r[v.id]=!0),d=!0,s[l.id]=!0;break}if(d)break}}const a={};a[n.id]=!0;const o={};for(let u=t.length-1;u>=0;u--){const l=t[u],c=l.inputs;for(let h=0;h<l.outputs.length;h++)if(a[l.outputs[h].id]){for(const p in c)a[c[p].id]=!0,o[l.id]=!0;break}}const i=[];for(let u=0;u<t.length;u++){const l=t[u];if(s[l.id]&&o[l.id]){const c={};for(const p in l.inputs){const d=l.inputs[p];r[d.id]&&(c[p]=d)}const h=Object.assign({},l);h.inputs=c,h.outputs=l.outputs,i.push(h)}}return i}function py(t,e,n,r){for(let s=e.length-1;s>=0;s--){const a=e[s],o=[];if(a.outputs.forEach(u=>{const l=t[u.id];l!=null?o.push(l):o.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const i=a.gradient(o);for(const u in a.inputs){if(!(u in i))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(i)}.`);const l=n(()=>i[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);const c=a.inputs[u];if(!zt(l.shape,c.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${c.shape}'`);if(t[c.id]==null)t[c.id]=l;else{const h=t[c.id];t[c.id]=r(h,l),h.dispose()}}}}const Yi=20,br=3,ga=7;function dy(t,e,n,r){const s=cr(e),a=my(t,e,n,s),o=e.length,i=ys(t,e,n,s,a),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${o}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(i.map(l=>"    "+l).join(`
`)),u.join(`
`)}function my(t,e,n,r){const s=$e(e),a=r[r.length-1],o=new Array(a).fill(0),i=e.length,u=n==="complex64"?Nr(t):t;if(i>1)for(let l=0;l<s/a;l++){const c=l*a;for(let h=0;h<a;h++)o[h]=Math.max(o[h],Sr(u[c+h],0,n).length)}return o}function Sr(t,e,n){let r;return Array.isArray(t)?r=`${parseFloat(t[0].toFixed(ga))} + ${parseFloat(t[1].toFixed(ga))}j`:an(t)?r=`'${t}'`:n==="bool"?r=Lh(t):r=parseFloat(t.toFixed(ga)).toString(),kr(r,e)}function Lh(t){return t===0?"false":"true"}function ys(t,e,n,r,s,a=!0){const o=n==="complex64"?2:1,i=e[0],u=e.length;if(u===0){if(n==="complex64"){const v=Nr(t);return[Sr(v[0],0,n)]}return n==="bool"?[Lh(t[0])]:[t[0].toString()]}if(u===1){if(i>Yi){const N=br*o;let _=Array.from(t.slice(0,N)),F=Array.from(t.slice((i-br)*o,i*o));return n==="complex64"&&(_=Nr(_),F=Nr(F)),["["+_.map((x,$)=>Sr(x,s[$],n)).join(", ")+", ..., "+F.map((x,$)=>Sr(x,s[i-br+$],n)).join(", ")+"]"]}const v=n==="complex64"?Nr(t):Array.from(t);return["["+v.map((N,_)=>Sr(N,s[_],n)).join(", ")+"]"]}const l=e.slice(1),c=r.slice(1),h=r[0]*o,p=[];if(i>Yi){for(let v=0;v<br;v++){const N=v*h,_=N+h;p.push(...ys(t.slice(N,_),l,n,c,s,!1))}p.push("...");for(let v=i-br;v<i;v++){const N=v*h,_=N+h;p.push(...ys(t.slice(N,_),l,n,c,s,v===i-1))}}else for(let v=0;v<i;v++){const N=v*h,_=N+h;p.push(...ys(t.slice(N,_),l,n,c,s,v===i-1))}const d=u===2?",":"";p[0]="["+p[0]+d;for(let v=1;v<p.length-1;v++)p[v]=" "+p[v]+d;let b=`,
`;for(let v=2;v<u;v++)b+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(a?"":b),p}function Nr(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class xs{constructor(e,n,r){if(this.dtype=n,this.shape=e.slice(),this.size=$e(e),r!=null){const s=r.length;S(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Mu(n,this.size),this.strides=cr(e)}set(e,...n){n.length===0&&(n=[0]),S(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const r=this.locToIndex(n);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let n=0;for(const s of e){if(s<0||s>=this.shape[n]){const a=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(a)}n++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return n}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const n=new Array(this.shape.length);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(e/this.strides[r]),e-=n[r]*this.strides[r];return n[n.length-1]=e,n}get rank(){return this.shape.length}toTensor(){return $t().makeTensor(this.values,this.shape,this.dtype)}}let $t=null,Xn=null;function gy(t){$t=t}function yy(t){Xn=t}class be{constructor(e,n,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=n||"float32",this.size=$e(e),this.strides=cr(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Xn.buffer(this.shape,this.dtype,e)}bufferSync(){return Xn.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return En(this.shape,e,this.dtype==="complex64")}arraySync(){return En(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=$t().read(this.dataId);if(this.dtype==="string"){const n=await e;try{return n.map(r=>ks(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),$t().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=$t().readSync(this.dataId);if(this.dtype==="string")try{return e.map(n=>ks(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await $t().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||($t().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Xn.print(this,e)}clone(){return this.throwIfDisposed(),Xn.clone(this)}toString(e=!1){const n=this.dataSync();return dy(n,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Xn.cast(this,e)}variable(e=!0,n,r){return this.throwIfDisposed(),$t().makeVariable(this,e,n,r)}}Object.defineProperty(be,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function by(){return fo("Tensor",()=>be)}by();class Ir extends be{constructor(e,n,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=n,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!zt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);$t().disposeTensor(this),this.dataId=e.dataId,$t().incRef(this,null)}dispose(){$t().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Ir,Symbol.hasInstance,{value:t=>t instanceof be&&t.assign!=null&&t.assign instanceof Function});var Ra;(function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"})(Ra||(Ra={}));var Ba;(function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"})(Ba||(Ba={}));var La;(function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"})(La||(La={}));var Ma;(function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"})(Ma||(Ma={}));var za;(function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"})(za||(za={}));const wy={float32:Ma,int32:Ba,bool:La,complex64:za};function Ls(t,e){if(t==="string"||e==="string"){if(t==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return wy[t][e]}function vy(t){return Ls(t,"int32")}function Ce(t,e){if(t.dtype===e.dtype)return[t,e];const n=Ls(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function Mh(t,e){S(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function Sy(t,e){return e.some(n=>n.id===t.id)}function vo(t){const e=[];return zh(t,e,new Set),e}function zh(t,e,n){if(t==null)return;if(t instanceof be){e.push(t);return}if(!Ny(t))return;const r=t;for(const s in r){const a=r[s];n.has(a)||(n.add(a),zh(a,e,n))}}function Ny(t){return Array.isArray(t)||typeof t=="object"}var Ty=Object.freeze(Object.defineProperty({__proto__:null,makeTypesMatch:Ce,assertTypesMatch:Mh,isTensorInList:Sy,getTensorsInContainer:vo},Symbol.toStringTag,{value:"Module"}));function ya(t){return t.kernelName!=null}class Zi{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class ar{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Zi}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:n}=this.initializeBackend(e);if(n)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,n,r=1){return e in this.registryFactory?(rn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:n,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:n,asyncInit:r}=this.initializeBackend(e);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new ly(this.backendInstance),!0}setupRegisteredKernels(){Ts(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Ts(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const n=this.registryFactory[e];if(n==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=n.factory();if(r&&!(r instanceof Pu)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,a=r.then(o=>s<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,rn(`Initialization of backend ${e} failed`),rn(o.stack||o.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return rn(`Initialization of backend ${e} failed`),rn(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,n)=>this.registryFactory[n].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n],{success:s,asyncInit:a}=this.initializeBackend(r);if(a||s)return{name:r,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,n){const r=this.state.tensorInfo.get(n),s=r.backend,a=this.readSync(n),o=s.refCount(n);s.disposeData(n,!0),r.backend=e,e.move(n,a,r.shape,r.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,n){let r=null;if(n==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");n=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=n(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,n,r){e();try{const s=r();return n(),s}catch(s){throw n(),s}}nextTensorId(){return ar.nextTensorId++}nextVariableId(){return ar.nextVariableId++}clone(e){const n=k.runKernel(go,{x:e}),r={x:e},s=o=>({x:()=>{const i="float32",u={x:o},l={dtype:i};return k.runKernel(mo,u,l)}}),a=[];return this.addTapeNode(this.state.activeScope.name,r,[n],s,a,{}),n}runKernel(e,n,r){if(this.backendName==null&&this.backend,!(Ns(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,n,r){const s=this.backend.numDataIds();let a=0;r.forEach(u=>{a+=u.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=s-n-a-o;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let n,r=[];const s=this.isTapeOn(),a=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let u;const l=ya(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(ya(e)){const{kernelName:b,inputs:v,attrs:N}=e;this.backendName==null&&this.backend;const _=Ns(b,this.backendName);S(_!=null,()=>`Cannot find registered kernel '${b}' for backend '${this.backendName}'`),i=()=>{const F=this.backend.numDataIds();u=_.kernelFunc({inputs:v,attrs:N,backend:this.backend});const x=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(b,F,x);const $=x.map(A=>A.rank!=null?A:this.makeTensorFromTensorInfo(A));if(s){const A=this.getTensorsForGradient(b,v,$);r=this.saveTensorsForBackwardMode(A)}return $}}else{const{forwardFunc:b}=e,v=N=>{!s||(r=N.map(_=>this.keep(this.clone(_))))};i=()=>{const N=this.backend.numDataIds();u=this.tidy(()=>b(this.backend,v));const _=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,N,_),_}}const{inputs:c,attrs:h}=e,p=ya(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=i():(d=this.profiler.profileKernel(l,c,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),n=d.outputs)}),s&&this.addTapeNode(l,c,n,p,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(b=>c[b]!=null?c[b].shape:null),outputShapes:n.map(b=>b.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(u)?n:n[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,n,r){const s=Da(e);if(s!=null){const a=s.inputsToSave||[],o=s.outputsToSave||[];let i;s.saveAllInputs?(S(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(n).map(l=>n[l])):i=a.map(l=>n[l]);const u=r.filter((l,c)=>o[c]);return i.concat(u)}return[]}makeTensor(e,n,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let a=e;r==="string"&&an(e[0])&&(a=e.map(u=>Vr(u)));const o=s.write(a,n,r),i=new be(n,r,o,this.nextTensorId());if(this.trackTensor(i,s),r==="string"){const u=this.state.tensorInfo.get(o),l=ju(a);this.state.numBytes+=l-u.bytes,u.bytes=l}return i}makeTensorFromDataId(e,n,r,s){r=r||"float32";const a={dataId:e,shape:n,dtype:r};return this.makeTensorFromTensorInfo(a,s)}makeTensorFromTensorInfo(e,n){const{dataId:r,shape:s,dtype:a}=e,o=new be(s,a,r,this.nextTensorId());return this.trackTensor(o,n),o}makeVariable(e,n=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const a=new Ir(e,n,r,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,n){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*_a(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:n||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof Ir||this.track(e)}incRef(e,n){this.trackTensor(e,n),this.backend.incRef(e.dataId)}removeDataId(e,n){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===n&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const n=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*_a(e.dtype);this.state.numBytes-=r}n.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,n.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const n=this.state.registeredVariables[e];this.disposeVariable(n)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,n,r,s,a,o){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:n,outputs:r,saved:a},u=Da(e);u!=null&&(s=u.gradFunc),s!=null&&(i.gradient=l=>(l=l.map((c,h)=>{if(c==null){const p=r[h],d=Rs(p.size,p.dtype);return this.makeTensor(d,p.shape,p.dtype)}return c}),s(l.length>1?l:l[0],a,o))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(n.name=e),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(e){const n=vo(e),r=new Set(n.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const o=this.state.activeScope.track[a];!o.kept&&!r.has(o.id)&&o.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(a=>{!a.kept&&a.scopeId===s.id&&this.track(a)})}gradients(e,n,r,s=!1){if(S(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));S(a instanceof be,()=>"The result y returned by f() must be a tensor.");const o=fy(this.state.activeTape,n,a);if(!s&&o.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const i={};i[a.id]=r??Ey(a.shape),py(i,o,l=>this.tidy(l),ky);const u=n.map(l=>i[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(const c of l.saved)c.dispose()}),this.state.activeTape=null),{value:a,grads:u}})}customGrad(e){return S(cn(e),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{S(n.every(i=>i instanceof be),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};n.forEach((i,u)=>{s[u]=i});const a=(i,u)=>(r=e(...n,u),S(r.value instanceof be,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),S(cn(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),o=(i,u)=>{const l=r.gradFunc(i,u),c=Array.isArray(l)?l:[l];S(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),S(c.every(p=>p instanceof be),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return c.forEach((p,d)=>{h[d]=()=>p}),h};return this.runKernelFunc({forwardFunc:a,backwardsFunc:o,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,n){return this.state.tensorInfo.get(e).backend.readToGPU(e,n)}async time(e){const n=Ar(),r=await this.backend.time(e);return r.wallMs=Ar()-n,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Zi;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}ar.nextTensorId=0;ar.nextVariableId=0;function Ey(t){const e=lo($e(t),"float32");return k.makeTensor(e,t,"float32")}function Vh(){const t=Gu();if(t._tfengine==null){const e=new Hu(t);t._tfengine=new ar(e)}return _g(t._tfengine.ENV),gy(()=>t._tfengine),t._tfengine}const k=Vh();function ky(t,e){const n={a:t,b:e};return k.runKernel(po,n)}function xy(){return typeof navigator<"u"&&navigator!=null}let Va;function _y(t){Va=t}function $y(t){if(Va!==void 0)return Va;if(t||xy()){if(t||(t=navigator),t.product==="ReactNative")return!0;const e=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");if(!e){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function jh(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var Ay=Object.freeze(Object.defineProperty({__proto__:null,mockIsMobile:_y,isMobile:$y,isBrowser:jh},Symbol.toStringTag,{value:"Module"}));const wt=re();wt.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});wt.registerFlag("IS_BROWSER",()=>jh());wt.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");wt.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));wt.registerFlag("PROD",()=>!1);wt.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>wt.getBool("DEBUG"));wt.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);wt.registerFlag("IS_TEST",()=>!1);wt.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);wt.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);wt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Vt(t,e){let n=t;if(Ue(t))return e==="string"?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||Ue(n)&&e!=="string";)r.push(n.length),n=n[0];return Array.isArray(t)&&re().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Uh(t,r,[]),r}function Uh(t,e,n){if(n=n||[],!Array.isArray(t)&&!Ue(t)){S(e.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}S(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),S(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const r=e.slice(1);for(let s=0;s<t.length;++s)Uh(t[s],r,n.concat(s))}function Ji(t,e,n,r){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==e||t==="numeric"&&e==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function w(t,e,n,r="numeric"){if(t instanceof be)return Ji(r,t.dtype,e,n),t;let s=Ps(t);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),Ji(r,s,e,n),t==null||!Ue(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){const u=t==null?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${u}'`)}const a=Vt(t,s);!Ue(t)&&!Array.isArray(t)&&(t=[t]);const i=s!=="string"?Bs(t,s):$n(t,[],!0);return k.makeTensor(i,a,s)}function Or(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((a,o)=>w(a,`${e}[${o}]`,n,r))}const So="__op";function E(t){const e=Object.keys(t);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+So;const s=(...a)=>{k.startScope(n);try{const o=r(...a);return An(o)&&console.error("Cannot return a Promise inside of tidy."),k.endScope(o),o}catch(o){throw k.endScope(null),o}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}function Iy(t,e){const n=w(t,"real","complex"),r=w(e,"imag","complex");Je(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return k.runKernel(ml,s)}const Xt=E({complex_:Iy});function dn(t,e,n,r){if(r==null&&(r=Ps(t)),r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Ue(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){co(e);const s=$e(e),a=$e(n);S(s===a,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${a}`);for(let o=0;o<n.length;++o){const i=n[o],u=o===n.length-1?i!==$e(e.slice(o)):!0;S(n[o]===e[o]||!u,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return!Ue(t)&&!Array.isArray(t)&&(t=[t]),e=e||n,t=r!=="string"?Bs(t,r):$n(t,[],!0),k.makeTensor(t,e,r)}function yt(t,e,n){const r=Vt(t,n);return dn(t,e,r,n)}const ja={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};const _s=4;async function Oy(t,e){const n=[],r=[],s=Array.isArray(t)?t.map(o=>o.name):Object.keys(t);for(let o=0;o<s.length;++o){const i=s[o],u=Array.isArray(t)?t[o].tensor:t[i];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${u.dtype}`);const l={name:i,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const c=new Promise(async h=>{const p=await u.bytes(),d=p.reduce((N,_)=>N+_.length,0)+_s*p.length,b=new Uint8Array(d);let v=0;for(let N=0;N<p.length;N++){const _=p[N],F=new Uint8Array(new Uint32Array([_.length]).buffer);b.set(F,v),v+=_s,b.set(_,v),v+=_.length}h(b)});r.push(c)}else r.push(u.data());e!=null&&(l.group=e),n.push(l)}const a=await Promise.all(r);return{data:Dy(a),specs:n}}function Wh(t,e){const n={};let r,s=0;for(const a of e){const o=a.name,i=a.dtype,u=a.shape,l=$e(u);let c;if("quantization"in a){const h=a.quantization;if(h.dtype==="uint8"||h.dtype==="uint16"){if(!("min"in h&&"scale"in h))throw new Error(`Weight ${a.name} with quantization ${h.dtype} doesn't have corresponding metadata min and scale.`)}else if(h.dtype==="float16"){if(i!=="float32")throw new Error(`Weight ${a.name} is quantized with ${h.dtype} which only supports weights of type float32 not ${i}.`)}else throw new Error(`Weight ${a.name} has unknown quantization dtype ${h.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const p=ja[h.dtype],d=t.slice(s,s+l*p),b=h.dtype==="uint8"?new Uint8Array(d):new Uint16Array(d);if(i==="float32")if(h.dtype==="uint8"||h.dtype==="uint16"){c=new Float32Array(b.length);for(let v=0;v<b.length;v++){const N=b[v];c[v]=N*h.scale+h.min}}else if(h.dtype==="float16")r===void 0&&(r=Ly()),c=r(b);else throw new Error(`Unsupported quantization type ${h.dtype} for weight type float32.`);else if(i==="int32"){if(h.dtype!=="uint8"&&h.dtype!=="uint16")throw new Error(`Unsupported quantization type ${h.dtype} for weight type int32.`);c=new Int32Array(b.length);for(let v=0;v<b.length;v++){const N=b[v];c[v]=Math.round(N*h.scale+h.min)}}else throw new Error(`Unsupported dtype in weight '${o}': ${i}`);s+=l*p}else if(i==="string"){const h=$e(a.shape);c=[];for(let p=0;p<h;p++){const d=new Uint32Array(t.slice(s,s+_s))[0];s+=_s;const b=new Uint8Array(t.slice(s,s+d));c.push(b),s+=d}}else{const h=ja[i],p=t.slice(s,s+l*h);if(i==="float32")c=new Float32Array(p);else if(i==="int32")c=new Int32Array(p);else if(i==="bool")c=new Uint8Array(p);else if(i==="complex64"){c=new Float32Array(p);const d=new Float32Array(c.length/2),b=new Float32Array(c.length/2);for(let _=0;_<d.length;_++)d[_]=c[_*2],b[_]=c[_*2+1];const v=yt(d,u,"float32"),N=yt(b,u,"float32");n[o]=Xt(v,N),v.dispose(),N.dispose()}else throw new Error(`Unsupported dtype in weight '${o}': ${i}`);s+=l*h}i!=="complex64"&&(n[o]=yt(c,u,i))}return n}function Dy(t){if(t===null)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(a=>{if(e+=a.byteLength,n.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const r=new Uint8Array(e);let s=0;return n.forEach(a=>{r.set(new Uint8Array(a.buffer),s),s+=a.byteLength}),r.buffer}const No=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function Qi(t){return No?Buffer.byteLength(t):new Blob([t]).size}function Fy(t){if(No)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,s=e.length;r<s;r++)n+=String.fromCharCode(e[r]);return btoa(n)}function Cy(t){if(No){const r=Buffer.from(t,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}function To(t){if(t.length===1)return t[0];let e=0;t.forEach(s=>{e+=s.byteLength});const n=new Uint8Array(e);let r=0;return t.forEach(s=>{n.set(new Uint8Array(s),r),r+=s.byteLength}),n.buffer}function eu(t){const e="/";for(t=t.trim();t.endsWith(e);)t=t.slice(0,t.length-1);const n=t.split(e);return n[n.length-1]}function qh(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),n}async function Eo(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),t.weightsManifest!=null){const[r,s]=await e(t.weightsManifest);n.weightSpecs=r,n.weightData=s}return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),n}function jr(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:Qi(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:Qi(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:t.weightData.byteLength}}function Py(){const t=n=>{let r=n<<13,s=0;for(;(r&8388608)===0;)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}function Ry(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}function By(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}function Ly(){const t=Py(),e=Ry(),n=By();return r=>{const s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let o=0;o<r.length;o++){const i=r[o],u=t[n[i>>10]+(i&1023)]+e[i>>10];a[o]=u}return new Float32Array(s)}}class Fe{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Fe.instance==null&&(Fe.instance=new Fe),Fe.instance}static registerSaveRouter(e){Fe.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Fe.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Fe.getHandlers(e,"save")}static getLoadHandlers(e,n){return Fe.getHandlers(e,"load",n)}static getHandlers(e,n,r){const s=[];return(n==="load"?Fe.getInstance().loadRouters:Fe.getInstance().saveRouters).forEach(o=>{const i=o(e,r);i!==null&&s.push(i)}),s}}const My=t=>Fe.registerSaveRouter(t),zy=t=>Fe.registerLoadRouter(t),Vy=t=>Fe.getSaveHandlers(t),jy=(t,e)=>Fe.getLoadHandlers(t,e);const Ua="tensorflowjs",Wa=1,Tn="models_store",on="model_info_store";function Hh(){if(!re().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function qa(t){const e=t.result;e.createObjectStore(Tn,{keyPath:"modelPath"}),e.createObjectStore(on,{keyPath:"modelPath"})}class In{constructor(e){if(this.indexedDB=Hh(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,n){return new Promise((r,s)=>{const a=this.indexedDB.open(Ua,Wa);a.onupgradeneeded=()=>qa(a),a.onsuccess=()=>{const o=a.result;if(n==null){const i=o.transaction(Tn,"readonly"),l=i.objectStore(Tn).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return o.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(l.result.modelArtifacts)},l.onerror=c=>(o.close(),s(l.error)),i.oncomplete=()=>o.close()}else{const i=jr(n),u=o.transaction(on,"readwrite");let l=u.objectStore(on);const c=l.put({modelPath:this.modelPath,modelArtifactsInfo:i});let h;c.onsuccess=()=>{h=o.transaction(Tn,"readwrite");const d=h.objectStore(Tn).put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:i});d.onsuccess=()=>r({modelArtifactsInfo:i}),d.onerror=b=>{l=u.objectStore(on);const v=l.delete(this.modelPath);v.onsuccess=()=>(o.close(),s(d.error)),v.onerror=N=>(o.close(),s(d.error))}},c.onerror=p=>(o.close(),s(c.error)),u.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},a.onerror=o=>s(a.error)})}}In.URL_SCHEME="indexeddb://";const Gh=t=>re().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(In.URL_SCHEME)?Uy(t.slice(In.URL_SCHEME.length)):null;Fe.registerSaveRouter(Gh);Fe.registerLoadRouter(Gh);function Uy(t){return new In(t)}function Wy(t){return t.startsWith(In.URL_SCHEME)?t.slice(In.URL_SCHEME.length):t}class qy{constructor(){this.indexedDB=Hh()}async listModels(){return new Promise((e,n)=>{const r=this.indexedDB.open(Ua,Wa);r.onupgradeneeded=()=>qa(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(on,"readonly"),i=a.objectStore(on).getAll();i.onsuccess=()=>{const u={};for(const l of i.result)u[l.modelPath]=l.modelArtifactsInfo;e(u)},i.onerror=u=>(s.close(),n(i.error)),a.oncomplete=()=>s.close()},r.onerror=s=>n(r.error)})}async removeModel(e){return e=Wy(e),new Promise((n,r)=>{const s=this.indexedDB.open(Ua,Wa);s.onupgradeneeded=()=>qa(s),s.onsuccess=()=>{const a=s.result,o=a.transaction(on,"readwrite"),i=o.objectStore(on),u=i.get(e);let l;u.onsuccess=()=>{if(u.result==null)return a.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=i.delete(e),h=()=>{l=a.transaction(Tn,"readwrite");const d=l.objectStore(Tn).delete(e);d.onsuccess=()=>n(u.result.modelArtifactsInfo),d.onerror=b=>r(u.error)};c.onsuccess=h,c.onerror=p=>(h(),a.close(),r(u.error))}},u.onerror=c=>(a.close(),r(u.error)),o.oncomplete=()=>{l==null?a.close():l.oncomplete=()=>a.close()}},s.onerror=a=>r(s.error)})}}const Gt="/",Yn="tensorflowjs_models",Kh="info",Hy="model_topology",Gy="weight_specs",Ky="weight_data",Xy="model_metadata";function Xh(t){return{info:[Yn,t,Kh].join(Gt),topology:[Yn,t,Hy].join(Gt),weightSpecs:[Yn,t,Gy].join(Gt),weightData:[Yn,t,Ky].join(Gt),modelMetadata:[Yn,t,Xy].join(Gt)}}function Yh(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function Yy(t){const e=t.split(Gt);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(Gt)}function Zy(t){return t.startsWith(On.URL_SCHEME)?t.slice(On.URL_SCHEME.length):t}class On{constructor(e){if(!re().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Xh(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=jr(e);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,Fy(e.weightData));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:s}}catch{throw Yh(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=s;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const i=JSON.parse(a);n.format=i.format,n.generatedBy=i.generatedBy,n.convertedBy=i.convertedBy,i.signature!=null&&(n.signature=i.signature),i.userDefinedMetadata!=null&&(n.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(n.modelInitializer=i.modelInitializer),i.trainingConfig!=null&&(n.trainingConfig=i.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=Cy(o),n}}On.URL_SCHEME="localstorage://";const Zh=t=>re().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(On.URL_SCHEME)?Jy(t.slice(On.URL_SCHEME.length)):null;Fe.registerSaveRouter(Zh);Fe.registerLoadRouter(Zh);function Jy(t){return new On(t)}class Qy{constructor(){S(re().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),S(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},n=Yn+Gt,r=Gt+Kh;for(let s=0;s<this.LS.length;++s){const a=this.LS.key(s);if(a.startsWith(n)&&a.endsWith(r)){const o=Yy(a);e[o]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=Zy(e);const n=Xh(e);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return Yh(n),r}}const Qn="://";class Ke{constructor(){this.managers={}}static getInstance(){return Ke.instance==null&&(Ke.instance=new Ke),Ke.instance}static registerManager(e,n){S(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Qn)&&(e=e.slice(0,e.indexOf(Qn))),S(e.length>0,()=>"scheme must not be an empty string.");const r=Ke.getInstance();S(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=n}static getManager(e){const n=Ke.getInstance().managers[e];if(n==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return n}static getSchemes(){return Object.keys(Ke.getInstance().managers)}}function bs(t){if(t.indexOf(Qn)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ke.getSchemes().join(",")}`);return{scheme:t.split(Qn)[0],path:t.split(Qn)[1]}}async function Jh(t,e,n=!1){S(t!==e,()=>`Old path and new path are the same: '${t}'`);const r=Fe.getLoadHandlers(t);S(r.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),S(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`);const s=r[0],a=Fe.getSaveHandlers(e);S(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),S(a.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const o=a[0],i=bs(t).scheme,u=bs(t).path,l=i===bs(t).scheme,c=await s.load();n&&l&&await Ke.getManager(i).removeModel(u);const h=await o.save(c);return n&&!l&&await Ke.getManager(i).removeModel(u),h.modelArtifactsInfo}async function e0(){const t=Ke.getSchemes(),e={};for(const n of t){const r=await Ke.getManager(n).listModels();for(const s in r){const a=n+Qn+s;e[a]=r[s]}}return e}async function t0(t){const e=bs(t);return Ke.getManager(e.scheme).removeModel(e.path)}async function n0(t,e){return Jh(t,e,!1)}async function r0(t,e){return Jh(t,e,!0)}class s0{fetch(e,n){return fetch(e,n)}now(){return performance.now()}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,n){return new TextDecoder(n).decode(e)}}if(re().get("IS_BROWSER")){re().setPlatform("browser",new s0);try{Ke.registerManager(On.URL_SCHEME,new Qy)}catch{}try{Ke.registerManager(In.URL_SCHEME,new qy)}catch{}}const a0={importFetch:()=>require("node-fetch")};let ba;class o0{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return re().global.fetch!=null?re().global.fetch(e,n):(ba==null&&(ba=a0.importFetch()),ba(e,n))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(e)}decode(e,n){return e.length===0?"":new this.util.TextDecoder(n).decode(e)}}re().get("IS_NODE")&&!re().get("IS_BROWSER")&&re().setPlatform("node",new o0);function jt(t,e="float32",n){return e=e||"float32",co(t),new xs(t,e,n)}function i0(t,e){const n=w(t,"x","cast");if(!Vu(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&n.dtype!=="string"||e!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:e};return k.runKernel(mo,r,s)}const we=E({cast_:i0});function u0(t){const n={x:w(t,"x","clone","string_or_numeric")};return k.runKernel(go,n)}const Kt=E({clone_:u0});function ko(t,e=!1){console.log(t.toString(e))}Vh();const l0={buffer:jt,cast:we,clone:Kt,print:ko};yy(l0);const c0="model",h0=".json",f0=".weights.bin";function tu(t){return new Promise(e=>setTimeout(e)).then(t)}class Dn{constructor(e){if(!re().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Dn.URL_SCHEME)&&(e=e.slice(Dn.URL_SCHEME.length)),(e==null||e.length===0)&&(e=c0),this.modelJsonFileName=e+h0,this.weightDataFileName=e+f0}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],s=qh(e,r),a=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=a,await tu(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=n,await tu(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:jr(e)}}}}Dn.URL_SCHEME="downloads://";class p0{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,n)=>{const r=new FileReader;r.onload=s=>{const a=JSON.parse(s.target.result),o=a.modelTopology;if(o==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:o});return}const u=Eo(a,l=>this.loadWeights(l));e(u)},r.onerror=s=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){const n=[],r=[];for(const o of e)n.push(...o.weights),r.push(...o.paths);const s=this.checkManifestAndWeightFiles(e),a=r.map(o=>this.loadWeightsFile(o,s[o]));return Promise.all(a).then(o=>[n,To(o)])}loadWeightsFile(e,n){return new Promise((r,s)=>{const a=new FileReader;a.onload=o=>{const i=o.target.result;r(i)},a.onerror=o=>s(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(e){const n=[],r=this.weightsFiles.map(a=>eu(a.name)),s={};for(const a of e)a.paths.forEach(o=>{const i=eu(o);if(n.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(n.push(i),r.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);s[o]=this.weightsFiles[r.indexOf(i)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}const d0=t=>re().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Dn.URL_SCHEME)?m0(t.slice(Dn.URL_SCHEME.length)):null;Fe.registerSaveRouter(d0);function m0(t="model"){return new Dn(t)}function g0(t){return new p0(t)}function nu(t,e,n,r){o(t),n=n??0,r=r??1,i(n,r);let s=0;const a=u=>(u.then(l=>{const c=n+ ++s/t.length*(r-n);return e(c),l}),u);function o(u){S(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function i(u,l){S(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),S(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),S(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(t.map(a))}async function Qh(t,e){e==null&&(e={});const n=e.fetchFunc==null?re().platform.fetch:e.fetchFunc,r=t.map(h=>n(h,e.requestInit,{isBinary:!0})),s=0,a=.5,i=(e.onProgress==null?await Promise.all(r):await nu(r,e.onProgress,s,a)).map(h=>h.arrayBuffer()),u=.5,l=1;return e.onProgress==null?await Promise.all(i):await nu(i,e.onProgress,u,l)}async function y0(t,e="",n,r){return ef(o=>Qh(o,{requestInit:r}))(t,e,n)}function ef(t){return async(e,n="",r)=>{const s=e.map(()=>!1),a={},o=r!=null?r.map(()=>!1):[],i=[];if(e.forEach((d,b)=>{let v=0;d.weights.forEach(N=>{const _="quantization"in N?N.quantization.dtype:N.dtype,F=ja[_]*$e(N.shape),x=()=>{s[b]=!0,a[b]==null&&(a[b]=[]),a[b].push({manifestEntry:N,groupOffset:v,sizeBytes:F})};r!=null?r.forEach(($,A)=>{$===N.name&&(x(),o[A]=!0)}):x(),i.push(N.name),v+=F})}),!o.every(d=>d)){const d=r.filter((b,v)=>!o[v]);throw new Error(`Could not find weights in manifest with names: ${d.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}const u=s.reduce((d,b,v)=>(b&&d.push(v),d),[]),l=[];u.forEach(d=>{e[d].paths.forEach(b=>{const v=n+(n.endsWith("/")?"":"/")+b;l.push(v)})});const c=await t(l),h={};let p=0;return u.forEach(d=>{const b=e[d].paths.length;let v=0;for(let $=0;$<b;$++)v+=c[p+$].byteLength;const N=new ArrayBuffer(v),_=new Uint8Array(N);let F=0;for(let $=0;$<b;$++){const A=new Uint8Array(c[p+$]);_.set(A,F),F+=A.byteLength}a[d].forEach($=>{const A=N.slice($.groupOffset,$.groupOffset+$.sizeBytes),I=Wh(A,[$.manifestEntry]);for(const P in I)h[P]=I[P]}),p+=b}),h}}const b0="application/octet-stream",w0="application/json";class xo{constructor(e,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.onProgress=n.onProgress,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(S(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=re().platform.fetch,S(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&S(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=qh(e,r);n.body.append("model.json",new Blob([JSON.stringify(s)],{type:w0}),"model.json"),e.weightData!=null&&n.body.append("model.weights.bin",new Blob([e.weightData],{type:b0}),"model.weights.bin");const a=await this.fetch(this.path,n);if(a.ok)return{modelArtifactsInfo:jr(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const r=n.modelTopology,s=n.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Eo(n,a=>this.loadWeights(a))}async loadWeights(e){const n=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=v0(n),a=this.weightPathPrefix||r,o=[];for(const c of e)o.push(...c.weights);const i=[],u=[];for(const c of e)for(const h of c.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(h)):i.push(a+h+s);this.weightUrlConverter&&i.push(...await Promise.all(u));const l=await Qh(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,To(l)]}}xo.URL_SCHEME_REGEX=/^https?:\/\//;function v0(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),s=n>e?t.substring(n):"";return[r+"/",s]}function Ha(t){return t.match(xo.URL_SCHEME_REGEX)!=null}const tf=(t,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let n=!0;if(Array.isArray(t)?n=t.every(r=>Ha(r)):n=Ha(t),n)return _o(t,e)}return null};Fe.registerSaveRouter(tf);Fe.registerLoadRouter(tf);function _o(t,e){return new xo(t,e)}function S0(t,e){return _o(t,e)}class wa{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class nf{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class N0{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=n=>Promise.resolve(e.save(n)))}}function T0(t,e,n,r){const s=arguments;return new N0(rf(...s))}function rf(t,e,n,r){return arguments.length===1?t.modelTopology!=null||t.weightSpecs!=null?new wa(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new wa({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new wa({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r}))}function E0(t){return new nf(t)}function k0(t){return new nf(t)}var $o=Object.freeze(Object.defineProperty({__proto__:null,browserFiles:g0,browserHTTPRequest:S0,concatenateArrayBuffers:To,decodeWeights:Wh,encodeWeights:Oy,fromMemory:T0,fromMemorySync:rf,getLoadHandlers:jy,getModelArtifactsForJSON:Eo,getModelArtifactsInfoForJSON:jr,getSaveHandlers:Vy,http:_o,isHTTPScheme:Ha,loadWeights:y0,registerLoadRouter:zy,registerSaveRouter:My,weightsLoaderFactory:ef,withSaveHandler:E0,withSaveHandlerSync:k0,copyModel:n0,listModels:e0,moveModel:r0,removeModel:t0},Symbol.toStringTag,{value:"Module"}));function x0(t,e,n=!1,r=!1){let s=w(t,"a","matMul"),a=w(e,"b","matMul");[s,a]=Ce(s,a);const o={a:s,b:a},i={transposeA:n,transposeB:r};return k.runKernel(ll,o,i)}const ye=E({matMul_:x0});function _0(t,e,n=1,r=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const a={indices:w(t,"indices","oneHot","int32")},o={depth:e,onValue:n,offValue:r};return k.runKernel(Dc,a,o)}const Dr=E({oneHot_:_0});function $0(){re().set("PROD",!0)}function A0(){re().set("DEBUG",!0)}function I0(){re().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function O0(t){re().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function D0(){k.disposeVariables()}function Ao(){return k}function F0(){return k.memory()}function C0(t){return k.profile(t)}function Y(t,e){return k.tidy(t,e)}function et(t){vo(t).forEach(n=>n.dispose())}function Rt(t){return k.keep(t)}function P0(t){return k.time(t)}function R0(t){return k.setBackend(t)}function B0(){return k.ready()}function sf(){return k.backendName}function L0(t){k.removeBackend(t)}function M0(t){return k.findBackend(t)}function z0(t){return k.findBackendFactory(t)}function V0(t,e,n=1){return k.registerBackend(t,e,n)}function af(){return k.backend}function j0(t,e){re().setPlatform(t,e)}function U0(t){const n={input:w(t,"input","imag")};return k.runKernel(ec,n)}const Ur=E({imag_:U0});function W0(t){const n={x:w(t,"x","neg")};return k.runKernel(xc,n)}const Lt=E({neg_:W0});function q0(t){const n={input:w(t,"input","real")};return k.runKernel(Mc,n)}const or=E({real_:q0});function H0(t,e,n){const r=w(t,"x","transpose");if(e==null&&(e=r.shape.map((o,i)=>i).reverse()),S(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(o=>{S(o>=0&&o<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const s={x:r},a={perm:e};return r.dtype==="complex64"?Y(()=>{let o=or(r),i=Ur(r);return o=k.runKernel(gs,{x:o},a),i=k.runKernel(gs,{x:i},a),n&&(i=Lt(i)),Xt(o,i)}):k.runKernel(gs,s,a)}const Fr=E({transpose_:H0});function G0(t,e,n){const r=w(t,"labels","confusionMatrix"),s=w(e,"predictions","confusionMatrix");S(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),S(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),S(s.rank===1,()=>`Expected the rank of predictions to be 1, but got ${s.rank}`),S(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),S(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);const a=Dr(we(r,"int32"),n),o=Dr(we(s,"int32"),n),i=Fr(a),u=ye(i,o);return we(u,"int32")}const K0=E({confusionMatrix_:G0});var X0=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:K0},Symbol.toStringTag,{value:"Module"}));function of(t,e){const n=t.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,o=t[a]||1;(e[e.length-1-s]||1)>1&&o===1&&r.unshift(a)}return r}function Io(t,e){const n=[];for(let r=0;r<e.length;r++){const s=t[t.length-r-1],a=e.length-r-1,o=e[a];(s==null||s===1&&o>1)&&n.unshift(a)}return n}function Be(t,e){const n=[],r=Math.max(t.length,e.length);for(let s=0;s<r;s++){let a=t[t.length-s-1];a==null&&(a=1);let o=e[e.length-s-1];if(o==null&&(o=1),a===1)n.unshift(o);else if(o===1)n.unshift(a);else if(a!==o){const i=`Operands could not be broadcast together with shapes ${t} and ${e}.`;throw Error(i)}else n.unshift(a)}return n}var Y0=Object.freeze(Object.defineProperty({__proto__:null,getBroadcastDims:of,getReductionAxes:Io,assertAndGetBroadcastShape:Be},Symbol.toStringTag,{value:"Module"}));function Oo(t,e,n){if(Bn(t),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=Vt(t,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return dn(t,e,r,n)}let wn;function uf(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(t==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,o=!1,i=!1;if(t.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&t instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)a=!0;else if(t.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&t instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);if(s&&s&&t.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(Ns($a,k.backendName)!=null){const b={pixels:t},v={numChannels:e};return k.runKernel($a,b,v)}const[l,c]=s?[t.videoWidth,t.videoHeight]:[t.width,t.height];let h;if(o)h=t.getContext("2d").getImageData(0,0,l,c).data;else if(r||n)h=t.data;else if(a||s||i){if(wn==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")wn=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else wn=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});wn.canvas.width=l,wn.canvas.height=c,wn.drawImage(t,0,0,l,c),h=wn.getImageData(0,0,l,c).data}let p;if(e===4)p=new Int32Array(h);else{const b=l*c;p=new Int32Array(b*e);for(let v=0;v<b;v++)for(let N=0;N<e;++N)p[v*e+N]=h[v*4+N]}return Oo(p,[c,l,e],"int32")}function Z0(t){return t!=null&&t.data instanceof Uint8Array}function J0(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function Q0(t){return t!=null&&t.width!==0&&t.height!==0}function eb(t){return J0()&&!(t instanceof ImageBitmap)&&Q0(t)&&!Z0(t)}async function tb(t,e=3){let n=null;if(re().getBool("WRAP_TO_IMAGEBITMAP")&&eb(t)){let r;try{r=await createImageBitmap(t,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===t.width&&r.height===t.height?n=r:n=t}else n=t;return uf(n,e)}async function Wr(t,e){let n=w(t,"img","toPixels");if(!(t instanceof be)){const l=n;n=we(l,"int32"),l.dispose()}if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[r,s]=n.shape.slice(0,2),a=n.rank===2?1:n.shape[2];if(a>4||a===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${a}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);const o=await n.data(),i=n.dtype==="float32"?255:1,u=new Uint8ClampedArray(s*r*4);for(let l=0;l<r*s;++l){const c=[0,0,0,255];for(let p=0;p<a;p++){const d=o[l*a+p];if(n.dtype==="float32"){if(d<0||d>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${d}.`)}else if(n.dtype==="int32"&&(d<0||d>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${d}.`);a===1?(c[0]=d*i,c[1]=d*i,c[2]=d*i):c[p]=d*i}const h=l*4;u[h+0]=Math.round(c[0]),u[h+1]=Math.round(c[1]),u[h+2]=Math.round(c[2]),u[h+3]=Math.round(c[3])}if(e!=null){e.width=s,e.height=r;const l=e.getContext("2d"),c=new ImageData(u,s,r);l.putImageData(c,0,0)}return n!==t&&n.dispose(),u}const Ms=E({fromPixels_:uf});var nb=Object.freeze(Object.defineProperty({__proto__:null,fromPixelsAsync:tb,toPixels:Wr,fromPixels:Ms},Symbol.toStringTag,{value:"Module"}));function lf(t,e){const n=t.shape.length,r=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${n}`);if($e(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const s=e.shape,a=s[s.length-1];let o=1;for(let h=0;h<s.length-1;++h)o*=s[h];const i=t.shape,u=s.slice();u.pop();let l=1;for(let h=a;h<n;++h)l*=i[h],u.push(i[h]);const c=[...cr(t.shape).map(h=>h/l),1].slice(0,a);return[u,o,l,c]}var rb=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:lf},Symbol.toStringTag,{value:"Module"}));function Do(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(t.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+t.length-r)throw new Error(a+` update.rank != ${s+t.length-r}`);for(let o=0;o<s;++o)if(n.shape[o]!==e.shape[o])throw new Error(a+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<n.rank-s;++o)if(n.shape[o+s]!==t[o+r])throw new Error(a+` updates.shape[${o+s}] (${n.shape[o+s]}) != shape[${o+s}] (${t[o+s]})`)}function Fo(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}Do(n,e,t)}function cf(t,e,n){const r=e.shape.length,s=r>1?e.shape[r-1]:1,a=n.length;let o=1;for(let h=s;h<a;++h)o*=n[h];const i=s<1?1:s,u=$e(e.shape)/i,l=[...cr(n.slice(0,s)),1],c=$e(n);return{sliceRank:s,numUpdates:u,sliceSize:o,strides:l,outputSize:c}}var sb=Object.freeze(Object.defineProperty({__proto__:null,validateUpdateShape:Do,validateInput:Fo,calculateShapes:cf},Symbol.toStringTag,{value:"Module"}));const Ga=-2,ab=-1;function ob(t,e,n){const r=t.shape.length;S(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),S(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)S(e[s]+n[s]<=t.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+n[s]}) would overflow input.shape[${s}] (${t.shape[s]})`)}function ib(t){const e=[];let n=0;for(;t>0;)t&1&&e.push(n),t/=2,n++;return e}function ub(t,e,n){const r=[];for(let s=0;s<t.length;s++)r[s]=Math.ceil((e[s]-t[s])/n[s]);return r}function hf(t,e,n,r){const s=[...t];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<n;a++)a===0?s[e]=1:(s.splice(e,0,1),s.pop());return s}function ff(t,e,n){return n<=t?n:n-(e-1)}function pf(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function lb(t,e,n,r,s,a,o,i,u){const l=t.length;let c=new Array(l),h=new Array(l),p=new Array(l);if(e.length&&n>0){const d=e[0],b=n+1;c=df(o,d,b,r,t),h=mf(i,d,b,s,t),p=hf(a,d,b,t)}else for(let d=0;d<l;d++)c[d]=yf(o,r,a,t,d,u),h[d]=bf(i,s,a,t,d,u),p[d]=gf(a,d,u);return{begin:c,end:h,strides:p}}function df(t,e,n,r,s){const a=[...s],o=pf(n,e);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=0;else{const u=ff(e,n,i);let l=r[u];t&1<<u&&(l=0),a[i]=l}return a}function mf(t,e,n,r,s){const a=[...s],o=pf(n,e);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=Number.MAX_SAFE_INTEGER;else{const u=ff(e,n,i);let l=r[u];t&1<<u&&(l=Number.MAX_SAFE_INTEGER),a[i]=l}for(let i=0;i<a.length;i++){const u=s[i];a[i]<0&&(a[i]+=u),a[i]=_r(0,a[i],s[i])}return a}function gf(t,e,n){let r=t[e];return(n&1<<e||r==null)&&(r=1),r}function yf(t,e,n,r,s,a){let o=e[s];const i=n[s]||1;(t&1<<s||a&1<<s||o==null)&&(i>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const u=r[s];return o<0&&(o+=u),o=_r(0,o,u-1),o}function bf(t,e,n,r,s,a){let o=e[s];const i=n[s]||1;(t&1<<s||a&1<<s||o==null)&&(i>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const u=r[s];return o<0&&(o+=u),i>0?o=_r(0,o,u):o=_r(-1,o,u-1),o}function cb(t,e,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(e[s]>0||n[s]!==t[s])return!1;return!0}function hb(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function fb(t,e,n){let r;const s=t.shape.length;typeof e=="number"?r=[e,...new Array(s-1).fill(0)]:e.length<s?r=e.concat(new Array(s-e.length).fill(0)):r=e.slice(),r.forEach(o=>{S(o!==-1,()=>"slice() does not support negative begin indexing.")});let a;return n==null?a=new Array(s).fill(-1):typeof n=="number"?a=[n,...new Array(s-1).fill(-1)]:n.length<s?a=n.concat(new Array(s-n.length).fill(-1)):a=n,a=a.map((o,i)=>o>=0?o:(S(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${i}.`),t.shape[i]-r[i])),[r,a]}function pb(t,e,n,r,s,a,o,i,u){let l;if(r==null?(l=new Array(e.length),l.fill(1)):l=r,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:l.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:l.slice(),beginMask:s,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};for(let x=0;x<h.dims;x++)c&&(1<<x&i)!==0&&h.numAddAxisAfterEllipsis++,1<<x&o&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const p={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};db(h,p);let d=!0,b=!0,v=!0;const N=[],_=[];for(let x=0;x<t.length;++x){if(p.strides[x]===0)throw Error(`strides[${x}] must be non-zero`);const $=!!(p.shrinkAxisMask&1<<x),A=t[x];if(A===-1){N.push($?1:-1);continue}const I=[p.beginMask&1<<x,p.endMask&1<<x],P=[p.strides[x]>0?0:-1,p.strides[x]>0?A:A-1];if($&&p.strides[x]<=0)throw Error("only stride 1 allowed on non-range indexing.");v=v&&p.strides[x]===1;const M=!!(p.beginMask&1<<x&&p.endMask&1<<x);if(p.beginValid&&p.endValid){if($){const G=p.begin[x]<0?A+p.begin[x]:p.begin[x];if(p.begin[x]=G,p.end[x]=p.begin[x]+1,G<0||G>=A)throw Error(`slice index ${p.begin[x]} of dimension ${x} out of bounds.`)}else p.begin[x]=ru(p.begin[x],0,p.strides[x],A,I,P),p.end[x]=ru(p.end[x],1,p.strides[x],A,I,P);const z=p.strides[x]===1&&p.begin[x]===0&&p.end[x]===A;d=d&&z,b=b&&(x===0&&p.strides[x]===1||z)}else d=d&&p.strides[x]===1&&M,b=b&&(x===0&&p.strides[x]===1||M);let C,j=!1;if(p.beginValid&&p.endValid?(C=p.end[x]-p.begin[x],j=!0):$?(C=1,j=!0):M&&A>=0&&(p.strides[x]<0?C=-A:C=A,j=!0),j){let z;C===0||C<0!=p.strides[x]<0?z=0:z=Math.trunc(C/p.strides[x])+(C%p.strides[x]!==0?1:0),N.push(z)}else N.push(-1)}for(let x=0;x<p.finalShapeGatherIndices.length;++x){const $=p.finalShapeGatherIndices[x];$>=0?_.push(N[$]):$===Ga&&_.push(1)}return{finalShapeSparse:_.filter((x,$)=>p.finalShapeGatherIndices[$]!==Ga),finalShape:_,isIdentity:d,sliceDim0:b,isSimpleSlice:v,begin:p.begin,end:p.end,strides:p.strides}}function db(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=t.begin!=null,e.endValid=t.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const s=Math.min(e.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<s;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&t.newAxisMask)e.finalShapeGatherIndices.push(Ga),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);t.begin!=null&&(e.begin[n]=t.begin[r]),t.end!=null&&(e.end[n]=t.end[r]),e.strides[n]=t.strides[r],t.beginMask&1<<r&&(e.beginMask|=1<<n),t.endMask&1<<r&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(ab),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[n]=r,n++}}function ru(t,e,n,r,s,a){if(s[e])return n>0?a[e]:a[e+1&1];{const o=t<0?r+t:t;return o<a[0]?a[0]:o>a[1]?a[1]:o}}var wf=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:ob,maskToAxes:ib,computeOutShape:ub,stridesWithElidedDims:hf,getNormalizedAxes:lb,startIndicesWithElidedDims:df,stopIndicesWithElidedDims:mf,stridesForAxis:gf,startForAxis:yf,stopForAxis:bf,isSliceContinous:cb,computeFlatOffset:hb,parseSliceParams:fb,sliceInfo:pb},Symbol.toStringTag,{value:"Module"}));class vf{getClassName(){return this.constructor.className}static fromConfig(e,n){return new e(n)}}class sn{constructor(){this.classNameMap={}}static getMap(){return sn.instance==null&&(sn.instance=new sn),sn.instance}static register(e){sn.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function mn(t){S(t.className!=null,()=>"Class being registered does not have the static className property defined."),S(typeof t.className=="string",()=>"className is required to be a string, but got type "+typeof t.className),S(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),sn.register(t)}var mb=Object.freeze(Object.defineProperty({__proto__:null,Serializable:vf,SerializationMap:sn,registerClass:mn},Symbol.toStringTag,{value:"Module"}));const gb=.001,Sf=.1;function yb(t,e,n){return n==null&&(n=Co()),Ka(t,e,(r,s)=>Po(r,s,n))}function Co(){return k.backend.floatPrecision()===32?gb:Sf}function Ka(t,e,n){let r=!0;if((Ue(t)||Ue(e))&&(r=!1),Ue(t)&&Ue(e)&&(r=!0),r){const o=t.constructor.name,i=e.constructor.name;if(o!==i)throw new Error(`Arrays are of different type. Actual: ${o}. Expected: ${i}`)}if(Array.isArray(t)&&Array.isArray(e)){const o=Vt(t),i=Vt(e);if(!zt(o,i))throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${i}]`)}const s=Ue(t)?t:$n(t),a=Ue(e)?e:$n(e);if(s.length!==a.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${a.length}.
Actual:   ${s}.
Expected: ${a}.`);for(let o=0;o<a.length;++o){const i=s[o],u=a[o];if(!n(i,u))throw new Error(`Arrays differ: actual[${o}] = ${i}, expected[${o}] = ${u}.
Actual:   ${s}.
Expected: ${a}.`)}}function bb(t,e){t().then(()=>e.fail(),()=>e())}function wb(t,e){const n=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return an(t)||an(t[0])||an(e)||an(e[0])?Ka(t,n,(r,s)=>r==s):Ka(t,e,(r,s)=>Po(r,s,0))}function vb(t,e,n){if(n==null&&(n=Co()),!Po(t,e,n))throw new Error(`Numbers differ: actual === ${t}, expected === ${e}`)}function Po(t,e,n){return!isFinite(t)&&!isFinite(e)?!0:!(isNaN(t)||isNaN(e)||Math.abs(t-e)>n)}function Sb(t,e,n){for(let r=0;r<t.length;r++)if(t[r]<e||t[r]>n)throw new Error(`Value out of range:${t[r]} low: ${e}, high: ${n}`)}function Nb(t,e){const n=new Float32Array(t),r=new Float32Array(e);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let s=0;s<r.length;s++)if(n[s]!==r[s])throw new Error(`Expected ArrayBuffer value at ${s} to be ${r[s]} but got ${n[s]} instead`)}function Nf(t){for(let e=0;e<t.length;e++){const n=t[e];Array.isArray(n)?Nf(n):t[e]=Vr(n)}return t}var Tb=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:Sf,expectArraysClose:yb,testEpsilon:Co,expectPromiseToFail:bb,expectArraysEqual:wb,expectNumbersClose:vb,expectValuesInRange:Sb,expectArrayBuffersEqual:Nb,encodeStrings:Nf},Symbol.toStringTag,{value:"Module"}));const Eb="3.19.0";function kb(t,e){let n=w(t,"a","add"),r=w(e,"b","add");[n,r]=Ce(n,r);const s={a:n,b:r};return k.runKernel(po,s)}const X=E({add_:kb});function xb(t,e){let n=w(t,"a","floorDiv"),r=w(e,"b","floorDiv");[n,r]=Ce(n,r);const s={a:n,b:r};return k.runKernel(Gl,s)}const Ro=E({floorDiv_:xb});function _b(t,e){let n=w(t,"a","div"),r=w(e,"b","div");if([n,r]=Ce(n,r),n.dtype==="int32"&&r.dtype==="int32")return Ro(n,r);const s={a:n,b:r},a={};return k.runKernel(Pl,s,a)}const ke=E({div_:_b});function $b(t,e){let n=w(t,"a","mul"),r=w(e,"b","mul");[n,r]=Ce(n,r);const s={a:n,b:r};return k.runKernel(kc,s)}const U=E({mul_:$b});function Ab(t){const e=w(t,"x","abs");if(e.dtype==="complex64"){const n={x:e};return k.runKernel(gl,n)}else{const n={x:e};return k.runKernel(Ku,n)}}const rt=E({abs_:Ab});function Ib(t){const n={x:w(t,"x","acos")};return k.runKernel(Xu,n)}const Tf=E({acos_:Ib});function Ob(t){const n={x:w(t,"x","acosh")};return k.runKernel(Yu,n)}const Ef=E({acosh_:Ob});function Db(t){S(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),S(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((s,a)=>w(s,`tensors${a}`,"addN")),n=e[0];e.forEach(s=>{if(s.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!zt(s.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return k.runKernel(Zu,r)}const kf=E({addN_:Db});function Fb(t,e=null,n=!1){const s={x:w(t,"x","all","bool")},a={axis:e,keepDims:n};return k.runKernel(Ju,s,a)}const xf=E({all_:Fb});function Cb(t,e=null,n=!1){const s={x:w(t,"x","any","bool")},a={axis:e,keepDims:n};return k.runKernel(Qu,s,a)}const _f=E({any_:Cb});function Pb(t,e=0){const r={x:w(t,"x","argMax")},s={axis:e};return k.runKernel(el,r,s)}const Bo=E({argMax_:Pb});function Rb(t,e=0){const r={x:w(t,"x","argMin")},s={axis:e};return k.runKernel(tl,r,s)}const $f=E({argMin_:Rb});function Bb(t){const n={x:w(t,"x","asin")};return k.runKernel(nl,n)}const Af=E({asin_:Bb});function Lb(t){const n={x:w(t,"x","asinh")};return k.runKernel(rl,n)}const If=E({asinh_:Lb});function Mb(t){const n={x:w(t,"x","atan")};return k.runKernel(sl,n)}const Of=E({atan_:Mb});function zb(t,e){let n=w(t,"a","atan2"),r=w(e,"b","atan2");[n,r]=Ce(n,r);const s={a:n,b:r};return k.runKernel(ol,s)}const Df=E({atan2_:zb});function Vb(t){const n={x:w(t,"x","atanh")};return k.runKernel(al,n)}const Ff=E({atanh_:Vb});function jb(t,e,n,r,s="NHWC",a){const o=t[3],i=[...e,o],u=Rf(s);return qr(t,i,n,a,r,null,null,u)}function Cf(t,e,n,r,s,a,o="channelsLast"){const[i,u]=$s(e);let l;if(o==="channelsLast")l=[i,u,t[3],t[3]];else if(o==="channelsFirst")l=[i,u,t[1],t[1]];else throw new Error(`Unknown dataFormat ${o}`);return qr(t,l,n,r,s,a,!1,o)}function Ub(t,e,n,r,s,a,o="NDHWC"){const[i,u,l]=Xa(e);let c,h;if(o==="NDHWC")h="channelsLast",c=[i,u,l,t[4],t[4]];else if(o==="NCDHW")h="channelsFirst",c=[i,u,l,t[1],t[1]];else throw new Error(`Unknown dataFormat ${o}`);return Pf(t,c,n,r,s,!1,h,a)}function qr(t,e,n,r,s,a,o=!1,i="channelsLast"){let[u,l,c,h]=[-1,-1,-1,-1];if(i==="channelsLast")[u,l,c,h]=t;else if(i==="channelsFirst")[u,h,l,c]=t;else throw new Error(`Unknown dataFormat ${i}`);const[p,d,,b]=e,[v,N]=$s(n),[_,F]=$s(r),x=er(p,_),$=er(d,F),{padInfo:A,outHeight:I,outWidth:P}=Hb(s,l,c,v,N,x,$,a,i),M=o?b*h:b;let C;return i==="channelsFirst"?C=[u,M,I,P]:i==="channelsLast"&&(C=[u,I,P,M]),{batchSize:u,dataFormat:i,inHeight:l,inWidth:c,inChannels:h,outHeight:I,outWidth:P,outChannels:M,padInfo:A,strideHeight:v,strideWidth:N,filterHeight:p,filterWidth:d,effectiveFilterHeight:x,effectiveFilterWidth:$,dilationHeight:_,dilationWidth:F,inShape:t,outShape:C,filterShape:e}}function Pf(t,e,n,r,s,a=!1,o="channelsLast",i){let[u,l,c,h,p]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[u,l,c,h,p]=t;else if(o==="channelsFirst")[u,p,l,c,h]=t;else throw new Error(`Unknown dataFormat ${o}`);const[d,b,v,,N]=e,[_,F,x]=Xa(n),[$,A,I]=Xa(r),P=er(d,$),M=er(b,A),C=er(v,I),{padInfo:j,outDepth:z,outHeight:G,outWidth:K}=Gb(s,l,c,h,_,F,x,P,M,C,i),Z=a?N*p:N;let ie;return o==="channelsFirst"?ie=[u,Z,z,G,K]:o==="channelsLast"&&(ie=[u,z,G,K,Z]),{batchSize:u,dataFormat:o,inDepth:l,inHeight:c,inWidth:h,inChannels:p,outDepth:z,outHeight:G,outWidth:K,outChannels:Z,padInfo:j,strideDepth:_,strideHeight:F,strideWidth:x,filterDepth:d,filterHeight:b,filterWidth:v,effectiveFilterDepth:P,effectiveFilterHeight:M,effectiveFilterWidth:C,dilationDepth:$,dilationHeight:A,dilationWidth:I,inShape:t,outShape:ie,filterShape:e}}function Wb(t,e,n,r,s){r==null&&(r=Lo(t,e,n));const a=t[0],o=t[1],i=kn((a-e+2*r)/n+1,s),u=kn((o-e+2*r)/n+1,s);return[i,u]}function qb(t,e,n,r,s,a){s==null&&(s=Lo(t,e,r));const o=t[0],i=t[1],u=t[2],l=kn((o-e+2*s)/r+1,a),c=kn((i-e+2*s)/r+1,a),h=kn((u-e+2*s)/r+1,a);return[l,c,h,n]}function Lo(t,e,n,r=1){const s=er(e,r);return Math.floor((t[0]*(n-1)-n+s)/2)}function $s(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function Xa(t){return typeof t=="number"?[t,t,t]:t}function er(t,e){return e<=1?t:t+(t-1)*(e-1)}function Hb(t,e,n,r,s,a,o,i,u){let l,c,h;if(typeof t=="number"){l={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};const d=Wb([e,n],a,r,t,i);c=d[0],h=d[1]}else if(t==="same"){c=Math.ceil(e/r),h=Math.ceil(n/s);const p=Math.max(0,(c-1)*r+a-e),d=Math.max(0,(h-1)*s+o-n),b=Math.floor(p/2),v=p-b,N=Math.floor(d/2),_=d-N;l={top:b,bottom:v,left:N,right:_,type:"SAME"}}else if(t==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-a+1)/r),h=Math.ceil((n-o+1)/s);else if(typeof t=="object"){const p=u==="channelsLast"?t[1][0]:t[2][0],d=u==="channelsLast"?t[1][1]:t[2][1],b=u==="channelsLast"?t[2][0]:t[3][0],v=u==="channelsLast"?t[2][1]:t[3][1];l={top:p,bottom:d,left:b,right:v,type:p===0&&d===0&&b===0&&v===0?"VALID":"EXPLICIT"},c=kn((e-a+p+d)/r+1,i),h=kn((n-o+b+v)/s+1,i)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:l,outHeight:c,outWidth:h}}function Gb(t,e,n,r,s,a,o,i,u,l,c){let h,p,d,b;if(typeof t=="number"){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};const N=qb([e,n,r,1],i,1,s,t,c);p=N[0],d=N[1],b=N[2]}else if(t==="same"){p=Math.ceil(e/s),d=Math.ceil(n/a),b=Math.ceil(r/o);const v=(p-1)*s+i-e,N=(d-1)*a+u-n,_=(b-1)*o+l-r,F=Math.floor(v/2),x=v-F,$=Math.floor(N/2),A=N-$,I=Math.floor(_/2),P=_-I;h={top:$,bottom:A,left:I,right:P,front:F,back:x,type:"SAME"}}else if(t==="valid")h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},p=Math.ceil((e-i+1)/s),d=Math.ceil((n-u+1)/a),b=Math.ceil((r-l+1)/o);else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:h,outDepth:p,outHeight:d,outWidth:b}}function kn(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function Cr(t){const[e,n,r]=$s(t);return e===1&&n===1&&r===1}function Yt(t,e){return Cr(t)||Cr(e)}function Rf(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function vt(t,e,n){if(n!=null){if(typeof e=="string")throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if(typeof e=="number")S(nr(e),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(s=>{S(nr(s),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${s}.`)})});else throw Error(`Error in ${t}: Unknown padding parameter: ${e}`)}}function Kb(t,e){const r={x:w(t,"x","reshape","string_or_numeric")},s={shape:e};return k.runKernel(jc,r,s)}const B=E({reshape_:Kb});function Xb(t,e,n,r,s){const a=w(t,"x","avgPool","float32"),o=1;S(Yt(n,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);let i=a,u=!1;a.rank===3&&(u=!0,i=B(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),vt("avgPool",r,s);const l={x:i},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s};let h=k.runKernel(il,l,c);return h=we(h,a.dtype),u?B(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Mo=E({avgPool_:Xb});function Yb(t,e,n,r,s,a="NDHWC"){const o=w(t,"x","avgPool3d","float32");let i=o,u=!1;o.rank===4&&(u=!0,i=B(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),S(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),vt("avgPool3d",r,s);const l={x:i},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:a};let h=k.runKernel(ul,l,c);return h=we(h,i.dtype),u?B(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const Bf=E({avgPool3d_:Yb});function Zb(t,e=0){S(t.length>=1,()=>"Pass at least one tensor to concat");const n=Or(t,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),n.length===1)return Kt(n[0]);const r=n,s={axis:e};return k.runKernel(yl,r,s)}const We=E({concat_:Zb});function Jb(t){const n={x:w(t,"x","sigmoid","float32")};return k.runKernel(rh,n)}const Mt=E({sigmoid_:Jb});function Qb(t,e,n){const r=w(t,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:e,size:n};return k.runKernel(Qc,s,a)}const Te=E({slice_:Qb});function e1(t){const n={x:w(t,"x","tanh","float32")};return k.runKernel(Nh,n)}const As=E({tanh_:e1});function t1(t,e,n,r,s,a){const o=w(t,"forgetBias","basicLSTMCell"),i=w(e,"lstmKernel","basicLSTMCell"),u=w(n,"lstmBias","basicLSTMCell"),l=w(r,"data","basicLSTMCell"),c=w(s,"c","basicLSTMCell"),h=w(a,"h","basicLSTMCell"),p=We([l,h],1),d=ye(p,i),b=X(d,u),v=b.shape[0],N=b.shape[1]/4,_=[v,N],F=Te(b,[0,0],_),x=Te(b,[0,N],_),$=Te(b,[0,N*2],_),A=Te(b,[0,N*3],_),I=X(U(Mt(F),As(x)),U(c,Mt(X(o,$)))),P=U(As(I),Mt(A));return[I,P]}const Lf=E({basicLSTMCell_:t1});function n1(t,e,n){const r=w(t,"x","batchToSpaceND"),s=e.reduce((i,u)=>i*u);S(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),S(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),S(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const a={x:r},o={blockShape:e,crops:n};return k.runKernel(cl,a,o)}const zo=E({batchToSpaceND_:n1});function r1(t){let e;return t.rank===0||t.rank===1?e=B(t,[1,1,1,t.size]):t.rank===2?e=B(t,[1,1,t.shape[0],t.shape[1]]):t.rank===3?e=B(t,[1,t.shape[0],t.shape[1],t.shape[2]]):e=t,e}function s1(t,e,n,r,s,a){a==null&&(a=.001);const o=w(t,"x","batchNorm"),i=w(e,"mean","batchNorm"),u=w(n,"variance","batchNorm");let l;s!=null&&(l=w(s,"scale","batchNorm"));let c;r!=null&&(c=w(r,"offset","batchNorm")),S(i.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(c==null||i.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(l==null||i.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const p={x:r1(o),scale:l,offset:c,mean:i,variance:u},d={varianceEpsilon:a},b=k.runKernel(Kl,p,d);return B(b,o.shape)}const Hr=E({batchNorm_:s1});function a1(t,e,n,r,s,a){const o=w(t,"x","batchNorm"),i=w(e,"mean","batchNorm"),u=w(n,"variance","batchNorm");let l;s!=null&&(l=w(s,"scale","batchNorm"));let c;return r!=null&&(c=w(r,"offset","batchNorm")),S(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),S(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),S(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&S(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&S(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Hr(o,i,u,c,l,a)}const Mf=E({batchNorm2d_:a1});function o1(t,e,n,r,s,a){const o=w(t,"x","batchNorm"),i=w(e,"mean","batchNorm"),u=w(n,"variance","batchNorm");let l;s!=null&&(l=w(s,"scale","batchNorm"));let c;return r!=null&&(c=w(r,"offset","batchNorm")),S(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),S(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),S(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&S(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&S(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Hr(o,i,u,c,l,a)}const zf=E({batchNorm3d_:o1});function i1(t,e,n,r,s,a){const o=w(t,"x","batchNorm"),i=w(e,"mean","batchNorm"),u=w(n,"variance","batchNorm");let l;s!=null&&(l=w(s,"scale","batchNorm"));let c;return r!=null&&(c=w(r,"offset","batchNorm")),S(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),S(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),S(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&S(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&S(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Hr(o,i,u,c,l,a)}const Vf=E({batchNorm4d_:i1});function u1(t,e,n){const r=w(t,"x","bincount"),s=w(e,"weights","bincount");S(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),S(n>=0,()=>`size must be non-negative, but got ${n}.`),S(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const a={x:r,weights:s},o={size:n};return k.runKernel(hl,a,o)}const Vo=E({bincount_:u1});function l1(t,e){const n=w(t,"s0","broadcastArgs","int32"),r=w(e,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:n,s1:r};return k.runKernel(fl,s)}const jf=E({broadcastArgs_:l1});function c1(t,e){let n=w(t,"broadcastTo","x");const r=n.shape;if(e.some(l=>!(l>0)||l%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const l=n.shape.slice();for(;l.length<e.length;)l.unshift(1);n=B(n,l)}const s=n.shape,a=Array.from(e);for(let l=e.length-1;l>=0;l--)if(s[l]===e[l])a[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(a.map((l,c)=>l>1?c:-1).filter(l=>l>=0).length===0)return Kt(n);const i={x:n},u={reps:a};return k.runKernel(yo,i,u)}const xr=E({broadcastTo_:c1});function h1(t){const n={x:w(t,"x","ceil","float32")};return k.runKernel(pl,n)}const Uf=E({ceil_:h1});function f1(t,e,n){const r=w(t,"x","clipByValue");S(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`);const s={x:r},a={clipValueMin:e,clipValueMax:n};return k.runKernel(dl,s,a)}const Wf=E({clipByValue_:f1});function p1(t){return We(t,0)}const qf=E({concat1d_:p1});function d1(t,e){return We(t,e)}const Hf=E({concat2d_:d1});function m1(t,e){return We(t,e)}const Gf=E({concat3d_:m1});function g1(t,e){return We(t,e)}const Kf=E({concat4d_:g1});function y1(t,e,n,r,s="NHWC",a=[1,1],o){const i=w(t,"x","conv2d","float32"),u=w(e,"filter","conv2d","float32");let l=i,c=!1;i.rank===3&&(c=!0,l=B(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),S(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),vt("conv2d",r,o);const h=s==="NHWC"?l.shape[3]:l.shape[1];S(h===u.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${u.shape[2]}.`),S(Yt(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const p={x:l,filter:u},d={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o},b=k.runKernel(bl,p,d);return c?B(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Gr=E({conv2d_:y1});function b1(t,e,n,r,s="NWC",a=1,o){const i=w(t,"x","conv1d"),u=w(e,"filter","conv1d");let l=i,c=!1;i.rank===2&&(c=!0,l=B(i,[1,i.shape[0],i.shape[1]])),S(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),S(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),vt("conv1d",r,o),S(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),S(Yt(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),S(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=B(u,[1,u.shape[0],u.shape[1],u.shape[2]]),p=B(l,[l.shape[0],1,l.shape[1],l.shape[2]]),N=Gr(p,h,[1,n],r,"NHWC",[1,a],o);return c?B(N,[N.shape[2],N.shape[3]]):B(N,[N.shape[0],N.shape[2],N.shape[3]])}const Xf=E({conv1d_:b1});function w1(t,e,n,r,s,a="NHWC",o){S(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let i=t,u=e,l=!1;e.rank===3&&(l=!0,u=B(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,t[0],t[1],t[2]]),S(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),S(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),S(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c=a==="NHWC"?i[3]:i[1],h=a==="NHWC"?u.shape[3]:u.shape[1];S(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),S(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),vt("conv2dDerInput",s,o);const p={dy:u,filter:n},d={strides:r,pad:s,dataFormat:a,dimRoundingMode:o,inputShape:i},b=k.runKernel(vl,p,d);return l?B(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Yf=E({conv2DBackpropInput_:w1});function v1(t,e,n,r,s,a){const o=w(t,"x","conv2dTranspose"),i=w(e,"filter","conv2dTranspose");return Yf(n,o,i,r,s,"NHWC",a)}const Zf=E({conv2dTranspose_:v1});function S1(t,e,n,r,s="NDHWC",a=[1,1,1]){const o=w(t,"x","conv3d"),i=w(e,"filter","conv3d");let u=o,l=!1;o.rank===4&&(l=!0,u=B(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),S(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),S(u.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`),S(Yt(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),S(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const c={x:u,filter:i},h={strides:n,pad:r,dataFormat:s,dilations:a},p=k.runKernel(Sl,c,h);return l?B(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const Jf=E({conv3d_:S1});function N1(t,e,n,r,s){S(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let a=t,o=e,i=!1;e.rank===4&&(i=!0,o=B(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),a=[1,t[0],t[1],t[2],t[3]]);const u=a[4],l=o.shape[4];S(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),S(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),S(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),S(u===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`),S(l===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`);const c={dy:o,filter:n},h={pad:s,strides:r,inputShape:a},p=k.runKernel(Nl,c,h);return i?B(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const T1=E({conv3DBackpropInput_:N1});function E1(t,e,n,r,s){const a=w(t,"x","conv3dTranspose"),o=w(e,"filter","conv3dTranspose");return T1(n,a,o,r,s)}const Qf=E({conv3dTranspose_:E1});function k1(t){const n={x:w(t,"x","cos","float32")};return k.runKernel(Tl,n)}const ep=E({cos_:k1});function x1(t){const n={x:w(t,"x","cosh","float32")};return k.runKernel(El,n)}const tp=E({cosh_:x1});function _1(t,e=0,n=!1,r=!1){const a={x:w(t,"x","cumprod")},o={axis:e,exclusive:n,reverse:r};return k.runKernel(kl,a,o)}const np=E({cumprod_:_1});function $1(t,e=0,n=!1,r=!1){const a={x:w(t,"x","cumsum")},o={axis:e,exclusive:n,reverse:r};return k.runKernel(xl,a,o)}const rp=E({cumsum_:$1});function A1(t,e,n,r=!1){const s=w(t,"x","denseBincount"),a=w(e,"weights","denseBincount");S(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),S(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),S(n>=0,()=>`size must be non-negative, but got ${n}.`),S(a.size===s.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`);const o={x:s,weights:a},i={size:n,binaryOutput:r};return k.runKernel($l,o,i)}const sp=E({denseBincount_:A1});function I1(t,e,n="NHWC"){const r=w(t,"x","depthToSpace","float32"),s=n==="NHWC"?r.shape[1]:r.shape[2],a=n==="NHWC"?r.shape[2]:r.shape[3],o=n==="NHWC"?r.shape[3]:r.shape[1];S(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),S(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),S(a*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${e} for depthToSpace with input shape
        ${r.shape}`),S(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${r.shape}`);const i={x:r},u={blockSize:e,dataFormat:n};return k.runKernel(Al,i,u)}const ap=E({depthToSpace_:I1});function O1(t,e,n,r,s="NHWC",a=[1,1],o){const i=w(t,"x","depthwiseConv2d","float32"),u=w(e,"filter","depthwiseConv2d","float32");let l=i,c=!1;i.rank===3&&(c=!0,l=B(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),S(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const h=s==="NHWC"?l.shape[3]:l.shape[1];S(h===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${u.shape[2]}.`),vt("depthwiseConv2d",r,o);const p={x:l,filter:u},d={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o},b=k.runKernel(Il,p,d);return c?B(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const zs=E({depthwiseConv2d_:O1});function D1(t){const n={x:w(t,"x","diag")};return k.runKernel(Fl,n)}const op=E({diag_:D1});function F1(t,e,n,r,s=[1,1],a="NHWC"){const o=w(t,"x","dilation2d"),i=w(e,"filter","dilation2d");S(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),S(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),S(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let u=o,l=!1;o.rank===3&&(u=B(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=!0);const c={x:u,filter:i},h={strides:n,pad:r,dilations:s},p=k.runKernel(Cl,c,h);return l?B(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const ip=E({dilation2d_:F1});function C1(t,e){let n=w(t,"a","equal","string_or_numeric"),r=w(e,"b","equal","string_or_numeric");[n,r]=Ce(n,r),Be(n.shape,r.shape);const s={a:n,b:r};return k.runKernel(Ml,s)}const Kr=E({equal_:C1});function P1(t,e,n){const r=w(e,"a","where"),s=w(n,"b","where"),a=w(t,"condition","where","bool"),o=Be(Be(a.shape,r.shape),s.shape),i=xr(a,o),u=xr(r,o),l=xr(s,o),c={condition:i,t:u,e:l};return k.runKernel(Zc,c)}const Fn=E({where_:P1});function R1(t){const n={x:w(t,"x","zerosLike")};return k.runKernel($h,n)}const ot=E({zerosLike_:R1});function B1(t,e){let n=w(t,"a","div"),r=w(e,"b","div");[n,r]=Ce(n,r);const s=ke(n,r),a=ot(s),o=Kr(r,a);return Fn(o,a,s)}const up=E({divNoNan_:B1});function L1(t,e){const n=w(t,"t1","dot"),r=w(e,"t2","dot");S((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const s=n.rank===1?n.size:n.shape[1],a=r.rank===1?r.size:r.shape[0];if(S(s===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`),n.rank===1&&r.rank===1){const o=B(n,[1,-1]),i=B(r,[-1,1]),u=ye(o,i);return B(u,[])}else if(n.rank===1&&r.rank===2){const o=B(n,[1,-1]),i=B(r,[r.shape[0],r.shape[1]]),u=ye(o,i);return B(u,[u.size])}else if(n.rank===2&&r.rank===1){const o=B(r,[-1,1]),i=ye(n,o);return B(i,[i.size])}else{const o=B(r,[r.shape[0],r.shape[1]]);return ye(n,o)}}const lp=E({dot_:L1});function M1(t,...e){const n=e.map((s,a)=>w(s,`tensors${a}`,"einsum")),r={equation:t};return k.runKernel(Rl,n,r)}const cp=E({einsum_:M1});function z1(t){const n={x:w(t,"x","elu","float32")};return k.runKernel(Bl,n)}const jo=E({elu_:z1});function V1(t){let e=w(t,"x","erf");S(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=we(e,"float32"));const n={x:e};return k.runKernel(Ll,n)}const hp=E({erf_:V1});function Uo(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function fp(t,e,n){const r=t.length+e.length,s=[];let a=0,o=0;for(let i=0;i<r;i++)n.indexOf(i)===-1?s.push(t[a++]):s.push(e[o++]);return s}function j1(t,e){const n=[],r=t.length;for(let a=0;a<r;a++)e.indexOf(a)===-1&&n.push(t[a]);const s=e.map(a=>t[a]);return[n,s]}function Xr(t,e){const n=e.map(r=>1);return fp(t,n,e)}function U1(t,e,n){S(Uo(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function W1(t,e){if(Uo(t,e))return null;const n=[];for(let r=0;r<e;++r)t.indexOf(r)===-1&&n.push(r);return t.forEach(r=>n.push(r)),n}function q1(t){return t.map((e,n)=>[n,e]).sort((e,n)=>e[1]-n[1]).map(e=>e[0])}function H1(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}function G1(t,e=null,n=!1){const s={x:w(t,"x","max")},a={reductionIndices:e,keepDims:n};return k.runKernel(dc,s,a)}const xn=E({max_:G1});function K1(t,e=null,n=!1){const s={x:w(t,"x","min")},a={axis:e,keepDims:n};return k.runKernel(vc,s,a)}const Is=E({min_:K1});function X1(t,e){let n=w(t,"base","pow"),r=w(e,"exp","pow");[n,r]=Ce(n,r);const s={a:n,b:r};return k.runKernel(Pc,s)}const ir=E({pow_:X1});function se(t,e){if((Ue(t)&&e!=="string"||Array.isArray(t))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Ue(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return dn(t,[],[],e)}function Y1(t){const n={x:w(t,"x","sqrt","float32")};return k.runKernel(ah,n)}const Ut=E({sqrt_:Y1});function Z1(t){const e=w(t,"x","square"),n={};return k.runKernel("Square",{x:e},n)}const bt=E({square_:Z1});function J1(t,e=null,n=!1){let r=w(t,"x","sum");r.dtype==="bool"&&(r=we(r,"int32"));const s={x:r},a={axis:e,keepDims:n};return k.runKernel(oh,s,a)}const _e=E({sum_:J1});function Q1(t,e="euclidean",n=null,r=!1){t=w(t,"x","norm");const s=pp(t,e,n);let a=s.shape;if(r){const o=Mr(n,t.shape);a=Xr(s.shape,o)}return B(s,a)}function pp(t,e,n=null){if(t.rank===0)return rt(t);if(t.rank!==1&&n===null)return pp(B(t,[-1]),e,n);if(t.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(e===1)return _e(rt(t),n);if(e===1/0)return xn(rt(t),n);if(e===-1/0)return Is(rt(t),n);if(e==="euclidean"||e===2)return Ut(_e(ir(rt(t),se(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&n.length===2){if(e===1)return xn(_e(rt(t),n[0]),n[1]-1);if(e===1/0)return xn(_e(rt(t),n[1]),n[0]);if(e===-1/0)return Is(_e(rt(t),n[1]),n[0]);if(e==="fro"||e==="euclidean")return Ut(_e(bt(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Yr=E({norm_:Q1});function ew(t,e=null,n=!1){return Yr(t,"euclidean",e,n)}const dp=E({euclideanNorm_:ew});function tw(t){const n={x:w(t,"x","exp")};return k.runKernel(zl,n)}const hn=E({exp_:tw});function nw(t,e=0){const n=w(t,"x","expandDims","string_or_numeric");S(e<=n.rank,()=>"Axis must be <= rank of the tensor");const r={input:n},s={dim:e};return k.runKernel(Vl,r,s)}const st=E({expandDims_:nw});function rw(t){const n={x:w(t,"x","expm1")};return k.runKernel(jl,n)}const mp=E({expm1_:rw});function sw(t,e){const n=w(t,"x","tile","string_or_numeric");S(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);const r={x:n},s={reps:e};return k.runKernel(yo,r,s)}const tr=E({tile_:sw});function aw(t,e,n,r="float32"){e==null&&(e=t);const s=jt([t,e],r),a=t<=e?t:e;for(let i=0;i<a;++i)s.set(1,i,i);const o=B(s.toTensor(),[t,e]);if(n==null)return o;if(n.length===1)return tr(st(o,0),[n[0],1,1]);if(n.length===2)return tr(st(st(o,0),0),[n[0],n[1],1,1]);if(n.length===3)return tr(st(st(st(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const Wo=E({eye_:aw});function Zr(t,e,n){const r={shape:t,value:e,dtype:n};return k.runKernel(Wl,{},r)}function ow(t){const n={x:w(t,"x","floor","float32")};return k.runKernel(Hl,n)}const qo=E({floor_:ow});function iw(t,e,n=0,r=0){const s=w(t,"x","gather"),a=w(e,"indices","gather","int32"),o={x:s,indices:a},i={axis:n,batchDims:r};return k.runKernel(Xl,o,i)}const Ho=E({gather_:iw});function uw(t,e){let n=w(t,"a","greater","string_or_numeric"),r=w(e,"b","greater","string_or_numeric");[n,r]=Ce(n,r),Be(n.shape,r.shape);const s={a:n,b:r};return k.runKernel(Zl,s)}const hr=E({greater_:uw});function lw(t,e){let n=w(t,"a","greaterEqual","string_or_numeric"),r=w(e,"b","greaterEqual","string_or_numeric");[n,r]=Ce(n,r),Be(n.shape,r.shape);const s={a:n,b:r};return k.runKernel(Jl,s)}const Go=E({greaterEqual_:lw});function cw(t){const n={x:w(t,"x","isFinite")};return k.runKernel(tc,n)}const gp=E({isFinite_:cw});function hw(t){const n={x:w(t,"x","isInf")};return k.runKernel(nc,n)}const yp=E({isInf_:hw});function fw(t){const n={x:w(t,"x","isNaN")};return k.runKernel(rc,n)}const bp=E({isNaN_:fw});function pw(t,e=.2){const r={x:w(t,"x","leakyRelu")},s={alpha:e};return k.runKernel(sc,r,s)}const Ko=E({leakyRelu_:pw});function dw(t,e){let n=w(t,"a","less","string_or_numeric"),r=w(e,"b","less","string_or_numeric");[n,r]=Ce(n,r),Be(n.shape,r.shape);const s={a:n,b:r};return k.runKernel(ac,s)}const wp=E({less_:dw});function mw(t,e){let n=w(t,"a","lessEqual","string_or_numeric"),r=w(e,"b","lessEqual","string_or_numeric");[n,r]=Ce(n,r),Be(n.shape,r.shape);const s={a:n,b:r};return k.runKernel(oc,s)}const Vs=E({lessEqual_:mw});function vp(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:t,stop:e,num:n};return k.runKernel(ic,{},r)}function gw(t,e=5,n=1,r=1,s=.5){const a=w(t,"x","localResponseNormalization");S(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),S(nr(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=a,i=!1;a.rank===3&&(i=!0,o=B(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const u={x:o},l={depthRadius:e,bias:n,alpha:r,beta:s},c=k.runKernel(pc,u,l);return i?B(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Sp=E({localResponseNormalization_:gw});function yw(t){const n={x:w(t,"x","log","float32")};return k.runKernel(uc,n)}const ur=E({log_:yw});function bw(t){const n={x:w(t,"x","log1p")};return k.runKernel(lc,n)}const Xo=E({log1p_:bw});function ww(t){return S(cn(t),()=>"The f passed in grad(f) must be a function"),(e,n)=>{const r=w(e,"x","tf.grad","string_or_numeric"),s=n!=null?w(n,"dy","tf.grad"):null;return k.tidy(()=>{const{value:a,grads:o}=k.gradients(()=>t(r),[r],s);return s!=null&&Je(a.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),js(o),o[0]})}}function vw(t){return S(cn(t),()=>"The f passed in grads(f) must be a function"),(e,n)=>{S(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const r=Or(e,"args","tf.grads","string_or_numeric"),s=n!=null?w(n,"dy","tf.grads"):null;return k.tidy(()=>{const{value:a,grads:o}=k.gradients(()=>t(...r),r,s);return s!=null&&Je(a.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),js(o),o})}}function Sw(t){return S(cn(t),()=>"The f passed in valueAndGrad(f) must be a function"),(e,n)=>{S(e instanceof be,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),S(n==null||n instanceof be,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:r,value:s}=k.gradients(()=>t(e),[e],n);return js(r),{grad:r[0],value:s}}}function Nw(t){return S(cn(t),()=>"The f passed in valueAndGrads(f) must be a function"),(e,n)=>{S(Array.isArray(e)&&e.every(s=>s instanceof be),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),S(n==null||n instanceof be,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const r=k.gradients(()=>t(...e),e,n);return n!=null&&Je(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),js(r.grads),r}}function Np(t,e){S(cn(t),()=>"The f passed in variableGrads(f) must be a function"),S(e==null||Array.isArray(e)&&e.every(l=>l instanceof Ir),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=e!=null;if(!n){e=[];for(const l in k.registeredVariables)e.push(k.registeredVariables[l])}const r=n?e.filter(l=>!l.trainable):null,s=e.length;e=e.filter(l=>l.trainable),S(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const a=!0,{value:o,grads:i}=k.gradients(t,e,null,a);S(i.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),S(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const u={};return e.forEach((l,c)=>{i[c]!=null&&(u[l.name]=i[c])}),r?.forEach(l=>u[l.name]=null),{value:o,grads:u}}function Wt(t){return k.customGrad(t)}function js(t){if(t.filter(n=>n==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function Tw(t){const n={x:w(t,"x","softplus")};return k.runKernel(sh,n)}const Yo=E({softplus_:Tw});function Ew(t){const e=w(t,"x","logSigmoid");return Wt(r=>({value:Lt(Yo(Lt(r))),gradFunc:o=>U(o,Mt(Lt(r)))}))(e)}const Tp=E({logSigmoid_:Ew});function kw(t,e){let n=w(t,"a","sub"),r=w(e,"b","sub");[n,r]=Ce(n,r);const s={a:n,b:r};return k.runKernel(vh,s)}const ne=E({sub_:kw});function xw(t,e=-1){const n=w(t,"logits","logSoftmax");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return Wt((s,a)=>{const i=xn(s,e,!0),u=ne(s,i),l=ne(we(u,"float32"),ur(_e(hn(u),e,!0)));return a([l]),{value:l,gradFunc:(h,p)=>{const[d]=p,b=!0,v=hn(d);return ne(h,U(_e(h,e,b),v))}}})(n)}const Ep=E({logSoftmax_:xw});function _w(t,e=null,n=!1){const r=w(t,"x","logSumExp"),s=Mr(e,r.shape),a=xn(r,s,!0),o=ne(r,a),i=hn(o),u=_e(i,s),l=ur(u),c=X(B(a,l.shape),l);if(n){const h=Xr(c.shape,s);return B(c,h)}return c}const Zo=E({logSumExp_:_w});function $w(t,e){const n=w(t,"a","logicalAnd","bool"),r=w(e,"b","logicalAnd","bool");Be(n.shape,r.shape);const s={a:n,b:r};return k.runKernel(cc,s)}const Pr=E({logicalAnd_:$w});function Aw(t){const n={x:w(t,"x","logicalNot","bool")};return k.runKernel(hc,n)}const Jo=E({logicalNot_:Aw});function Iw(t,e){const n=w(t,"a","logicalOr","bool"),r=w(e,"b","logicalOr","bool");Be(n.shape,r.shape);const s={a:n,b:r};return k.runKernel(fc,s)}const Qo=E({logicalOr_:Iw});function Ow(t,e){const n=w(t,"a","logicalXor","bool"),r=w(e,"b","logicalXor","bool");return Be(n.shape,r.shape),Pr(Qo(t,e),Jo(Pr(t,e)))}const kp=E({logicalXor_:Ow});const is=2147483648;function Dw(t,e,n="left"){const r=w(t,"sortedSequence","searchSorted"),s=w(e,"values","searchSorted"),a=r.shape[r.shape.length-1],o=s.shape[s.shape.length-1],i=B(r,[-1,a]),u=B(s,[-1,o]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if($e(u.shape)>=is)throw new Error(`values tensor size must less than ${is}`);if(i.shape[1]>=is)throw new Error(`trailing dim_size must less than ${is} for int32 output type, was ${i.shape[1]}`);const l={sortedSequence:i,values:u},c={side:n};return k.runKernel(Yc,l,c)}const Us=E({searchSorted_:Dw});function xp(t,e){return Us(t,e,"left")}function Fw(t,e,n,r,s){const a=w(t,"x","maxPool"),o=1;let i=a,u=!1;a.rank===3&&(u=!0,i=B(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),S(Yt(n,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),vt("maxPool",r,s);const l={x:i},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s},h=k.runKernel(gc,l,c);return u?B(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const ei=E({maxPool_:Fw});function Cw(t,e=[1,1,1],n,r,s,a="NDHWC"){const o=w(t,"x","maxPool3d");let i=o,u=!1;o.rank===4&&(u=!0,i=B(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),S(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),vt("maxPool3d",r,s);const l={x:i},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},h=k.runKernel(yc,l,c);return u?B(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const _p=E({maxPool3d_:Cw});function Pw(t,e,n,r,s=!1){const o={x:w(t,"x","maxPoolWithArgmax")},i={filterSize:e,strides:n,pad:r,includeBatchInIndex:s},u=k.runKernel(bc,o,i);return{result:u[0],indexes:u[1]}}const $p=E({maxPoolWithArgmax_:Pw});function Rw(t,e){let n=w(t,"a","maximum"),r=w(e,"b","maximum");[n,r]=Ce(n,r),n.dtype==="bool"&&(n=we(n,"int32"),r=we(r,"int32")),Be(n.shape,r.shape);const s={a:n,b:r};return k.runKernel(mc,s)}const ti=E({maximum_:Rw});function Bw(t,e=null,n=!1){const s={x:w(t,"x","mean")},a={axis:e,keepDims:n};return k.runKernel(wc,s,a)}const Rr=E({mean_:Bw});function Cn(t,e="float32"){if(e==="complex64"){const r=Cn(t,"float32"),s=Cn(t,"float32");return Xt(r,s)}const n=Rs($e(t),e);return k.makeTensor(n,t,e)}function un(t,e="float32"){if(e==="complex64"){const r=un(t,"float32"),s=Cn(t,"float32");return Xt(r,s)}const n=lo($e(t),e);return k.makeTensor(n,t,e)}function Ap(t,e,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(t===void 0)return[];let r=w(t,"x","meshgrid",t instanceof be?t.dtype:"float32");if(e===void 0)return[r];let s=w(e,"y","meshgrid",e instanceof be?e.dtype:"float32");const a=$e(r.shape),o=$e(s.shape);return n==="xy"?(r=B(r,[1,-1]),s=B(s,[-1,1]),[ye(un([o,1],r.dtype),r),ye(s,un([1,a],s.dtype))]):(r=B(r,[-1,1]),s=B(s,[1,-1]),[ye(r,un([1,o],r.dtype)),ye(un([a,1],s.dtype),s)])}function Lw(t,e){let n=w(t,"a","minimum"),r=w(e,"b","minimum");[n,r]=Ce(n,r),n.dtype==="bool"&&(n=we(n,"int32"),r=we(r,"int32")),Be(n.shape,r.shape);const s={a:n,b:r};return k.runKernel(Sc,s)}const ni=E({minimum_:Lw});function Mw(t,e,n){S(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=w(t,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");S(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=n==="reflect"?1:0;for(let i=0;i<r.rank;i++)S(e[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),S(e[i][0]>=0&&e[i][0]<=r.shape[i]-s&&e[i][1]>=0&&e[i][1]<=r.shape[i]-s,()=>`Padding in dimension ${i} cannot be greater than or equal to ${r.shape[i]-s} or less than 0 for input of shape ${r.shape}`);const a={paddings:e,mode:n},o={x:r};return k.runKernel(Nc,o,a)}const ri=E({mirrorPad_:Mw});function zw(t,e){let n=w(t,"a","mod"),r=w(e,"b","mod");[n,r]=Ce(n,r);const s={a:n,b:r};return k.runKernel(Tc,s)}const Ip=E({mod_:zw});function Vw(t,e=null,n=!1){t=w(t,"x","moments");const r=Mr(e,t.shape),s=Rr(t,r,n);let a=s.shape;n||(a=Xr(s.shape,r));const o=bt(ne(we(t,"float32"),B(s,a))),i=Rr(o,r,n);return{mean:s,variance:i}}const Op=E({moments_:Vw});function jw(t,e,n,r){const s=w(e,"data","multiRNNCell"),a=Or(n,"c","multiRNNCell"),o=Or(r,"h","multiRNNCell");let i=s;const u=[];for(let h=0;h<t.length;h++){const p=t[h](i,a[h],o[h]);u.push(p[0]),u.push(p[1]),i=p[1]}const l=[],c=[];for(let h=0;h<u.length;h+=2)l.push(u[h]),c.push(u[h+1]);return[l,c]}const Dp=E({multiRNNCell_:jw});function Uw(t,e,n,r=!1){const s=w(t,"logits","multinomial"),a=s.size,o=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n=n||Math.random();const u={logits:o===1?B(s,[1,-1]):s},l={numSamples:e,seed:n,normalized:r},c=k.runKernel(Ec,u,l);return o===1?B(c,[c.size]):c}const Fp=E({multinomial_:Uw});function Ww(t,e){let n=w(t,"a","notEqual","string_or_numeric"),r=w(e,"b","notEqual","string_or_numeric");[n,r]=Ce(n,r),Be(n.shape,r.shape);const s={a:n,b:r};return k.runKernel(_c,s)}const si=E({notEqual_:Ww});function qw(t){const n={x:w(t,"x","onesLike")};return k.runKernel(Oc,n)}const Cp=E({onesLike_:qw});function Hw(t,e){const n=w(t,"v1","outerProduct"),r=w(e,"v2","outerProduct");S(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);const s=B(n,[-1,1]),a=B(r,[1,-1]);return ye(s,a)}const Pp=E({outerProduct_:Hw});function Gw(t,e,n=0){const r=w(t,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:n},a={x:r};return k.runKernel(Cc,a,s)}const Mn=E({pad_:Gw});function Kw(t,e,n=0){return S(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Mn(t,[e],n)}const Rp=E({pad1d_:Kw});function Xw(t,e,n=0){return S(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Mn(t,e,n)}const Bp=E({pad2d_:Xw});function Yw(t,e,n=0){return S(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Mn(t,e,n)}const ai=E({pad3d_:Yw});function Zw(t,e,n=0){return S(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Mn(t,e,n)}const Lp=E({pad4d_:Zw});function Jw(t,e,n){const r=w(t,"x","spaceToBatchND");S(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),S(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),S(r.shape.reduce((o,i,u)=>u>0&&u<=e.length?o&&(i+n[u-1][0]+n[u-1][1])%e[u-1]===0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},a={blockShape:e,paddings:n};return k.runKernel(ih,s,a)}const oi=E({spaceToBatchND_:Jw});function Qw(t,e,n,r,s,a,o){s==null&&(s=[1,1]),a==null&&(a=1),r===0&&(r="valid");const i=w(t,"x","maxPool");let u=i,l=!1;i.rank===3&&(l=!0,u=B(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(Yt(a,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`);const c=Cf(u.shape,e,a,s,r),h=[c.dilationHeight,c.dilationWidth];let p;r==="same"?p=tv([c.filterHeight,c.filterWidth],h):p=[[0,0],[0,0]];const d=h[0]===1&&h[1]===1,[b,v]=ev([c.inHeight,c.inWidth],h,p),N=d?r:"valid",_=d?u:oi(u,h,b),x=(n==="avg"?()=>Mo(_,e,a,N,o):()=>ei(_,e,a,N,o))(),$=d?x:zo(x,h,v);return l?B($,[$.shape[1],$.shape[2],$.shape[3]]):$}function ev(t,e,n){const r=n.map(c=>c[0]),s=n.map(c=>c[1]),a=t.concat(r,s),o=e.map((c,h)=>(c-a[h]%c)%c),i=s.map((c,h)=>c+o[h]),u=e.map((c,h)=>[r[h],i[h]]),l=e.map((c,h)=>[0,o[h]]);return[u,l]}function tv(t,e){const r=t.map((o,i)=>o+(o-1)*(e[i]-1)).map(o=>o-1),s=r.map(o=>Math.floor(o/2)),a=r.map((o,i)=>o-s[i]);return r.map((o,i)=>[s[i],a[i]])}const Mp=E({pool_:Qw});function nv(t,e){const n=w(t,"x","prelu"),r=w(e,"alpha","prelu"),s={x:n,alpha:r};return k.runKernel(Rc,s)}const ii=E({prelu_:nv});function rv(t,e=null,n=!1){let r=w(t,"x","prod");r.dtype==="bool"&&(r=we(r,"int32"));const s={x:r},a={axis:e,keepDims:n};return k.runKernel(Bc,s,a)}const zp=E({prod_:rv});function sv(t,e,n){const r=$e(t);let s=null;if(n==null||n==="float32")s=new Float32Array(r);else if(n==="int32")s=new Int32Array(r);else if(n==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let a=0;a<r;a++)s[a]=e();return k.makeTensor(s,t,n)}const Vp=E({rand_:sv});var jp={exports:{}};(function(t){(function(e,n,r){function s(u){var l=this,c=i();l.next=function(){var h=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=h-(l.c=h|0)},l.c=1,l.s0=c(" "),l.s1=c(" "),l.s2=c(" "),l.s0-=c(u),l.s0<0&&(l.s0+=1),l.s1-=c(u),l.s1<0&&(l.s1+=1),l.s2-=c(u),l.s2<0&&(l.s2+=1),c=null}function a(u,l){return l.c=u.c,l.s0=u.s0,l.s1=u.s1,l.s2=u.s2,l}function o(u,l){var c=new s(u),h=l&&l.state,p=c.next;return p.int32=function(){return c.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,h&&(typeof h=="object"&&a(h,c),p.state=function(){return a(c,{})}),p}function i(){var u=4022871197,l=function(c){c=String(c);for(var h=0;h<c.length;h++){u+=c.charCodeAt(h);var p=.02519603282416938*u;u=p>>>0,p-=u,p*=u,u=p>>>0,p-=u,u+=p*4294967296}return(u>>>0)*23283064365386963e-26};return l}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.alea=o})(Bt,t,!1)})(jp);var Up={exports:{}};(function(t){(function(e,n,r){function s(i){var u=this,l="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var h=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^h^h>>>8},i===(i|0)?u.x=i:l+=i;for(var c=0;c<l.length+64;c++)u.x^=l.charCodeAt(c)|0,u.next()}function a(i,u){return u.x=i.x,u.y=i.y,u.z=i.z,u.w=i.w,u}function o(i,u){var l=new s(i),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,b=(p+d)/(1<<21);while(b===0);return b},h.int32=l.next,h.quick=h,c&&(typeof c=="object"&&a(c,l),h.state=function(){return a(l,{})}),h}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xor128=o})(Bt,t,!1)})(Up);var Wp={exports:{}};(function(t){(function(e,n,r){function s(i){var u=this,l="";u.next=function(){var h=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(h^h<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,i===(i|0)?u.x=i:l+=i;for(var c=0;c<l.length+64;c++)u.x^=l.charCodeAt(c)|0,c==l.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function a(i,u){return u.x=i.x,u.y=i.y,u.z=i.z,u.w=i.w,u.v=i.v,u.d=i.d,u}function o(i,u){var l=new s(i),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,b=(p+d)/(1<<21);while(b===0);return b},h.int32=l.next,h.quick=h,c&&(typeof c=="object"&&a(c,l),h.state=function(){return a(l,{})}),h}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xorwow=o})(Bt,t,!1)})(Wp);var qp={exports:{}};(function(t){(function(e,n,r){function s(i){var u=this;u.next=function(){var c=u.x,h=u.i,p,d;return p=c[h],p^=p>>>7,d=p^p<<24,p=c[h+1&7],d^=p^p>>>10,p=c[h+3&7],d^=p^p>>>3,p=c[h+4&7],d^=p^p<<7,p=c[h+7&7],p=p^p<<13,d^=p^p<<9,c[h]=d,u.i=h+1&7,d};function l(c,h){var p,d=[];if(h===(h|0))d[0]=h;else for(h=""+h,p=0;p<h.length;++p)d[p&7]=d[p&7]<<15^h.charCodeAt(p)+d[p+1&7]<<13;for(;d.length<8;)d.push(0);for(p=0;p<8&&d[p]===0;++p);for(p==8&&(d[7]=-1),c.x=d,c.i=0,p=256;p>0;--p)c.next()}l(u,i)}function a(i,u){return u.x=i.x.slice(),u.i=i.i,u}function o(i,u){i==null&&(i=+new Date);var l=new s(i),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,b=(p+d)/(1<<21);while(b===0);return b},h.int32=l.next,h.quick=h,c&&(c.x&&a(c,l),h.state=function(){return a(l,{})}),h}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xorshift7=o})(Bt,t,!1)})(qp);var Hp={exports:{}};(function(t){(function(e,n,r){function s(i){var u=this;u.next=function(){var c=u.w,h=u.X,p=u.i,d,b;return u.w=c=c+1640531527|0,b=h[p+34&127],d=h[p=p+1&127],b^=b<<13,d^=d<<17,b^=b>>>15,d^=d>>>12,b=h[p]=b^d,u.i=p,b+(c^c>>>16)|0};function l(c,h){var p,d,b,v,N,_=[],F=128;for(h===(h|0)?(d=h,h=null):(h=h+"\0",d=0,F=Math.max(F,h.length)),b=0,v=-32;v<F;++v)h&&(d^=h.charCodeAt((v+32)%h.length)),v===0&&(N=d),d^=d<<10,d^=d>>>15,d^=d<<4,d^=d>>>13,v>=0&&(N=N+1640531527|0,p=_[v&127]^=d+N,b=p==0?b+1:0);for(b>=128&&(_[(h&&h.length||0)&127]=-1),b=127,v=4*128;v>0;--v)d=_[b+34&127],p=_[b=b+1&127],d^=d<<13,p^=p<<17,d^=d>>>15,p^=p>>>12,_[b]=d^p;c.w=N,c.X=_,c.i=b}l(u,i)}function a(i,u){return u.i=i.i,u.w=i.w,u.X=i.X.slice(),u}function o(i,u){i==null&&(i=+new Date);var l=new s(i),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,b=(p+d)/(1<<21);while(b===0);return b},h.int32=l.next,h.quick=h,c&&(c.X&&a(c,l),h.state=function(){return a(l,{})}),h}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xor4096=o})(Bt,t,!1)})(Hp);var Gp={exports:{}};(function(t){(function(e,n,r){function s(i){var u=this,l="";u.next=function(){var h=u.b,p=u.c,d=u.d,b=u.a;return h=h<<25^h>>>7^p,p=p-d|0,d=d<<24^d>>>8^b,b=b-h|0,u.b=h=h<<20^h>>>12^p,u.c=p=p-d|0,u.d=d<<16^p>>>16^b,u.a=b-h|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,i===Math.floor(i)?(u.a=i/4294967296|0,u.b=i|0):l+=i;for(var c=0;c<l.length+20;c++)u.b^=l.charCodeAt(c)|0,u.next()}function a(i,u){return u.a=i.a,u.b=i.b,u.c=i.c,u.d=i.d,u}function o(i,u){var l=new s(i),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,b=(p+d)/(1<<21);while(b===0);return b},h.int32=l.next,h.quick=h,c&&(typeof c=="object"&&a(c,l),h.state=function(){return a(l,{})}),h}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.tychei=o})(Bt,t,!1)})(Gp);var Kp={exports:{}};(function(t){(function(e,n,r){var s=256,a=6,o=52,i="random",u=r.pow(s,a),l=r.pow(2,o),c=l*2,h=s-1,p;function d($,A,I){var P=[];A=A==!0?{entropy:!0}:A||{};var M=_(N(A.entropy?[$,x(n)]:$??F(),3),P),C=new b(P),j=function(){for(var z=C.g(a),G=u,K=0;z<l;)z=(z+K)*s,G*=s,K=C.g(1);for(;z>=c;)z/=2,G/=2,K>>>=1;return(z+K)/G};return j.int32=function(){return C.g(4)|0},j.quick=function(){return C.g(4)/4294967296},j.double=j,_(x(C.S),n),(A.pass||I||function(z,G,K,Z){return Z&&(Z.S&&v(Z,C),z.state=function(){return v(C,{})}),K?(r[i]=z,G):z})(j,M,"global"in A?A.global:this==r,A.state)}function b($){var A,I=$.length,P=this,M=0,C=P.i=P.j=0,j=P.S=[];for(I||($=[I++]);M<s;)j[M]=M++;for(M=0;M<s;M++)j[M]=j[C=h&C+$[M%I]+(A=j[M])],j[C]=A;(P.g=function(z){for(var G,K=0,Z=P.i,ie=P.j,pe=P.S;z--;)G=pe[Z=h&Z+1],K=K*s+pe[h&(pe[Z]=pe[ie=h&ie+G])+(pe[ie]=G)];return P.i=Z,P.j=ie,K})(s)}function v($,A){return A.i=$.i,A.j=$.j,A.S=$.S.slice(),A}function N($,A){var I=[],P=typeof $,M;if(A&&P=="object")for(M in $)try{I.push(N($[M],A-1))}catch{}return I.length?I:P=="string"?$:$+"\0"}function _($,A){for(var I=$+"",P,M=0;M<I.length;)A[h&M]=h&(P^=A[h&M]*19)+I.charCodeAt(M++);return x(A)}function F(){try{var $;return p&&($=p.randomBytes)?$=$(s):($=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues($)),x($)}catch{var A=e.navigator,I=A&&A.plugins;return[+new Date,e,I,e.screen,x(n)]}}function x($){return String.fromCharCode.apply(0,$)}if(_(r.random(),n),t.exports){t.exports=d;try{p=require("crypto")}catch{}}else r["seed"+i]=d})(typeof self<"u"?self:Bt,[],Math)})(Kp);var av=jp.exports,ov=Up.exports,iv=Wp.exports,uv=qp.exports,lv=Hp.exports,cv=Gp.exports,zn=Kp.exports;zn.alea=av;zn.xor128=ov;zn.xorwow=iv;zn.xorshift7=uv;zn.xor4096=lv;zn.tychei=cv;var ui=zn;class li{constructor(e,n,r,s,a){this.mean=e,this.stdDev=n,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=a||Math.random();this.random=ui.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,n,r=!1;for(;!r;){let s,a,o;do s=2*this.random()-1,a=2*this.random()-1,o=s*s+a*a;while(o>=1||o===0);const i=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*s*i,n=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class hv{constructor(e,n,r,s){this.alpha=e,this.beta=1/n,this.dtype=r;const a=s||Math.random();this.randu=ui.alea(a.toString()),this.randn=new li(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,n,r,s,a,o;for(;;){do s=this.randn.nextValue(),o=1+this.c*s;while(o<=0);if(o*=o*o,e=s*s,n=1-.331*e*e,r=.5*e+this.d*(1-o+Math.log(o)),a=this.randu(),a<n||Math.log(a)<r)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class fv{constructor(e=0,n=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=n-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);this.random=ui.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function pv(t,e,n=1,r="float32",s){if(n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const a=new hv(e,n,r,s),o=jt(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const Xp=E({randomGamma_:pv});function dv(t,e=0,n=1,r,s){if(r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const a=new li(e,n,r,!1,s),o=jt(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const ci=E({randomNormal_:dv});function mv(t,e,n){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return ci(t,0,1,e,n)}const Yp=E({randomStandardNormal_:mv});function gv(t,e=0,n=1,r="float32",s){const a=jt(t,r),o=new fv(e,n,null,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const hi=E({randomUniform_:gv});function fn(t,e,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");const s={start:t,stop:e,step:n,dtype:r};return k.runKernel(Lc,{},s)}function yv(t){const n={x:w(t,"x","reciprocal")};return k.runKernel(zc,n)}const Zp=E({reciprocal_:yv});function bv(t){const n={x:w(t,"x","relu")};return k.runKernel(Vc,n)}const Jr=E({relu_:bv});function wv(t){const n={x:w(t,"x","relu6")};return k.runKernel(qc,n)}const fi=E({relu6_:wv});function vv(t,e){const r={x:w(t,"x","reverse")},s={dims:e};return k.runKernel(Hc,r,s)}const pn=E({reverse_:vv});function Sv(t){const e=w(t,"x","reverse");return S(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),pn(e,0)}const Jp=E({reverse1d_:Sv});function Nv(t,e){const n=w(t,"x","reverse");return S(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),pn(n,e)}const Qp=E({reverse2d_:Nv});function Tv(t,e){const n=w(t,"x","reverse");return S(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),pn(n,e)}const ed=E({reverse3d_:Tv});function Ev(t,e){const n=w(t,"x","reverse");return S(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),pn(n,e)}const td=E({reverse4d_:Ev});function kv(t){const n={x:w(t,"x","round")};return k.runKernel(Gc,n)}const pi=E({round_:kv});function xv(t){const n={x:w(t,"x","rsqrt","float32")};return k.runKernel(Kc,n)}const nd=E({rsqrt_:xv});function _v(t){const n={x:w(t,"x","selu")};return k.runKernel(Jc,n)}const rd=E({selu_:_v});function $v(t,e,n,r,s,a=[1,1],o="NHWC"){const i=w(t,"x","separableConv2d"),u=w(e,"depthwiseFilter","separableConv2d"),l=w(n,"pointwiseFilter","separableConv2d");let c=i,h=!1;if(i.rank===3&&(h=!0,c=B(i,[1,i.shape[0],i.shape[1],i.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");S(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),S(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),S(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),S(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),S(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);const p=u.shape[2],d=u.shape[3];S(l.shape[2]===p*d,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*d}, but got ${l.shape[2]}.`);const b=zs(c,u,r,s,o,a),N=Gr(b,l,1,"valid",o);return h?B(N,[N.shape[1],N.shape[2],N.shape[3]]):N}const sd=E({separableConv2d_:$v});async function Av(t,e){const n=w(t,"x","setdiff1d"),r=w(e,"y","setdiff1d");S(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),S(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),S(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await n.data(),a=await r.data(),o=new Set(a);let i=0;for(let c=0;c<s.length;c++)o.has(s[c])||i++;const u=new xs([i],n.dtype),l=new xs([i],"int32");for(let c=0,h=0;c<s.length;c++)o.has(s[c])||(u.values[h]=s[c],l.values[h]=c,h++);return[u.toTensor(),l.toTensor()]}const ad=Av;function Iv(t){const n={x:w(t,"x","sign")};return k.runKernel(nh,n)}const od=E({sign_:Iv});function Ov(t){const n={x:w(t,"x","sin","float32")};return k.runKernel(eh,n)}const id=E({sin_:Ov});function Dv(t){const n={x:w(t,"x","sinh")};return k.runKernel(th,n)}const ud=E({sinh_:Dv});function Fv(t,e,n){const r=w(t,"x","slice1d");return S(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Te(r,[e],[n])}const ld=E({slice1d_:Fv});function Cv(t,e,n){const r=w(t,"x","slice2d");return S(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Te(r,e,n)}const cd=E({slice2d_:Cv});function Pv(t,e,n){const r=w(t,"x","slice3d");return S(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Te(r,e,n)}const hd=E({slice3d_:Pv});function Rv(t,e,n){const r=w(t,"x","slice4d");return S(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Te(r,e,n)}const fd=E({slice4d_:Rv});function Bv(t,e=-1){const n=w(t,"logits","softmax","float32");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const r={logits:n},s={dim:e};return k.runKernel(lh,r,s)}const pd=E({softmax_:Bv});function Lv(t){S(t.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);const e={input:t};return k.runKernel(Ul,e)}const Ws=E({fft_:Lv});function Mv(t){S(t.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);const e={input:t};return k.runKernel(Ql,e)}const Br=E({ifft_:Mv});function zv(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const s=B(t,[n,e]);r=Br(s)}else{const s=[n,2*(e-1)],a=B(or(t),[n,e]),o=B(Ur(t),[n,e]),i=pn(Te(a,[0,1],[n,e-2]),1),u=U(pn(Te(o,[0,1],[n,e-2]),1),se(-1)),l=We([a,i],1),c=We([o,u],1),h=B(Xt(l,c),[s[0],s[1]]);r=Br(h)}if(r=or(r),t.rank===3&&t.shape[0]!==0){const s=r,a=t.shape[0];r=B(r,[a,r.shape[0]/a,r.shape[1]]),s.dispose()}return r}const di=E({irfft_:zv});function Vv(t,e,n=0){const s={x:w(t,"x","split")},a={numOrSizeSplits:e,axis:n};return k.runKernel(uh,s,a)}const lr=E({split_:Vv});function jv(t,e){S(t.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const r=t.size/n;let s;if(e!=null&&e<n){const b=t.shape.map(N=>0),v=t.shape.map(N=>N);v[t.shape.length-1]=e,s=Te(t,b,v),n=e}else if(e!=null&&e>n){const b=t.shape.map(v=>v);b[t.shape.length-1]=e-n,s=We([t,Cn(b)],t.shape.length-1),n=e}else s=t;const a=ot(s),o=B(Xt(s,a),[r,n]),i=Ws(o),u=Math.floor(n/2)+1,l=or(i),c=Ur(i),h=lr(l,[u,n-u],l.shape.length-1),p=lr(c,[u,n-u],c.shape.length-1),d=s.shape.slice();return d[s.shape.length-1]=u,B(Xt(h[0],p[0]),d)}const qs=E({rfft_:jv});function Uv(t,e){let n=w(t,"a","squaredDifference"),r=w(e,"b","squaredDifference");[n,r]=Ce(n,r),Be(n.shape,r.shape);const s={a:n,b:r},a={};return k.runKernel(mh,s,a)}const mi=E({squaredDifference_:Uv});function Wv(t,e){const n=w(t,"x","squeeze","string_or_numeric");return B(n,Bu(n.shape,e).newShape)}const mt=E({squeeze_:Wv});function qv(t,e=0){const n=Or(t,"tensors","stack","string_or_numeric");S(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&S(e<=n[0].rank,()=>"Axis must be <= rank of the tensor");const r=n,s={axis:e};return k.runKernel(Fc,r,s)}const qt=E({stack_:qv});function Hv(t,e=0){const r={x:w(t,"x","step")},s={alpha:e};return k.runKernel(Ah,r,s)}const gi=E({step_:Hv});function Gv(t,e,n,r,s=0,a=0,o=0,i=0,u=0){const c={x:w(t,"x","stridedSlice","string_or_numeric")},h={begin:e,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};return k.runKernel(gh,c,h)}const dd=E({stridedSlice_:Gv});function Kv(t){const n={x:w(t,"x","tan","float32")};return k.runKernel(Sh,n)}const md=E({tan_:Kv});function gt(t,e){Bn(t);const n=Vt(t,e);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return dn(t,null,n,e)}function _n(t,e,n){if(Bn(t),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=Vt(t,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return dn(t,e,r,n)}function gd(t,e,n){if(Bn(t),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=Vt(t,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return dn(t,e,r,n)}function yd(t,e,n){if(Bn(t),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=Vt(t,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return dn(t,e,r,n)}function bd(t,e,n){if(Bn(t),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=Vt(t,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,dn(t,e,r,n)}function Xv(t,e=1,n=!0){const r=w(t,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const a={x:r},o={k:e,sorted:n},[i,u]=k.runKernel(Th,a,o);return{values:i,indices:u}}const wd=E({topk_:Xv});function Yv(t,e=0,n=1,r,s){if(r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new li(e,n,r,!0,s),o=jt(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const vd=E({truncatedNormal_:Yv});function Zv(t,e=0){const n=w(t,"x","unique","string_or_numeric");S(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},s={axis:e},[a,o]=k.runKernel(kh,r,s);return{values:a,indices:o}}const Sd=E({unique_:Zv});function Jv(t,e,n){const r=w(t,"x","unsortedSegmentSum"),s=w(e,"segmentIds","unsortedSegmentSum","int32");S(nr(n),()=>"numSegments must be of dtype int");const a={x:r,segmentIds:s},o={numSegments:n};return k.runKernel(_h,a,o)}const Nd=E({unsortedSegmentSum_:Jv});function Qv(t,e=0){const n=w(t,"x","unstack","string_or_numeric");S(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);const r={value:n},s={axis:e};return k.runKernel(xh,r,s)}const gn=E({unstack_:Qv});function Td(t,e){return Us(t,e,"right")}function Ed(t,e=!0,n,r){return k.makeVariable(t,e,n,r)}function kd(t,e){const n=[];for(let a=0;a<e.length;a++)e[a]&&n.push(a);const r=jt(t,"int32"),s=jt([n.length,t.length],"int32");for(let a=0;a<n.length;a++){const o=r.indexToLoc(n[a]),i=a*t.length;s.values.set(o,i)}return s.toTensor()}async function e2(t){const e=w(t,"condition","whereAsync","bool"),n=await e.data(),r=kd(e.shape,n);return t!==e&&e.dispose(),r}const yi=e2;async function t2(t,e,n){const r=w(t,"tensor","boolMask"),s=w(e,"mask","boolMask","bool"),a=n??0,o=s.rank,i=r.shape;S(o>0,()=>"mask cannot be scalar"),Je(i.slice(a,a+o),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let v=a;v<a+o;v++)u*=i[v];const l=i.slice(0,a).concat([u],i.slice(a+o)),c=B(r,l),h=B(s,[-1]),p=await yi(h),d=mt(p,[1]),b=Ho(c,d,a);return t!==r&&r.dispose(),e!==s&&s.dispose(),d.dispose(),c.dispose(),h.dispose(),p.dispose(),b}const xd=t2;function n2(t,e,n,r,s=!0){const a=w(t,"v","movingAverage"),o=w(e,"x","movingAverage"),i=w(n,"decay","movingAverage");Mh(a,o),S(zt(a.shape,o.shape),()=>"Shape mismatch in v and x");const u=se(1),l=ne(u,i);let c=U(ne(o,a),l);if(s){S(r!=null,()=>"When using zeroDebias: true, step is required.");const h=w(r,"step","movingAverage");c=ke(c,ne(u,ir(i,h)))}return X(a,c)}const _d=E({movingAverage_:n2});function r2(t,e,n){const r=w(t,"indices","scatterND","int32"),s=w(e,"updates","scatterND");Fo(s,r,n);const a={indices:r,updates:s},o={shape:n};return k.runKernel(Xc,a,o)}const $d=E({scatterND_:r2});function s2(t,e,n,r){if(t.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const s=t.rank>0?t.shape[0]:1,a=t.rank>1?t.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function a2(t,e,n,r=0){const s=w(t,"sparseIndices","sparseToDense","int32"),a=w(e,"sparseValues","sparseToDense","string_or_numeric"),o=w(r,"defaultValue","sparseToDense",a.dtype);s2(s,a,n,o);const i={sparseIndices:s,sparseValues:a,defaultValue:o},u={outputShape:n};return k.runKernel(dh,i,u)}const Ad=E({sparseToDense_:a2});function o2(t,e){const n=w(e,"indices","gatherND","int32"),s={params:w(t,"x","gatherND","string_or_numeric"),indices:n};return k.runKernel(Yl,s)}const Id=E({gatherND_:o2});function i2(t,e){if(e==null)return t.shape.slice();if(zt(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)e[r]==null&&t.shape[r]!=null?n.push(t.shape[r]):n.push(e[r]);return n}return e}function u2(t,e,n,r){const s=w(t,"x","dropout");if(S(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),S(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return t instanceof be?s.clone():s;const a=i2(s,n),o=1-e,i=ke(qo(X(hi(a,0,1,"float32",r),o)),o);return U(s,i)}const Od=E({dropout_:u2});function bi(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function Hs(t,e,n){const r=1-t%2,s=new Float32Array(t);for(let a=0;a<t;++a){const o=2*Math.PI*a/(t+r-1);s[a]=e-n*Math.cos(o)}return gt(s,"float32")}async function l2(t,e,n=1){const r=w(t,"predictions","inTopK"),s=w(e,"targets","inTopK");S(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),S(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),Je(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=r.shape[r.shape.length-1];S(n>0&&n<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`);const o=await r.data(),i=await s.data(),[u,l]=[o.length/a,a],c=Lu("bool",u);for(let h=0;h<u;h++){const p=h*l,d=o.subarray(p,p+l),b=[];for(let v=0;v<d.length;v++)b.push({value:d[v],index:v});b.sort((v,N)=>N.value-v.value),c[h]=0;for(let v=0;v<n;v++)if(b[v].index===i[h]){c[h]=1;break}}return t!==r&&r.dispose(),e!==s&&s.dispose(),yt(c,s.shape,"bool")}const Dd=l2;function c2(t,e,n,r,s,a="NHWC",o){let i=t;t.rank===3&&(i=B(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u=e;u.rank===3&&(u=B(e,[1,e.shape[0],e.shape[1],e.shape[2]])),S(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),S(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),S(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const l=a==="NHWC"?i.shape[3]:i.shape[1],c=a==="NHWC"?u.shape[3]:u.shape[1];S(l===n[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`),S(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),vt("conv2dDerFilter",s,o);const h={x:i,dy:u},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:o,filterShape:n};return k.runKernel(wl,h,p)}const h2=E({conv2DBackpropFilter_:c2});function Gs(t,e,n){if(n==null||n==="linear")return t;if(n==="relu")return U(t,gi(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Ks(t,e){let n=e;const r=Io(t.shape,e.shape);return r.length>0&&(n=_e(n,r)),B(n,t.shape)}function Xs(t,e,n,r){if(e==="linear")return t;if(e==="relu")return Jr(t);if(e==="elu")return jo(t);if(e==="relu6")return fi(t);if(e==="prelu")return ii(t,n);if(e==="leakyrelu")return Ko(t,r);if(e==="sigmoid")return Mt(t);throw new Error(`Unknown fused activation ${e}.`)}const Ys=(t,e)=>!(t>0)||e==="linear";function f2({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(u=u||"linear",Ys(k.state.gradientDepth,u)===!1){S(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let I=Gr(t,e,n,r,s,a,o);return i!=null&&(I=X(I,i)),Xs(I,u,l,c)}const h=w(t,"x","conv2d","float32"),p=w(e,"filter","conv2d","float32");let d=h,b=!1;h.rank===3&&(b=!0,d=B(h,[1,h.shape[0],h.shape[1],h.shape[2]])),S(d.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`),S(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),vt("fused conv2d",r,o);const v=s==="NHWC"?d.shape[3]:d.shape[1];S(p.shape[2]===v,()=>`Error in conv2d: depth of input (${v}) must match input depth for filter ${p.shape[2]}.`),S(Yt(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const N=qr(d.shape,p.shape,n,a,r,o);let _;i!=null&&(_=w(i,"bias","fused conv2d"),[_]=Ce(_,h),s==="NHWC"?Be(N.outShape,_.shape):(S(_.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${_.shape.length}.`),S(_.shape.length===0||_.shape[0]===N.outChannels||_.shape[0]===1,()=>`Error in fused conv2d: bias shape (${_.shape}) is not compatible with the number of output channels (${N.outChannels})`)));let F;if(l!=null){const I=l.shape;if(S(I.length<=1||I.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${I.length}.`),I.length===1)S(I[0]===1||I[0]===N.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the number of output channels (${N.outChannels}).`);else if(I.length===3)try{Be(I,N.outShape)}catch{const M=`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the output shape of the conv2d (${N.outShape}).`;throw Error(M)}F=w(l,"prelu weights","fused conv2d")}const x=(I,P)=>{S(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[M,C,j,z]=P,G=Gs(I,j,u);S(Cr(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const K=Yf(C.shape,G,M,n,r),Z=h2(C,G,M.shape,n,r),ie=[K,Z];if(z!=null){const pe=Ks(z,G);ie.push(pe)}return ie},$={x:d,filter:p,bias:_,preluActivationWeights:F},A={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:c};return i==null?Wt((P,M,C)=>{let j=k.runKernel(Ia,$,A);return C([M,P,j]),b&&(j=B(j,[j.shape[1],j.shape[2],j.shape[3]])),{value:j,gradFunc:x}})(d,p):Wt((P,M,C,j)=>{let z=k.runKernel(Ia,$,A);return j([M,P,z,C]),b&&(z=B(z,[z.shape[1],z.shape[2],z.shape[3]])),{value:z,gradFunc:x}})(d,p,_)}const p2=E({fusedConv2d_:f2});function d2(t,e,n,r,s,a=[1,1],o){let i=t;t.rank===3&&(i=B(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u=e;u.rank===3&&(u=B(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={x:i,dy:u},c={strides:r,pad:s,dimRoundingMode:o,dilations:a,filterShape:n};return k.runKernel(Ol,l,c)}const m2=E({depthwiseConv2dNativeBackpropFilter_:d2});function g2(t,e,n,r,s,a=[1,1],o){let i=e,u=!1;e.rank===3&&(u=!0,i=B(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={dy:i,filter:n},c={strides:r,pad:s,dimRoundingMode:o,dilations:a,inputShape:t},h=k.runKernel(Dl,l,c);return u?B(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const y2=E({depthwiseConv2dNativeBackpropInput_:g2});function b2({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(Ys(k.state.gradientDepth,u)===!1){let A=zs(t,e,n,r,s,a,o);return i!=null&&(A=X(A,i)),Xs(A,u,l,c)}const h=w(t,"x","depthwiseConv2d","float32"),p=w(e,"filter","depthwiseConv2d","float32");let d=h,b=!1;h.rank===3&&(b=!0,d=B(h,[1,h.shape[0],h.shape[1],h.shape[2]])),S(d.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),S(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),S(d.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),a==null&&(a=[1,1]),S(Yt(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),vt("fused depthwiseConv2d",r,o);const v=qr(d.shape,p.shape,n,a,r,o,!0);let N;i!=null&&(N=w(i,"bias","fused conv2d"),[N]=Ce(N,h),Be(v.outShape,N.shape));let _;l!=null&&(_=w(l,"prelu weights","fused depthwiseConv2d"));const F=(A,I)=>{S(Cr(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[P,M,C,j]=I,z=Gs(A,C,u),G=y2(M.shape,z,P,n,r,a,o),K=m2(M,z,P.shape,n,r,a,o);if(j!=null){const Z=Ks(N,z);return[G,K,Z]}return[G,K]},x={x:d,filter:p,bias:N,preluActivationWeights:_},$={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:c};return i==null?Wt((I,P,M)=>{let C=k.runKernel(Oa,x,$);return M([P,I,C]),b&&(C=B(C,[C.shape[1],C.shape[2],C.shape[3]])),{value:C,gradFunc:F}})(d,p):Wt((I,P,M,C)=>{let j=k.runKernel(Oa,x,$);return C([P,I,j,M]),b&&(j=B(j,[j.shape[1],j.shape[2],j.shape[3]])),{value:j,gradFunc:F}})(d,p,N)}const w2=E({fusedDepthwiseConv2d_:b2});function v2({a:t,b:e,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:o,leakyreluAlpha:i=.2}){if(Ys(k.state.gradientDepth,a)===!1){let z=ye(t,e,n,r);return s!=null&&(z=X(z,s)),Xs(z,a,o,i)}let u=w(t,"a","fused matMul"),l=w(e,"b","fused matMul");[u,l]=Ce(u,l);const c=n?u.shape[u.rank-2]:u.shape[u.rank-1],h=r?l.shape[l.rank-1]:l.shape[l.rank-2],p=n?u.shape[u.rank-1]:u.shape[u.rank-2],d=r?l.shape[l.rank-2]:l.shape[l.rank-1],b=u.shape.slice(0,-2),v=l.shape.slice(0,-2),N=$e(b),_=$e(v);S(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${n} and transposeB=${r} must match.`);const x=Be(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([p,d]),$=n?B(u,[N,c,p]):B(u,[N,p,c]),A=r?B(l,[_,d,h]):B(l,[_,h,d]);let I;s!=null&&(I=w(s,"bias","fused matMul"),[I]=Ce(I,u),Be(x,I.shape));let P;o!=null&&(P=w(o,"prelu weights","fused matMul"));const M=(z,G)=>{const[K,Z,ie,pe]=G,Oe=Gs(B(z,ie.shape),ie,a);let Ve,je;if(!n&&!r?(Ve=ye(Oe,Z,!1,!0),je=ye(K,Oe,!0,!1)):!n&&r?(Ve=ye(Oe,Z,!1,!1),je=ye(Oe,K,!0,!1)):n&&!r?(Ve=ye(Z,Oe,!1,!0),je=ye(K,Oe,!1,!1)):(Ve=ye(Z,Oe,!0,!0),je=ye(Oe,K,!0,!0)),s!=null){const Ot=Ks(pe,Oe);return[Ve,je,Ot]}else return[Ve,je]},C={a:$,b:A,bias:I,preluActivationWeights:P},j={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:i};return s==null?Wt((G,K,Z)=>{const ie=k.runKernel(Aa,C,j);return Z([G,K,ie]),{value:B(ie,x),gradFunc:M}})($,A):Wt((G,K,Z,ie)=>{const pe=k.runKernel(Aa,C,j);return ie([G,K,pe,Z]),{value:B(pe,x),gradFunc:M}})($,A,I)}const S2=E({fusedMatMul_:v2});var Fd=Object.freeze(Object.defineProperty({__proto__:null,conv2d:p2,depthwiseConv2d:w2,matMul:S2},Symbol.toStringTag,{value:"Module"}));function N2(t){return Hs(t,.54,.46)}const T2=E({hammingWindow_:N2});function E2(t){return Hs(t,.5,.5)}const Cd=E({hannWindow_:E2});function k2(t,e,n,r=!1,s=0){let a=0;const o=[];for(;a+e<=t.size;)o.push(Te(t,a,e)),a+=n;if(r)for(;a<t.size;){const i=a+e-t.size,u=We([Te(t,a,e-i),Zr([i],s)]);o.push(u),a+=n}return o.length===0?_n([],[0,e]):B(We(o),[o.length,e])}const Pd=E({frame_:k2});function x2(t,e,n,r,s=Cd){r==null&&(r=bi(e));const a=Pd(t,e,n),o=U(a,s(e));return qs(o,r)}const _2=E({stft_:x2});function $2(t,e,n,r,s="bilinear",a=0){const o=w(t,"image","cropAndResize"),i=w(e,"boxes","cropAndResize","float32"),u=w(n,"boxInd","cropAndResize","int32"),l=i.shape[0];S(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),S(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${i.shape}.`),S(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${i.shape}.`),S(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),S(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),S(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const c={image:o,boxes:i,boxInd:u},h={method:s,extrapolationValue:a,cropSize:r};return k.runKernel(_l,c,h)}const A2=E({cropAndResize_:$2});function I2(t){const e=w(t,"image","flipLeftRight","float32");S(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const n={image:e};return k.runKernel(ql,n,{})}const O2=E({flipLeftRight_:I2});function D2(t){const e=w(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];S(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),S(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,n),s[n]=3,tr(e,s)}const F2=E({grayscaleToRGB_:D2});function C2(t,e,n=0,r=.5){const s=w(t,"image","rotateWithOffset","float32");S(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const a={image:s},o={radians:e,fillValue:n,center:r};return k.runKernel(Ih,a,o)}const P2=E({rotateWithOffset_:C2});function fr(t,e,n,r,s,a){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),a==null&&(a=0);const o=t.shape[0];return n=Math.min(n,o),S(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),S(t.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),S(t.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),S(e.rank===1,()=>"scores must be a 1D tensor"),S(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),S(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}function R2(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=w(t,"boxes","nonMaxSuppression","float32"),o=w(e,"scores","nonMaxSuppression","float32"),i=fr(a,o,n,r,s);n=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;const u={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return k.runKernel($c,{boxes:a,scores:o},u)}const B2=E({nonMaxSuppression_:R2});function L2(t,e,n){const r=M2(t,e,n),s=r<0?-(r+1):r;t.splice(s,0,e)}function M2(t,e,n){return V2(t,e,n||z2)}function z2(t,e){return t>e?1:t<e?-1:0}function V2(t,e,n){let r=0,s=t.length,a=0,o=!1;for(;r<s;){a=r+(s-r>>>1);const i=n(e,t[a]);i>0?r=a+1:(s=a,o=!i)}return o?r:-r-1}function Rd(t,e,n,r,s){return wi(t,e,n,r,s,0)}function Bd(t,e,n,r,s,a){return wi(t,e,n,r,s,0,!1,a,!0)}function Ld(t,e,n,r,s,a){return wi(t,e,n,r,s,a,!0)}function wi(t,e,n,r,s,a,o=!1,i=!1,u=!1){const l=[];for(let N=0;N<e.length;N++)e[N]>s&&l.push({score:e[N],boxIndex:N,suppressBeginIndex:0});l.sort(su);const c=a>0?-.5/a:0,h=[],p=[];for(;h.length<n&&l.length>0;){const N=l.pop(),{score:_,boxIndex:F,suppressBeginIndex:x}=N;if(_<s)break;let $=!1;for(let A=h.length-1;A>=x;--A){const I=j2(t,F,h[A]);if(I>=r){$=!0;break}if(N.score=N.score*U2(r,c,I),N.score<=s)break}N.suppressBeginIndex=h.length,$||(N.score===_?(h.push(F),p.push(N.score)):N.score>s&&L2(l,N,su))}const d=h.length,b=n-d;i&&b>0&&(h.push(...new Array(b).fill(0)),p.push(...new Array(b).fill(0)));const v={selectedIndices:h};return o&&(v.selectedScores=p),u&&(v.validOutputs=d),v}function j2(t,e,n){const r=t.subarray(e*4,e*4+4),s=t.subarray(n*4,n*4+4),a=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),p=Math.max(s[1],s[3]),d=(i-a)*(u-o),b=(h-l)*(p-c);if(d<=0||b<=0)return 0;const v=Math.max(a,l),N=Math.max(o,c),_=Math.min(i,h),F=Math.min(u,p),x=Math.max(_-v,0)*Math.max(F-N,0);return x/(d+b-x)}function U2(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function su(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}async function W2(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=w(t,"boxes","nonMaxSuppressionAsync"),o=w(e,"scores","nonMaxSuppressionAsync"),i=fr(a,o,n,r,s);n=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;const u=await Promise.all([a.data(),o.data()]),l=u[0],c=u[1],{selectedIndices:h}=Rd(l,c,n,r,s);return a!==t&&a.dispose(),o!==e&&o.dispose(),gt(h,"int32")}const q2=W2;function H2(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const o=w(t,"boxes","nonMaxSuppression"),i=w(e,"scores","nonMaxSuppression"),u=fr(o,i,n,r,s,a);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;const l={boxes:o,scores:i},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},h=k.runKernel(Ic,l,c);return{selectedIndices:h[0],selectedScores:h[1]}}const G2=E({nonMaxSuppressionWithScore_:H2});async function K2(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const o=w(t,"boxes","nonMaxSuppressionAsync"),i=w(e,"scores","nonMaxSuppressionAsync"),u=fr(o,i,n,r,s,a);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;const l=await Promise.all([o.data(),i.data()]),c=l[0],h=l[1],{selectedIndices:p,selectedScores:d}=Ld(c,h,n,r,s,a);return o!==t&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:gt(p,"int32"),selectedScores:gt(d)}}const X2=K2;function Y2(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const o=w(t,"boxes","nonMaxSuppression"),i=w(e,"scores","nonMaxSuppression"),u=fr(o,i,n,r,s,null),l=u.maxOutputSize,c=u.iouThreshold,h=u.scoreThreshold,p={boxes:o,scores:i},d={maxOutputSize:l,iouThreshold:c,scoreThreshold:h,padToMaxOutputSize:a},b=k.runKernel(Ac,p,d);return{selectedIndices:b[0],validOutputs:b[1]}}const Z2=E({nonMaxSuppressionPadded_:Y2});async function J2(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const o=w(t,"boxes","nonMaxSuppressionAsync"),i=w(e,"scores","nonMaxSuppressionAsync"),u=fr(o,i,n,r,s,null),l=u.maxOutputSize,c=u.iouThreshold,h=u.scoreThreshold,[p,d]=await Promise.all([o.data(),i.data()]),{selectedIndices:b,validOutputs:v}=Bd(p,d,l,c,h,a);return o!==t&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:gt(b,"int32"),validOutputs:se(v,"int32")}}const Q2=J2;function eS(t,e,n=!1,r=!1){const s=w(t,"images","resizeBilinear");S(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),S(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),S(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=s,o=!1;s.rank===3&&(o=!0,a=B(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const i={images:a},u={alignCorners:n,halfPixelCenters:r,size:e},l=k.runKernel(Wc,i,u);return o?B(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const tS=E({resizeBilinear_:eS});function nS(t,e,n=!1,r=!1){const s=w(t,"images","resizeNearestNeighbor");S(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),S(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),S(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),S(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=s,o=!1;s.rank===3&&(o=!0,a=B(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const i={images:a},u={alignCorners:n,halfPixelCenters:r,size:e},l=k.runKernel(Uc,i,u);return o?B(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const rS=E({resizeNearestNeighbor_:nS});function sS(t,e="binary",n=!1,r=.5){const s=w(t,"image","threshold"),a=.2989,o=.587,i=.114,u=s.shape[0]*s.shape[1];let l=U(gt([r]),255),c,h,p,d;if(S(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),S(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),S(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),S(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[c,h,p]=lr(s,[1,1,1],-1);const N=U(c,a),_=U(h,o),F=U(p,i);d=X(X(N,_),F)}else d=t;if(e==="otsu"){const N=Vo(we(pi(d),"int32"),yt([]),256);l=aS(N,u)}const b=n?Vs(d,l):hr(d,l);return we(U(b,255),"int32")}function aS(t,e){let n=gt([-1]),r=gt([0]),s=gt([0]),a,o,i,u,l,c;for(let h=0;h<t.size-1;h++){a=Te(t,0,h+1),o=Te(t,h+1),l=ke(_e(a),e),c=ke(_e(o),e);const p=_e(U(a,fn(0,a.size)));i=ke(p,_e(a));const d=Zr(o.shape,a.size),b=X(fn(0,o.size),d),v=U(o,b);u=ke(_e(v),_e(o));const N=ne(i,u),_=ne(i,u),F=U(l,c);s=U(U(F,N),_);const x=hr(s,r);r=Fn(x,s,r),n=Fn(x,gt([h]),n)}return n}const oS=E({threshold_:sS});function iS(t,e,n="nearest",r="constant",s=0,a){const o=w(t,"image","transform","float32"),i=w(e,"transforms","transform","float32");S(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),S(i.rank===2&&(i.shape[0]===o.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),S(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const u={image:o,transforms:i},l={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return k.runKernel(Eh,u,l)}const uS=E({transform_:iS});function lS(t,e,n){S(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),S(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const r=w(t,"a","bandPart");S(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[a,o]=r.shape.slice(-2);if(!(e<=a))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${a}).`);if(!(n<=o))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`);e<0&&(e=a),n<0&&(n=o);const i=B(fn(0,a,1,"int32"),[-1,1]),u=fn(0,o,1,"int32"),l=ne(i,u),c=Pr(Vs(l,se(+e,"int32")),Go(l,se(-n,"int32"))),h=Cn([a,o],r.dtype);return B(qt(gn(B(r,[-1,a,o])).map(p=>Fn(c,p,h))),s)}const cS=E({bandPart_:lS});function hS(t){let e;if(Array.isArray(t)){e=!1,S(t!=null&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=t[0].shape[0];for(let a=1;a<t.length;++a)S(t[a].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[a].shape[0]} vs. ${s})`)}else e=!0,t=lr(t,t.shape[0],0).map(s=>mt(s,[0]));S(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],r=t;for(let s=0;s<t.length;++s)n.push(k.tidy(()=>{let a=r[s];if(s>0)for(let o=0;o<s;++o){const i=U(_e(U(n[o],a)),n[o]);a=ne(a,i)}return ke(a,Yr(a,"euclidean"))}));return e?qt(n,0):n}const fS=E({gramSchmidt_:hS});function pS(t,e=!1){if(S(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),t.rank===2)return au(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((u,l)=>u*l),r=gn(B(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),s=[],a=[];r.forEach(u=>{const[l,c]=au(u,e);s.push(l),a.push(c)});const o=B(qt(s,0),t.shape),i=B(qt(a,0),t.shape);return[o,i]}}function au(t,e=!1){return k.tidy(()=>{S(t.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],r=t.shape[1];let s=Wo(n),a=Kt(t);const o=_n([[1]],[1,1]);let i=Kt(o);const u=n>=r?r:n;for(let l=0;l<u;++l){const c=a,h=i,p=s;[i,a,s]=k.tidy(()=>{const d=Te(a,[l,l],[n-l,1]),b=Yr(d),v=Te(a,[l,l],[1,1]),N=Fn(hr(v,0),_n([[-1]]),_n([[1]])),_=ne(v,U(N,b)),F=ke(d,_);F.shape[0]===1?i=Kt(o):i=We([o,Te(F,[1,0],[F.shape[0]-1,F.shape[1]])],0);const x=Lt(ke(ye(N,_),b)),$=Te(a,[l,0],[n-l,r]),A=U(x,i),I=Fr(i);if(l===0)a=ne($,ye(A,ye(I,$)));else{const C=ne($,ye(A,ye(I,$)));a=We([Te(a,[0,0],[l,r]),C],0)}const P=Fr(A),M=Te(s,[0,l],[n,s.shape[1]-l]);if(l===0)s=ne(M,ye(ye(M,i),P));else{const C=ne(M,ye(ye(M,i),P));s=We([Te(s,[0,0],[n,l]),C],1)}return[i,a,s]}),et([c,h,p])}return!e&&n>r&&(s=Te(s,[0,0],[n,r]),a=Te(a,[0,0],[r,r])),[s,a]})}const dS=E({qr_:pS});var Ye;(function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Ye||(Ye={}));function mS(t,e,n=Ye.SUM_BY_NONZERO_WEIGHTS){const r=w(t,"losses","computeWeightedLoss");let s=null;e!=null&&(s=w(e,"weights","computeWeightedLoss"));const a=s==null?r:U(r,s);if(n===Ye.NONE)return a;if(n===Ye.SUM)return _e(a);if(n===Ye.MEAN){if(s==null)return Rr(a);{const o=r.size/s.size,i=ke(_e(a),_e(s));return o>1?ke(i,se(o)):i}}if(n===Ye.SUM_BY_NONZERO_WEIGHTS){if(s==null)return ke(_e(a),se(r.size));{const o=U(s,un(r.shape)),i=we(_e(si(o,se(0))),"float32");return ke(_e(a),i)}}throw Error(`Unknown reduction: ${n}`)}const Zt=E({computeWeightedLoss_:mS});function gS(t,e,n,r=Ye.SUM_BY_NONZERO_WEIGHTS){const s=w(t,"labels","absoluteDifference"),a=w(e,"predictions","absoluteDifference");let o=null;n!=null&&(o=w(n,"weights","absoluteDifference")),Je(s.shape,a.shape,"Error in absoluteDifference: ");const i=rt(ne(s,a));return Zt(i,o,r)}const yS=E({absoluteDifference_:gS});function bS(t,e,n,r,s=Ye.SUM_BY_NONZERO_WEIGHTS){const a=w(t,"labels","cosineDistance"),o=w(e,"predictions","cosineDistance");let i=null;r!=null&&(i=w(r,"weights","cosineDistance")),Je(a.shape,o.shape,"Error in cosineDistance: ");const u=se(1),l=ne(u,_e(U(a,o),n,!0));return Zt(l,i,s)}const wS=E({cosineDistance_:bS});function vS(t,e,n,r=Ye.SUM_BY_NONZERO_WEIGHTS){let s=w(t,"labels","hingeLoss");const a=w(e,"predictions","hingeLoss");let o=null;n!=null&&(o=w(n,"weights","hingeLoss")),Je(s.shape,a.shape,"Error in hingeLoss: ");const i=se(1);s=ne(U(se(2),s),i);const u=Jr(ne(i,U(s,a)));return Zt(u,o,r)}const SS=E({hingeLoss_:vS});function NS(t,e,n,r=1,s=Ye.SUM_BY_NONZERO_WEIGHTS){const a=w(t,"labels","huberLoss"),o=w(e,"predictions","huberLoss");let i=null;n!=null&&(i=w(n,"weights","huberLoss")),Je(a.shape,o.shape,"Error in huberLoss: ");const u=se(r),l=rt(ne(o,a)),c=ni(l,u),h=ne(l,c),p=X(U(se(.5),bt(c)),U(u,h));return Zt(p,i,s)}const TS=E({huberLoss_:NS});function ES(t,e,n,r=1e-7,s=Ye.SUM_BY_NONZERO_WEIGHTS){const a=w(t,"labels","logLoss"),o=w(e,"predictions","logLoss");let i=null;n!=null&&(i=w(n,"weights","logLoss")),Je(a.shape,o.shape,"Error in logLoss: ");const u=se(1),l=se(r),c=Lt(U(a,ur(X(o,l)))),h=U(ne(u,a),ur(X(ne(u,o),l))),p=ne(c,h);return Zt(p,i,s)}const kS=E({logLoss_:ES});function xS(t,e,n,r=Ye.SUM_BY_NONZERO_WEIGHTS){const s=w(t,"labels","meanSquaredError"),a=w(e,"predictions","meanSquaredError");let o=null;n!=null&&(o=w(n,"weights","meanSquaredError")),Je(s.shape,a.shape,"Error in meanSquaredError: ");const i=mi(s,a);return Zt(i,o,r)}const _S=E({meanSquaredError_:xS});function $S(t,e){const n=w(t,"labels","sigmoidCrossEntropyWithLogits"),r=w(e,"logits","sigmoidCrossEntropyWithLogits");Je(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Jr(r),a=U(r,n),o=Xo(hn(Lt(rt(r))));return X(ne(s,a),o)}function AS(t,e,n,r=0,s=Ye.SUM_BY_NONZERO_WEIGHTS){let a=w(t,"multiClassLabels","sigmoidCrossEntropy");const o=w(e,"logits","sigmoidCrossEntropy");let i=null;if(n!=null&&(i=w(n,"weights","sigmoidCrossEntropy")),Je(a.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const l=se(r),c=se(1),h=se(.5);a=X(U(a,ne(c,l)),U(h,l))}const u=$S(a,o);return Zt(u,i,s)}const IS=E({sigmoidCrossEntropy_:AS});function OS(t,e,n=-1){if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return Wt((s,a,o)=>{const u=Zo(a,[n],!0),l=ne(we(a,"float32"),u);o([s,l]);const c=Lt(U(l,s));return{value:_e(c,[n]),gradFunc:(d,b)=>{const[v,N]=b,_=Xr(d.shape,[n]);return[U(B(d,_),ne(we(v,"float32"),hn(N))),U(B(d,_),ne(hn(N),we(v,"float32")))]}}})(t,e)}function DS(t,e,n,r=0,s=Ye.SUM_BY_NONZERO_WEIGHTS){let a=w(t,"onehotLabels","softmaxCrossEntropy");const o=w(e,"logits","softmaxCrossEntropy");let i=null;if(n!=null&&(i=w(n,"weights","softmaxCrossEntropy")),Je(a.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const l=se(r),c=se(1),h=se(a.shape[1]);a=X(U(a,ne(c,l)),ke(l,h))}const u=OS(a,o);return Zt(u,i,s)}const FS=E({softmaxCrossEntropy_:DS});function CS(t,e,n,r){const s=w(t,"indices","sparseFillEmptyRows","int32"),a=w(e,"values","sparseFillEmptyRows"),o=w(n,"denseShape","sparseFillEmptyRows","int32"),i=w(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const u={indices:s,values:a,denseShape:o,defaultValue:i},l=k.runKernel(ch,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}const PS=E({sparseFillEmptyRows_:CS});function RS(t,e,n){const r=w(t,"inputIndices","sparseReshape","int32"),s=w(e,"inputShape","sparseReshape","int32"),a=w(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const o={inputIndices:r,inputShape:s,newShape:a},i=k.runKernel(hh,o);return{outputIndices:i[0],outputShape:i[1]}}const BS=E({sparseReshape_:RS});function LS(t,e,n){const r=w(t,"data","sparseSegmentMean"),s=w(e,"indices","sparseSegmentMean","int32"),a=w(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);const o={data:r,indices:s,segmentIds:a};return k.runKernel(fh,o)}const MS=E({sparseSegmentMean_:LS});function zS(t,e,n){const r=w(t,"data","sparseSegmentSum"),s=w(e,"indices","sparseSegmentSum","int32"),a=w(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);const o={data:r,indices:s,segmentIds:a};return k.runKernel(ph,o)}const VS=E({sparseSegmentSum_:zS});function jS(t,e,n,r,s,a,o,i){const u=w(t,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const l=w(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:o,preserveShortSequences:i},h={data:u,dataSplits:l},p=k.runKernel(yh,h,c);return{nGrams:p[0],nGramsSplits:p[1]}}const US=E({stringNGrams_:jS});function WS(t,e,n=!0){const r=w(t,"input","stringSplit","string"),s=w(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a={skipEmpty:n},o={input:r,delimiter:s},i=k.runKernel(bh,o,a);return{indices:i[0],values:i[1],shape:i[2]}}const qS=E({stringSplit_:WS});function HS(t,e){const n=w(t,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return k.runKernel(wh,s,r)}const GS=E({stringToHashBucketFast_:HS});const Md={fft:Ws,ifft:Br,rfft:qs,irfft:di},zd={hammingWindow:T2,hannWindow:Cd,frame:Pd,stft:_2},Pn={flipLeftRight:O2,grayscaleToRGB:F2,resizeNearestNeighbor:rS,resizeBilinear:tS,rotateWithOffset:P2,cropAndResize:A2,nonMaxSuppression:B2,nonMaxSuppressionAsync:q2,nonMaxSuppressionWithScore:G2,nonMaxSuppressionWithScoreAsync:X2,nonMaxSuppressionPadded:Z2,nonMaxSuppressionPaddedAsync:Q2,threshold:oS,transform:uS},Vd={bandPart:cS,gramSchmidt:fS,qr:dS},jd={absoluteDifference:yS,computeWeightedLoss:Zt,cosineDistance:wS,hingeLoss:SS,huberLoss:TS,logLoss:kS,meanSquaredError:_S,sigmoidCrossEntropy:IS,softmaxCrossEntropy:FS},Ud={sparseFillEmptyRows:PS,sparseReshape:BS,sparseSegmentMean:MS,sparseSegmentSum:VS},Wd={stringNGrams:US,stringSplit:qS,stringToHashBucketFast:GS};class yn extends vf{minimize(e,n=!1,r){const{value:s,grads:a}=this.computeGradients(e,r);if(r!=null){const o=r.map(i=>({name:i.name,tensor:a[i.name]}));this.applyGradients(o)}else this.applyGradients(a);return et(a),n?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,n){return Np(e,n)}dispose(){this.iterations_!=null&&et(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:se(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(yn,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});class Zs extends yn{constructor(e,n,r=null){super(),this.learningRate=e,this.rho=n,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=k.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const a=k.registeredVariables[r],o=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:Y(()=>ot(a).variable(o))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:Y(()=>ot(a).variable(o))});const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const u=this.accumulatedGrads[s].variable,l=this.accumulatedUpdates[s].variable;Y(()=>{const c=X(U(u,this.rho),U(bt(i),1-this.rho)),h=U(ke(Ut(X(l,this.epsilon)),Ut(X(u,this.epsilon))),i),p=X(U(l,this.rho),U(bt(h),1-this.rho));u.assign(c),l.assign(p);const d=X(U(h,-this.learningRate),a);a.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(et(this.accumulatedGrads.map(e=>e.variable)),et(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.rho,n.epsilon)}}Zs.className="Adadelta";mn(Zs);class Js extends yn{constructor(e,n=.1){super(),this.learningRate=e,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const a=k.registeredVariables[r];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:Y(()=>Zr(a.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[s].tensor:e[r];if(o==null)return;const i=this.accumulatedGrads[s].variable;Y(()=>{const u=X(i,bt(o));i.assign(u);const l=X(U(ke(o,Ut(X(u,k.backend.epsilon()))),-this.learningRate),a);a.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&et(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,n){return new e(n.learningRate,n.initialAccumulatorValue)}}Js.className="Adagrad";mn(Js);class Qs extends yn{constructor(e,n,r,s=null){super(),this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Y(()=>{this.accBeta1=se(n).variable(),this.accBeta2=se(r).variable()}),s==null&&(this.epsilon=k.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Y(()=>{const r=ne(1,this.accBeta1),s=ne(1,this.accBeta2);n.forEach((a,o)=>{const i=k.registeredVariables[a],u=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${a}/m`,variable:Y(()=>ot(i).variable(u))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${a}/v`,variable:Y(()=>ot(i).variable(u))});const l=Array.isArray(e)?e[o].tensor:e[a];if(l==null)return;const c=this.accumulatedFirstMoment[o].variable,h=this.accumulatedSecondMoment[o].variable,p=X(U(c,this.beta1),U(l,1-this.beta1)),d=X(U(h,this.beta2),U(bt(l),1-this.beta2)),b=ke(p,r),v=ke(d,s);c.assign(p),h.assign(d);const N=X(U(ke(b,X(Ut(v),this.epsilon)),-this.learningRate),i);i.assign(N)}),this.accBeta1.assign(U(this.accBeta1,this.beta1)),this.accBeta2.assign(U(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&et(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&et(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e),Y(()=>{this.accBeta1.assign(ir(this.beta1,this.iterations_+1)),this.accBeta2.assign(ir(this.beta2,this.iterations_+1))});const n=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon)}}Qs.className="Adam";mn(Qs);class ea extends yn{constructor(e,n,r,s=null,a=0){super(),this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=s,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Y(()=>{this.iteration=se(0).variable(),this.accBeta1=se(n).variable()}),s==null&&(this.epsilon=k.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Y(()=>{const r=ne(1,this.accBeta1),s=ke(-this.learningRate,X(U(this.iteration,this.decay),1));n.forEach((a,o)=>{const i=k.registeredVariables[a],u=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${a}/m`,variable:ot(i).variable(u)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${a}/v`,variable:ot(i).variable(u)});const l=Array.isArray(e)?e[o].tensor:e[a];if(l==null)return;const c=this.accumulatedFirstMoment[o].variable,h=this.accumulatedWeightedInfNorm[o].variable,p=X(U(c,this.beta1),U(l,1-this.beta1)),d=U(h,this.beta2),b=rt(l),v=ti(d,b);c.assign(p),h.assign(v);const N=X(U(ke(s,r),ke(p,X(v,this.epsilon))),i);i.assign(N)}),this.iteration.assign(X(this.iteration,1)),this.accBeta1.assign(U(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&et(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&et(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}ea.className="Adamax";mn(ea);class Qr extends yn{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const o=k.registeredVariables[r];Y(()=>{const i=X(U(this.c,a),o);o.assign(i)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Rt(se(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,n){return new e(n.learningRate)}}Qr.className="SGD";mn(Qr);class ta extends Qr{constructor(e,n,r=!1){super(e),this.learningRate=e,this.momentum=n,this.useNesterov=r,this.accumulations=[],this.m=se(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const a=k.registeredVariables[r];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:Y(()=>ot(a).variable(!1))});const o=this.accumulations[s].variable,i=Array.isArray(e)?e[s].tensor:e[r];i!=null&&Y(()=>{let u;const l=X(U(this.m,o),i);this.useNesterov?u=X(U(this.c,X(i,U(l,this.m))),a):u=X(U(this.c,l),a),o.assign(l),a.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&et(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,n){return new e(n.learningRate,n.momentum,n.useNesterov)}}ta.className="Momentum";mn(ta);class na extends yn{constructor(e,n=.9,r=0,s=null,a=!1){if(super(),this.learningRate=e,this.decay=n,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,s==null&&(this.epsilon=k.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const a=k.registeredVariables[r],o=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:Y(()=>ot(a).variable(o))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:Y(()=>ot(a).variable(o))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:Y(()=>ot(a).variable(o))});const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const u=this.accumulatedMeanSquares[s].variable,l=this.accumulatedMoments[s].variable;Y(()=>{const c=X(U(u,this.decay),U(bt(i),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[s].variable,p=X(U(h,this.decay),U(i,1-this.decay)),d=ke(U(i,this.learningRate),Ut(ne(c,X(bt(p),this.epsilon)))),b=X(U(l,this.momentum),d);u.assign(c),h.assign(p),l.assign(b);const v=ne(a,b);a.assign(v)}else{const h=X(U(u,this.decay),U(bt(i),1-this.decay)),p=X(U(l,this.momentum),ke(U(i,this.learningRate),Ut(X(h,this.epsilon))));u.assign(h),l.assign(p);const d=ne(a,p);a.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&et(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&et(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&et(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(n*2,n*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,n){return new e(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}na.className="RMSProp";mn(na);class nn{static sgd(e){return new Qr(e)}static momentum(e,n,r=!1){return new ta(e,n,r)}static rmsprop(e,n=.9,r=0,s=null,a=!1){return new na(e,n,r,s,a)}static adam(e=.001,n=.9,r=.999,s=null){return new Qs(e,n,r,s)}static adadelta(e=.001,n=.95,r=null){return new Zs(e,n,r)}static adamax(e=.002,n=.9,r=.999,s=null,a=0){return new ea(e,n,r,s,a)}static adagrad(e,n=.1){return new Js(e,n)}}const KS={sgd:nn.sgd,momentum:nn.momentum,adadelta:nn.adadelta,adagrad:nn.adagrad,rmsprop:nn.rmsprop,adamax:nn.adamax,adam:nn.adam};const XS=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t())();function YS(){return new Promise(t=>XS(()=>t()))}function ZS(t,e){const n=t[0].length;t.forEach((s,a)=>{S(s.length===n,()=>`Error in concat${n}D: rank of tensors[${a}] must be the same as the rank of the rest (${n})`)}),S(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=t[0];t.forEach((s,a)=>{for(let o=0;o<n;o++)S(o===e||s[o]===r[o],()=>`Error in concat${n}D: Shape of tensors[${a}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`)})}function JS(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}const vi=30;function QS(t){return t<=vi?t:Ss(t,Math.floor(Math.sqrt(t)))}function eN(t,e,n){const r=n*(typeof t=="number"?t:t[0]),s=e*(typeof t=="number"?t:t[1]);return[r,s]}function tN(t,e,n,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(t[0]/n),s=s.concat(t.slice(1));else{s=s.concat(t[0]);const a=e.length;for(let o=0;o<a;++o)s=s.concat([t[o+1]/e[o],e[o]]);s=s.concat(t.slice(a+1))}return s}function nN(t,e,n=!0){const r=[];if(n){r.push(e);for(let s=e+1;s<t;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],a=[];for(let o=1;o<t;++o)o>=e*2+1||o%2===1?a.push(o):s.push(o);r.push(...s),r.push(0),r.push(...a)}return r}function rN(t,e,n,r=!0){const s=[];r?s.push(t[0]/n):s.push(t[0]*n);for(let a=1;a<t.length;++a)a<=e.length?r?s.push(e[a-1]*t[a]):s.push(t[a]/e[a-1]):s.push(t[a]);return s}function sN(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function aN(t,e,n){const r=t.slice(0,1);for(let s=0;s<n;++s)r.push(t[s+1]-e[s][0]-e[s][1]);return r}const oN=1.7580993408473768,iN=1.0507009873554805;const uN=.3275911,lN=.254829592,cN=-.284496736,hN=1.421413741,fN=-1.453152027,pN=1.061405429;function dN(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(t.length*2);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function mN(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function gN(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function yN(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function bN(t,e){const n=t[e*2],r=t[e*2+1];return{real:n,imag:r}}function wN(t,e,n,r){t[r*2]=e,t[r*2+1]=n}function vN(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let s=0;s<Math.ceil(t/2);s++){const a=(e?2:-2)*Math.PI*(s/t);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function SN(t,e,n){const r=(n?2:-2)*Math.PI*(t/e),s=Math.cos(r),a=Math.sin(r);return{real:s,imag:a}}const va="->",NN=/->/g,ou=",",iu="...";function TN(t,e){t=t.replace(/\s/g,"");const n=(t.length-t.replace(NN,"").length)/va.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${va}").`);const[r,s]=t.split(va);S(r.indexOf(iu)===-1,()=>`The ellipsis notation ("${iu}") is not supported yet.`);const a=r.split(ou),o=a.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let p=0;p<s.length;++p){const d=s[p];if(!a.some(b=>b.indexOf(d)!==-1))throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);i.indexOf(d)===-1&&i.push(d)}for(let p=0;p<r.length;++p){const d=r[p];i.indexOf(d)===-1&&d!==ou&&i.push(d)}const u=new Array(a.length);for(let p=0;p<o;++p){if(new Set(a[p].split("")).size!==a[p].length)throw new Error(`Found duplicate axes in input component ${a[p]}. Support for duplicate axes in input is not implemented yet.`);u[p]=[];for(let d=0;d<a[p].length;++d)u[p].push(i.indexOf(a[p][d]))}const l=i.length,c=s.length,h=[];for(let p=c;p<l;++p)h.push(p);return{allDims:i,summedDims:h,idDims:u}}function EN(t,e){let n=new Array(t);n.fill(-1);for(let s=0;s<e.length;++s)n[e[s]]=s;const r=[];for(let s=0;s<t;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function kN(t,e,n){const r=new Array(t);for(let s=0;s<n.length;++s){const a=n[s].shape;for(let o=0;o<e[s].length;++o)r[e[s][o]]===void 0?r[e[s][o]]=a[o]:S(r[e[s][o]]===a[o],()=>`Expected dimension ${r[e[s][o]]} at axis ${o} of input shaped ${JSON.stringify(a)}, but got dimension ${a[o]}`)}}function xN(t,e){const n=t,r=[];let s=0;t.length===0&&n.push(-1),s=t.length+1;for(let o=0;o<s;++o)r.push([]);const a=[];for(let o=0;o<n.length;++o){const i=n[o],u=$N(e,i);for(const l of u)a.indexOf(l)===-1&&(r[o].push(l),a.push(l))}return{path:n,steps:r}}function _N(t){return t.every((e,n)=>e===n)}function $N(t,e){const n=[];for(let r=0;r<t.length;++r)(t[r].length===0||t[r].indexOf(e)!==-1||e===-1)&&n.push(r);return n}function AN(t,e,n=0){let r=[];if(typeof e=="number")S(t.shape[n]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(t.shape[n]/e);else{const s=e.reduce((o,i)=>(i===-1&&(o+=1),o),0);S(s<=1,()=>"There should be only one negative value in split array.");const a=e.indexOf(-1);if(a!==-1){const o=e.reduce((i,u)=>u>0?i+u:i);e[a]=t.shape[n]-o}S(t.shape[n]===e.reduce((o,i)=>o+i),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}function IN(t){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`}function ON(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function DN(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}function FN(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function CN(t,e){return`size ${t} must be non-negative, not ${e}`}function PN(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function RN(t,e){const n=$e(t),r=$e(e);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${t} outputShape= ${e}`}function BN(t,e){const n=$e(t),r=$e(e);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${t} outputShape=${e}`}function LN(){return"segment ids must be >= 0"}function MN(){return"segment ids are not increasing"}function zN(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function VN(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}function jN(t,e){let n=!1,r;for(t<=vi?(r=t,n=!0):r=Ss(t,Math.floor(Math.sqrt(t)));!n;)r>e||r===t?n=!0:r=Ss(t,r+1);return r}function UN(t,e,n){const r=[],s=t.length;for(let a=0;a<s;a++)a!==e?r.push(t[a]):r.push(n);return r}function WN(t,e,n,r){const s=e.shape.length,a=t.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let h=0;h<r;++h)if(t.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${t.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const o=t.shape[n],i=[];let u=1,l=1,c=1;for(let h=0;h<r;++h)i.push(t.shape[h]),u*=t.shape[h];for(let h=r;h<n;h++)i.push(t.shape[h]),l*=t.shape[h];for(let h=r;h<s;h++)i.push(e.shape[h]);for(let h=n+1;h<a;h++)i.push(t.shape[h]),c*=t.shape[h];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:o,outputShape:i}}var qN=Object.freeze(Object.defineProperty({__proto__:null,segOpComputeOptimalWindowSize:jN,computeOutShape:UN,collectGatherOpShapeInfo:WN},Symbol.toStringTag,{value:"Module"}));function HN(t){try{return t.map(e=>ks(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function GN(t){return t.map(e=>Vr(e))}var KN=Object.freeze(Object.defineProperty({__proto__:null,slice_util:wf,segment_util:qN,fromUint8ToStringArray:HN,fromStringArrayToUint8:GN,upcastType:Ls,axesAreInnerMostDims:Uo,combineLocations:fp,computeOutAndReduceShapes:j1,expandShapeToKeepDim:Xr,assertAxesAreInnerMostDims:U1,getAxesPermutation:W1,getUndoAxesPermutation:q1,getInnerMostAxes:H1,getBroadcastDims:of,getReductionAxes:Io,assertAndGetBroadcastShape:Be,assertParamsConsistent:ZS,computeOutShape:JS,computeDilation2DInfo:jb,computePool2DInfo:Cf,computePool3DInfo:Ub,computeConv2DInfo:qr,computeConv3DInfo:Pf,computeDefaultPad:Lo,tupleValuesAreOne:Cr,eitherStridesOrDilationsAreOne:Yt,convertConv2DDataFormat:Rf,checkPadOnDimRoundingMode:vt,getFusedDyActivation:Gs,getFusedBiasGradient:Ks,applyActivation:Xs,shouldFuse:Ys,PARALLELIZE_THRESHOLD:vi,computeOptimalWindowSize:QS,getImageCenter:eN,getReshaped:tN,getPermuted:nN,getReshapedPermuted:rN,getSliceBeginCoords:sN,getSliceSize:aN,prepareAndValidate:lf,validateUpdateShape:Do,validateInput:Fo,calculateShapes:cf,SELU_SCALEALPHA:oN,SELU_SCALE:iN,ERF_P:uN,ERF_A1:lN,ERF_A2:cN,ERF_A3:hN,ERF_A4:fN,ERF_A5:pN,warn:rn,log:Gg,mergeRealAndImagArrays:dN,splitRealAndImagArrays:mN,complexWithEvenIndex:gN,complexWithOddIndex:yN,getComplexWithIndex:bN,assignToTypedArray:wN,exponents:vN,exponent:SN,decodeEinsumEquation:TN,getEinsumPermutation:EN,checkEinsumDimSizes:kN,getEinsumComputePath:xN,isIdentityPermutation:_N,prepareSplitSize:AN,getSparseFillEmptyRowsIndicesDenseShapeMismatch:IN,getSparseFillEmptyRowsNegativeIndexErrorMessage:ON,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:DN,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:FN,getSparseReshapeNegativeOutputDimErrorMessage:CN,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:PN,getSparseReshapeInputOutputMultipleErrorMessage:RN,getSparseReshapeInputOutputMismatchErrorMessage:BN,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:LN,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:MN,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:zN,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:VN},Symbol.toStringTag,{value:"Module"}));var XN=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:Rd,nonMaxSuppressionV4Impl:Bd,nonMaxSuppressionV5Impl:Ld,whereImpl:kd},Symbol.toStringTag,{value:"Module"}));var qd=Object.freeze(Object.defineProperty({__proto__:null,AdadeltaOptimizer:Zs,AdagradOptimizer:Js,AdamOptimizer:Qs,AdamaxOptimizer:ea,MomentumOptimizer:ta,Optimizer:yn,OptimizerConstructors:nn,RMSPropOptimizer:na,SGDOptimizer:Qr,Tensor:be,TensorBuffer:xs,Variable:Ir,get Rank(){return Ra},sumOutType:vy,upcastType:Ls,get Reduction(){return Ye},customGrad:Wt,grad:ww,grads:vw,valueAndGrad:Sw,valueAndGrads:Nw,variableGrads:Np,Environment:Hu,env:re,get ENV(){return ho},nextFrame:YS,KernelBackend:Pu,DataStorage:ug,abs:rt,acos:Tf,acosh:Ef,add:X,addN:kf,all:xf,any:_f,argMax:Bo,argMin:$f,asin:Af,asinh:If,atan:Of,atan2:Df,atanh:Ff,avgPool:Mo,avgPool3d:Bf,basicLSTMCell:Lf,batchToSpaceND:zo,batchNorm:Hr,batchNorm2d:Mf,batchNorm3d:zf,batchNorm4d:Vf,bincount:Vo,broadcastArgs:jf,broadcastTo:xr,buffer:jt,cast:we,ceil:Uf,clipByValue:Wf,clone:Kt,complex:Xt,concat:We,concat1d:qf,concat2d:Hf,concat3d:Gf,concat4d:Kf,conv1d:Xf,conv2d:Gr,conv2dTranspose:Zf,conv3d:Jf,conv3dTranspose:Qf,cos:ep,cosh:tp,cumprod:np,cumsum:rp,denseBincount:sp,depthToSpace:ap,depthwiseConv2d:zs,diag:op,dilation2d:ip,div:ke,divNoNan:up,dot:lp,einsum:cp,elu:jo,equal:Kr,erf:hp,euclideanNorm:dp,exp:hn,expandDims:st,expm1:mp,eye:Wo,fill:Zr,floor:qo,floorDiv:Ro,gather:Ho,greater:hr,greaterEqual:Go,imag:Ur,isFinite:gp,isInf:yp,isNaN:bp,leakyRelu:Ko,less:wp,lessEqual:Vs,linspace:vp,localResponseNormalization:Sp,log:ur,log1p:Xo,logSigmoid:Tp,logSoftmax:Ep,logSumExp:Zo,logicalAnd:Pr,logicalNot:Jo,logicalOr:Qo,logicalXor:kp,lowerBound:xp,matMul:ye,max:xn,maxPool:ei,maxPool3d:_p,maxPoolWithArgmax:$p,maximum:ti,mean:Rr,meshgrid:Ap,min:Is,minimum:ni,mirrorPad:ri,mod:Ip,moments:Op,mul:U,multiRNNCell:Dp,multinomial:Fp,neg:Lt,notEqual:si,oneHot:Dr,ones:un,onesLike:Cp,outerProduct:Pp,pad:Mn,pad1d:Rp,pad2d:Bp,pad3d:ai,pad4d:Lp,pool:Mp,pow:ir,prelu:ii,print:ko,prod:zp,rand:Vp,randomGamma:Xp,randomNormal:ci,randomStandardNormal:Yp,randomUniform:hi,range:fn,real:or,reciprocal:Zp,relu:Jr,relu6:fi,reshape:B,reverse:pn,reverse1d:Jp,reverse2d:Qp,reverse3d:ed,reverse4d:td,round:pi,rsqrt:nd,scalar:se,selu:rd,separableConv2d:sd,setdiff1dAsync:ad,sigmoid:Mt,sign:od,sin:id,sinh:ud,slice:Te,slice1d:ld,slice2d:cd,slice3d:hd,slice4d:fd,softmax:pd,softplus:Yo,spaceToBatchND:oi,fft:Ws,ifft:Br,irfft:di,rfft:qs,split:lr,sqrt:Ut,square:bt,squaredDifference:mi,squeeze:mt,stack:qt,step:gi,stridedSlice:dd,sub:ne,sum:_e,tan:md,tanh:As,tensor:yt,tensor1d:gt,tensor2d:_n,tensor3d:Oo,tensor4d:gd,tensor5d:yd,tensor6d:bd,tile:tr,topk:wd,truncatedNormal:vd,unique:Sd,unsortedSegmentSum:Nd,unstack:gn,upperBound:Td,variable:Ed,where:Fn,whereAsync:yi,zeros:Cn,zerosLike:ot,op:E,OP_SCOPE_SUFFIX:So,booleanMaskAsync:xd,transpose:Fr,norm:Yr,movingAverage:_d,scatterND:$d,searchSorted:Us,sparseToDense:Ad,gatherND:Id,dropout:Od,enclosingPowerOfTwo:bi,cosineWindow:Hs,inTopKAsync:Dd,image:Pn,linalg:Vd,losses:jd,spectral:Md,fused:Fd,signal:zd,sparse:Ud,string:Wd,train:KS,enableProdMode:$0,enableDebugMode:A0,disableDeprecationWarnings:I0,deprecationWarn:O0,disposeVariables:D0,engine:Ao,memory:F0,profile:C0,tidy:Y,dispose:et,keep:Rt,time:P0,setBackend:R0,ready:B0,getBackend:sf,removeBackend:L0,findBackend:M0,findBackendFactory:z0,registerBackend:V0,backend:af,setPlatform:j0,getKernel:Ns,getGradient:Da,getKernelsForBackend:Ts,registerKernel:Oh,registerGradient:Kg,unregisterKernel:Xg,unregisterGradient:Yg,copyRegisteredKernels:Zg,Abs:Ku,Acos:Xu,Acosh:Yu,Add:po,AddN:Zu,All:Ju,Any:Qu,ArgMax:el,ArgMin:tl,Asin:nl,Asinh:rl,Atan:sl,Atanh:al,Atan2:ol,AvgPool:il,AvgPoolGrad:Ag,AvgPool3D:ul,AvgPool3DGrad:Ig,BatchMatMul:ll,BatchToSpaceND:cl,Bincount:hl,BroadcastTo:Og,BroadcastArgs:fl,Cast:mo,Ceil:pl,ClipByValue:dl,Complex:ml,ComplexAbs:gl,Concat:yl,Conv2D:bl,Conv2DBackpropFilter:wl,Conv2DBackpropInput:vl,Conv3D:Sl,Conv3DBackpropFilterV2:Dg,Conv3DBackpropInputV2:Nl,Cos:Tl,Cosh:El,Cumprod:kl,Cumsum:xl,CropAndResize:_l,DenseBincount:$l,DepthToSpace:Al,DepthwiseConv2dNative:Il,DepthwiseConv2dNativeBackpropFilter:Ol,DepthwiseConv2dNativeBackpropInput:Dl,Diag:Fl,Dilation2D:Cl,Dilation2DBackpropInput:Fg,Dilation2DBackpropFilter:Cg,RealDiv:Pl,Einsum:Rl,Elu:Bl,EluGrad:Pg,Erf:Ll,Equal:Ml,Exp:zl,ExpandDims:Vl,Expm1:jl,FFT:Ul,Fill:Wl,FlipLeftRight:ql,Floor:Hl,FloorDiv:Gl,FusedBatchNorm:Kl,GatherV2:Xl,GatherNd:Yl,Greater:Zl,GreaterEqual:Jl,Identity:go,IFFT:Ql,Imag:ec,IsFinite:tc,IsInf:nc,IsNan:rc,LeakyRelu:sc,Less:ac,LessEqual:oc,LinSpace:ic,Log:uc,Log1p:lc,LogicalAnd:cc,LogicalNot:hc,LogicalOr:fc,LogicalXor:Rg,LogSoftmax:Bg,LowerBound:Lg,LRN:pc,LRNGrad:Mg,Max:dc,Maximum:mc,MaxPool:gc,MaxPoolGrad:zg,MaxPool3D:yc,MaxPool3DGrad:Vg,MaxPoolWithArgmax:bc,Mean:wc,Min:vc,Minimum:Sc,MirrorPad:Nc,Mod:Tc,Multinomial:Ec,Multiply:kc,Neg:xc,NotEqual:_c,NonMaxSuppressionV3:$c,NonMaxSuppressionV4:Ac,NonMaxSuppressionV5:Ic,OnesLike:Oc,OneHot:Dc,Pack:Fc,PadV2:Cc,Pool:jg,Pow:Pc,Prelu:Rc,Prod:Bc,Range:Lc,Real:Mc,Reciprocal:zc,Relu:Vc,Reshape:jc,ResizeNearestNeighbor:Uc,ResizeNearestNeighborGrad:Ug,ResizeBilinear:Wc,ResizeBilinearGrad:Wg,Relu6:qc,Reverse:Hc,Round:Gc,Rsqrt:Kc,ScatterNd:Xc,SearchSorted:Yc,Select:Zc,Selu:Jc,Slice:Qc,Sin:eh,Sinh:th,Sign:nh,Sigmoid:rh,Softplus:sh,Sqrt:ah,Sum:oh,SpaceToBatchND:ih,SplitV:uh,Softmax:lh,SparseFillEmptyRows:ch,SparseReshape:hh,SparseSegmentMean:fh,SparseSegmentSum:ph,SparseToDense:dh,SquaredDifference:mh,Square:qg,StridedSlice:gh,StringNGrams:yh,StringSplit:bh,StringToHashBucketFast:wh,Sub:vh,Tan:Sh,Tanh:Nh,Tile:yo,TopK:Th,Transform:Eh,Transpose:gs,Unique:kh,Unpack:xh,UnsortedSegmentSum:_h,UpperBound:Hg,ZerosLike:$h,Step:Ah,FromPixels:$a,RotateWithOffset:Ih,_FusedMatMul:Aa,FusedConv2D:Ia,FusedDepthwiseConv2D:Oa,version_core:Eb,browser:nb,io:$o,math:X0,serialization:mb,test_util:Tb,util:uy,backend_util:KN,broadcast_util:Y0,tensor_util:Ty,slice_util:wf,gather_util:rb,scatter_util:sb,device_util:Ay,kernel_impls:XN},Symbol.toStringTag,{value:"Module"}));const YN=re();YN.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var ct;(function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"})(ct||(ct={}));var uu;(function(t){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(uu||(uu={}));const ZN={};function Hd(t){return ZN[t]}function m(t,e,n,r,s){const a=e.inputParams[t];if(a&&a.inputIndexStart!==void 0){const i=a.inputIndexStart,u=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?i+1:a.inputIndexEnd;if(a.type==="tensor")return Ze(e.inputNames[a.inputIndexStart],n,r,s);if(a.type==="tensors")return e.inputNames.slice(i,u).map(p=>Ze(p,n,r,s));const l=Ze(e.inputNames.slice(i)[0],n,r,s),c=l.dataSync();return a.type==="number"?c[0]:En(l.shape,c)}const o=e.attrParams[t];return o&&o.value}function Ze(t,e,n,r){const[s,a]=nt(t);if(r!=null){const i=r.getHashTableHandleByName(s);if(i!=null)return i}const o=n.currentContextIds.find(i=>!!e[Os(s,i)]);return o!==void 0?e[Os(s,o)][a]:void 0}function JN(t,e,n){return e[Os(t,n.currentContextId)]}function Pt(t,e){const[n,r,s]=nt(t);return[Os(n,e&&e.currentContextId),r,s]}function Os(t,e){return e?`${t}-${e}`:t}function nt(t){const e=t.split(":");if(e.length===1)return[t,0,void 0];const n=e[0],r=e.length===3?e[1]:void 0,s=Number(e[e.length-1]);return[n,s,r]}function ws(t,e,n){let r=m("pad",t,e,n);if(r==="explicit"){r=m("explicitPaddings",t,e,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)s[a][0]=r[a*2],s[a][1]=r[a*2+1];return s}return r}function Ht(t){return t.kept?t:Kt(t)}const QN=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var eT=Object.freeze(Object.defineProperty({__proto__:null,json:QN},Symbol.toStringTag,{value:"Module"}));const tT=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var nT=Object.freeze(Object.defineProperty({__proto__:null,json:tT},Symbol.toStringTag,{value:"Module"}));const rT=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var sT=Object.freeze(Object.defineProperty({__proto__:null,json:rT},Symbol.toStringTag,{value:"Module"}));const aT=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var oT=Object.freeze(Object.defineProperty({__proto__:null,json:aT},Symbol.toStringTag,{value:"Module"}));const iT=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var uT=Object.freeze(Object.defineProperty({__proto__:null,json:iT},Symbol.toStringTag,{value:"Module"}));const lT=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var cT=Object.freeze(Object.defineProperty({__proto__:null,json:lT},Symbol.toStringTag,{value:"Module"}));const hT=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var fT=Object.freeze(Object.defineProperty({__proto__:null,json:hT},Symbol.toStringTag,{value:"Module"}));const pT=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var dT=Object.freeze(Object.defineProperty({__proto__:null,json:pT},Symbol.toStringTag,{value:"Module"}));const mT=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var gT=Object.freeze(Object.defineProperty({__proto__:null,json:mT},Symbol.toStringTag,{value:"Module"}));const yT=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var bT=Object.freeze(Object.defineProperty({__proto__:null,json:yT},Symbol.toStringTag,{value:"Module"}));const wT=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var vT=Object.freeze(Object.defineProperty({__proto__:null,json:wT},Symbol.toStringTag,{value:"Module"}));const ST=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var NT=Object.freeze(Object.defineProperty({__proto__:null,json:ST},Symbol.toStringTag,{value:"Module"}));const TT=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var ET=Object.freeze(Object.defineProperty({__proto__:null,json:TT},Symbol.toStringTag,{value:"Module"}));const kT=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var xT=Object.freeze(Object.defineProperty({__proto__:null,json:kT},Symbol.toStringTag,{value:"Module"}));const _T=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var $T=Object.freeze(Object.defineProperty({__proto__:null,json:_T},Symbol.toStringTag,{value:"Module"}));const AT=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var IT=Object.freeze(Object.defineProperty({__proto__:null,json:AT},Symbol.toStringTag,{value:"Module"}));const OT=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var DT=Object.freeze(Object.defineProperty({__proto__:null,json:OT},Symbol.toStringTag,{value:"Module"}));const FT=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var CT=Object.freeze(Object.defineProperty({__proto__:null,json:FT},Symbol.toStringTag,{value:"Module"}));const PT=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var RT=Object.freeze(Object.defineProperty({__proto__:null,json:PT},Symbol.toStringTag,{value:"Module"}));class lu{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[eT,nT,sT,oT,uT,cT,fT,dT,gT,bT,vT,NT,ET,xT,$T,IT,DT,CT,RT],n=[].concat(...e.map(r=>r.json));this.opMappers=n.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(e,n={}){const r=e.node,s=[],a=[],o=[],i=r.reduce((v,N)=>(v[N.name]=this.mapNode(N),N.op.startsWith("Placeholder")?s.push(v[N.name]):N.op==="Const"?a.push(v[N.name]):(N.input==null||N.input.length===0)&&o.push(v[N.name]),v),{});let u=[];const l=[];let c={},h={};n!=null&&(c=this.mapSignatureEntries(n.inputs),h=this.mapSignatureEntries(n.outputs));const p=Object.keys(i);p.forEach(v=>{const N=i[v];N.inputNames.forEach((_,F)=>{const[x,,$]=Pt(_),A=i[x];if(A.outputs!=null){const I=A.outputs.indexOf($);if(I!==-1){const P=`${x}:${I}`;N.inputNames[F]=P}}N.inputs.push(A),A.children.push(N)})}),Object.keys(h).length===0?p.forEach(v=>{const N=i[v];N.children.length===0&&l.push(N)}):Object.keys(h).forEach(v=>{const[N]=Pt(v),_=i[N];_!=null&&(_.signatureKey=h[v],l.push(_))}),Object.keys(c).length>0?Object.keys(c).forEach(v=>{const[N]=Pt(v),_=i[N];_&&(_.signatureKey=c[v],u.push(_))}):u=s;let d={};e.library!=null&&e.library.function!=null&&(d=e.library.function.reduce((v,N)=>(v[N.signature.name]=this.mapFunction(N),v),{}));const b={nodes:i,inputs:u,outputs:l,weights:a,placeholders:s,signature:n,functions:d};return o.length>0&&(b.initNodes=o),b}mapSignatureEntries(e){return Object.keys(e||{}).reduce((n,r)=>(n[e[r].name]=r,n),{})}mapNode(e){const n=Hd(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:n.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:n.outputs};return n.inputs!=null&&(r.inputParams=n.inputs.reduce((s,a)=>(s[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},s),{})),n.attrs!=null&&(r.attrParams=n.attrs.reduce((s,a)=>{const o=a.type;let i;switch(a.type){case"string":i=Ya(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=Ya(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":i=ro(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=ro(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":i=Ja(e.attr,a.tfName,a.defaultValue||0),i===void 0&&!!a.tfDeprecatedName&&(i=Ja(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":i=no(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=no(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":i=Za(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=Za(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":i=ao(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=ao(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":i=to(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=to(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":i=so(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=so(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":i=Qa(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=Qa(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":i=eo(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=eo(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":i=cu(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=cu(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return s[a.name]={value:i,type:o},s},{})),r}mapFunction(e){const n=e.nodeDef,r=[],s=[];let a={};n!=null&&(a=n.reduce((h,p)=>(h[p.name]=this.mapNode(p),p.op==="Const"&&s.push(h[p.name]),h),{}));const o=[],i=[];e.signature.inputArg.forEach(h=>{const[p]=Pt(h.name),d={name:p,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Si(h.type),type:"dtype"}},children:[]};d.signatureKey=h.name,o.push(d),a[p]=d}),Object.keys(a).forEach(h=>{const p=a[h];p.inputNames.forEach((d,b)=>{const[v,,N]=Pt(d),_=a[v];if(_.outputs!=null){const F=_.outputs.indexOf(N);if(F!==-1){const x=`${v}:${F}`;p.inputNames[b]=x}}p.inputs.push(_),_.children.push(p)})});const l=e.ret;e.signature.outputArg.forEach(h=>{const[p,d]=Pt(l[h.name]),b=a[p];b!=null&&(b.defaultOutput=d,i.push(b))});const c=this.mapArgsToSignature(e);return{nodes:a,inputs:o,outputs:i,weights:s,placeholders:r,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r),n),{}),outputs:e.signature.outputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r,e.ret),n),{})}}mapArgToTensorInfo(e,n){let r=e.name;return n!=null&&(r=n[r]),{name:r,dtype:e.type}}}function BT(t){const e=re().global;if(typeof e.atob<"u")return e.atob(t);if(typeof Buffer<"u")return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function Gd(t,e){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):BT(t);return e?n:n.toLowerCase()}function Ya(t,e,n,r=!1){const s=t[e];return s!=null?Gd(s.s,r):n}function Za(t,e,n){const r=t[e];return r?r.b:n}function Ja(t,e,n){const r=t[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:n;return typeof s=="number"?s:parseInt(s,10)}function Si(t){switch(typeof t=="string"&&(t=ct[t]),t){case ct.DT_FLOAT:case ct.DT_HALF:return"float32";case ct.DT_INT32:case ct.DT_INT64:case ct.DT_INT8:case ct.DT_UINT8:return"int32";case ct.DT_BOOL:return"bool";case ct.DT_DOUBLE:return"float32";case ct.DT_STRING:return"string";default:return null}}function cu(t,e,n){const r=t[e];return r&&r.func?r.func.name:n}function Qa(t,e,n){const r=t[e];return r&&r.type?Si(r.type):n}function eo(t,e,n){const r=t[e];return r&&r.list&&r.list.type?r.list.type.map(s=>Si(s)):n}function Kd(t){if(!t.unknownRank)return t.dim!=null?t.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function to(t,e,n){const r=t[e];return r&&r.shape?Kd(r.shape):n}function no(t,e,n){const r=t[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):n}function ro(t,e,n,r=!1){const s=t[e];return s&&s.list&&s.list.s?s.list.s.map(a=>Gd(a,r)):n}function so(t,e,n){const r=t[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>Kd(s)):n}function ao(t,e,n){const r=t[e];return r&&r.list&&r.list.b?r.list.b:n}class LT{constructor(e,n,r){this.node=e,this.tensorMap=n,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,a)=>(s[a]=this.getAttr(a),s),{}))}getInput(e){return Ze(e,this.tensorMap,this.context)}getAttr(e,n){const r=this.node.rawAttrs[e];if(r.tensor!=null)return Ze(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return Ja(this.node.rawAttrs,e,n);if(r.s!=null)return Ya(this.node.rawAttrs,e,n);if(r.b!=null)return Za(this.node.rawAttrs,e,n);if(r.shape!=null)return to(this.node.rawAttrs,e,n);if(r.type!=null)return Qa(this.node.rawAttrs,e,n);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return no(this.node.rawAttrs,e,n);if(r.list.s!=null)return ro(this.node.rawAttrs,e,n);if(r.list.shape!=null)return so(this.node.rawAttrs,e,n);if(r.list.b!=null)return ao(this.node.rawAttrs,e,n);if(r.list.type!=null)return eo(this.node.rawAttrs,e,n)}return n}}var qe=Object.freeze(Object.defineProperty({__proto__:null,abs:rt,acos:Tf,acosh:Ef,add:X,addN:kf,all:xf,any:_f,argMax:Bo,argMin:$f,asin:Af,asinh:If,atan:Of,atan2:Df,atanh:Ff,avgPool:Mo,avgPool3d:Bf,basicLSTMCell:Lf,batchToSpaceND:zo,batchNorm:Hr,batchNorm2d:Mf,batchNorm3d:zf,batchNorm4d:Vf,bincount:Vo,broadcastArgs:jf,broadcastTo:xr,buffer:jt,cast:we,ceil:Uf,clipByValue:Wf,clone:Kt,complex:Xt,concat:We,concat1d:qf,concat2d:Hf,concat3d:Gf,concat4d:Kf,conv1d:Xf,conv2d:Gr,conv2dTranspose:Zf,conv3d:Jf,conv3dTranspose:Qf,cos:ep,cosh:tp,cumprod:np,cumsum:rp,denseBincount:sp,depthToSpace:ap,depthwiseConv2d:zs,diag:op,dilation2d:ip,div:ke,divNoNan:up,dot:lp,einsum:cp,elu:jo,equal:Kr,erf:hp,euclideanNorm:dp,exp:hn,expandDims:st,expm1:mp,eye:Wo,fill:Zr,floor:qo,floorDiv:Ro,gather:Ho,greater:hr,greaterEqual:Go,imag:Ur,isFinite:gp,isInf:yp,isNaN:bp,leakyRelu:Ko,less:wp,lessEqual:Vs,linspace:vp,localResponseNormalization:Sp,log:ur,log1p:Xo,logSigmoid:Tp,logSoftmax:Ep,logSumExp:Zo,logicalAnd:Pr,logicalNot:Jo,logicalOr:Qo,logicalXor:kp,lowerBound:xp,matMul:ye,max:xn,maxPool:ei,maxPool3d:_p,maxPoolWithArgmax:$p,maximum:ti,mean:Rr,meshgrid:Ap,min:Is,minimum:ni,mirrorPad:ri,mod:Ip,moments:Op,mul:U,multiRNNCell:Dp,multinomial:Fp,neg:Lt,notEqual:si,oneHot:Dr,ones:un,onesLike:Cp,outerProduct:Pp,pad:Mn,pad1d:Rp,pad2d:Bp,pad3d:ai,pad4d:Lp,pool:Mp,pow:ir,prelu:ii,print:ko,prod:zp,rand:Vp,randomGamma:Xp,randomNormal:ci,randomStandardNormal:Yp,randomUniform:hi,range:fn,real:or,reciprocal:Zp,relu:Jr,relu6:fi,reshape:B,reverse:pn,reverse1d:Jp,reverse2d:Qp,reverse3d:ed,reverse4d:td,round:pi,rsqrt:nd,scalar:se,selu:rd,separableConv2d:sd,setdiff1dAsync:ad,sigmoid:Mt,sign:od,sin:id,sinh:ud,slice:Te,slice1d:ld,slice2d:cd,slice3d:hd,slice4d:fd,softmax:pd,softplus:Yo,spaceToBatchND:oi,fft:Ws,ifft:Br,irfft:di,rfft:qs,split:lr,sqrt:Ut,square:bt,squaredDifference:mi,squeeze:mt,stack:qt,step:gi,stridedSlice:dd,sub:ne,sum:_e,tan:md,tanh:As,tensor:yt,tensor1d:gt,tensor2d:_n,tensor3d:Oo,tensor4d:gd,tensor5d:yd,tensor6d:bd,tile:tr,topk:wd,truncatedNormal:vd,unique:Sd,unsortedSegmentSum:Nd,unstack:gn,upperBound:Td,variable:Ed,where:Fn,whereAsync:yi,zeros:Cn,zerosLike:ot,op:E,OP_SCOPE_SUFFIX:So,booleanMaskAsync:xd,transpose:Fr,norm:Yr,movingAverage:_d,scatterND:$d,searchSorted:Us,sparseToDense:Ad,gatherND:Id,dropout:Od,enclosingPowerOfTwo:bi,cosineWindow:Hs,inTopKAsync:Dd,image:Pn,linalg:Vd,losses:jd,spectral:Md,fused:Fd,signal:zd,sparse:Ud,string:Wd},Symbol.toStringTag,{value:"Module"}));const MT=(t,e,n,r=qe)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(m("a",t,e,n),m("b",t,e,n))];case"AddN":return[r.addN(m("tensors",t,e,n))];case"FloorMod":case"Mod":return[r.mod(m("a",t,e,n),m("b",t,e,n))];case"Mul":return[r.mul(m("a",t,e,n),m("b",t,e,n))];case"RealDiv":case"Div":return[r.div(m("a",t,e,n),m("b",t,e,n))];case"DivNoNan":return[r.divNoNan(m("a",t,e,n),m("b",t,e,n))];case"FloorDiv":return[r.floorDiv(m("a",t,e,n),m("b",t,e,n))];case"Sub":return[r.sub(m("a",t,e,n),m("b",t,e,n))];case"Minimum":return[r.minimum(m("a",t,e,n),m("b",t,e,n))];case"Maximum":return[r.maximum(m("a",t,e,n),m("b",t,e,n))];case"Pow":return[r.pow(m("a",t,e,n),m("b",t,e,n))];case"SquaredDifference":return[r.squaredDifference(m("a",t,e,n),m("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const zT=(t,e,n,r=qe)=>{switch(t.op){case"Abs":case"ComplexAbs":return[r.abs(m("x",t,e,n))];case"Acos":return[r.acos(m("x",t,e,n))];case"Acosh":return[r.acosh(m("x",t,e,n))];case"Asin":return[r.asin(m("x",t,e,n))];case"Asinh":return[r.asinh(m("x",t,e,n))];case"Atan":return[r.atan(m("x",t,e,n))];case"Atan2":return[r.atan2(m("x",t,e,n),m("y",t,e,n))];case"Atanh":return[r.atanh(m("x",t,e,n))];case"Ceil":return[r.ceil(m("x",t,e,n))];case"Complex":return[r.complex(m("real",t,e,n),m("imag",t,e,n))];case"Cos":return[r.cos(m("x",t,e,n))];case"Cosh":return[r.cosh(m("x",t,e,n))];case"Elu":return[r.elu(m("x",t,e,n))];case"Erf":return[r.erf(m("x",t,e,n))];case"Exp":return[r.exp(m("x",t,e,n))];case"Expm1":return[r.expm1(m("x",t,e,n))];case"Floor":return[r.floor(m("x",t,e,n))];case"Log":return[r.log(m("x",t,e,n))];case"Log1p":return[r.log1p(m("x",t,e,n))];case"Imag":return[r.imag(m("x",t,e,n))];case"Neg":return[r.neg(m("x",t,e,n))];case"Reciprocal":return[r.reciprocal(m("x",t,e,n))];case"Real":return[r.real(m("x",t,e,n))];case"Relu":return[r.relu(m("x",t,e,n))];case"Round":return[r.round(m("x",t,e,n))];case"Selu":return[r.selu(m("x",t,e,n))];case"Sigmoid":return[r.sigmoid(m("x",t,e,n))];case"Sin":return[r.sin(m("x",t,e,n))];case"Sign":return[r.sign(m("x",t,e,n))];case"Sinh":return[r.sinh(m("x",t,e,n))];case"Softplus":return[r.softplus(m("x",t,e,n))];case"Sqrt":return[r.sqrt(m("x",t,e,n))];case"Square":return[r.square(m("x",t,e,n))];case"Tanh":return[r.tanh(m("x",t,e,n))];case"Tan":return[r.tan(m("x",t,e,n))];case"ClipByValue":return[r.clipByValue(m("x",t,e,n),m("clipValueMin",t,e,n),m("clipValueMax",t,e,n))];case"Relu6":return[r.relu6(m("x",t,e,n))];case"Rsqrt":return[r.rsqrt(Ze(t.inputNames[0],e,n))];case"Prod":return[r.prod(m("x",t,e,n),m("axes",t,e,n))];case"LeakyRelu":return[r.leakyRelu(m("x",t,e,n),m("alpha",t,e,n))];case"Prelu":return[r.prelu(m("x",t,e,n),m("alpha",t,e,n))];case"IsNan":return[r.isNaN(Ze(t.inputNames[0],e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function ht(t,e,n=""){if(!(typeof t=="number"||typeof e=="number")){S(t.length===e.length,()=>n+` Shapes ${t} and ${e} must match`);for(let r=0;r<t.length;r++){const s=t[r],a=e[r];S(s<0||a<0||s===a,()=>n+` Shapes ${t} and ${e} must match`)}}}function hu(t){return!(typeof t=="number"||t.some(e=>e<0))}function wr(t,e,n){let r=oo(t,n);const s=!hu(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(a=>{r=oo(a.shape,r)}),!hu(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function oo(t,e){if(typeof t=="number")return e;if(typeof e=="number")return t;if(t.length!==e.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);const n=[];for(let r=0;r<t.length;++r){const s=t[r],a=e[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);n[r]=s>=0?s:a}return n}class VT{constructor(e,n,r,s,a,o,i){this.name=e,this.dtype=n,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=a,this.dynamicSize=o,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=se(0),Rt(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const n=this.tensors[e];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(e){return e.map(n=>this.read(n))}write(e,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),ht(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=n,Rt(n),r.written=!0,this.tensors[e]=r}writeMany(e,n){if(e.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${n.length}.`);e.forEach((r,s)=>this.write(r,n[s]))}gather(e,n){if(!!n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return yt([],[0].concat(this.elementShape));const r=this.readMany(e);return ht(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),qt(r,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return yt([],[0].concat(this.elementShape));const n=[];for(let s=0;s<this.size();s++)n.push(s);const r=this.readMany(n);return ht(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),We(r,0)}scatter(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,gn(n,0))}split(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let r=0;const s=e.map(u=>(r+=u,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const a=r===0?0:n.size/r,o=[];Y(()=>{n=B(n,[1,r,a]);for(let u=0;u<e.length;++u){const l=u===0?0:s[u-1],c=[0,l,0],h=[1,e[u],a];o[u]=B(Te(n,c,h),this.elementShape)}return o});const i=[];for(let u=0;u<e.length;u++)i[u]=u;this.writeMany(i,o)}}class Rn{constructor(e,n,r,s=-1){this.tensors=e,this.elementShape=n,this.elementDtype=r,e?.forEach(a=>{if(r!==a.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${a.dtype}`);ht(n,a.shape,"TensorList shape mismatch: "),Rt(a)}),this.idTensor=se(0),this.maxNumElements=s,Rt(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Rn([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);ht(e,this.elementShape,"TensorList shape mismatch: ");const s=wr(this.elementShape,this.tensors,e);return Y(()=>{const a=this.tensors.map(o=>B(o,s));return qt(a,0)})}popBack(e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=wr(this.elementShape,this.tensors,e),s=this.tensors.pop();return ht(s.shape,e,"TensorList shape mismatch: "),B(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(ht(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Rt(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const n=new Rn([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)n.tensors[r]=this.tensors[r];return n}getItem(e,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);ht(this.tensors[e].shape,n,"TensorList shape mismatch: ");const s=wr(this.elementShape,this.tensors,n);return B(this.tensors[e],s)}setItem(e,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);ht(this.elementShape,n.shape,"TensorList shape mismatch: "),Rt(n),this.tensors[e]=n}gather(e,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);ht(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=wr(this.elementShape,this.tensors,r);return e.length===0?yt([],[0].concat(s)):Y(()=>{const a=e.map(o=>B(this.tensors[o],s));return qt(a,0)})}concat(e,n){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);ht(this.elementShape,n,"TensorList shape mismatch: ");const r=wr(this.elementShape,this.tensors,n);return this.size()===0?yt([],[0].concat(r)):Y(()=>{const s=this.tensors.map(a=>B(a,r));return We(s,0)})}}function jT(t,e,n){const r=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);const s=t.shape.slice(1);ht(s,e,"TensorList shape mismatch: ");const a=gn(t);return new Rn(a,e,r)}function UT(t,e,n,r){return new Rn([],t,e,r)}function WT(t,e,n,r){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const a=new Rn([],n,t.dtype,r),o=gn(t,0);return e.forEach((i,u)=>{a.setItem(i,o[u])}),a}function qT(t,e,n){let r=0;const s=e.map(c=>(r+=c,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);const a=t.shape.slice(1),o=oo(a,n),i=r===0?0:t.size/r,u=Y(()=>{const c=[];t=B(t,[1,r,i]);for(let h=0;h<e.length;++h){const p=h===0?0:s[h-1],d=[0,p,0],b=[1,e[h],i];c[h]=B(Te(t,d,b),o)}return t.dispose(),c}),l=new Rn([],n,t.dtype,e.length);for(let c=0;c<u.length;c++)l.setItem(c,u[c]);return l}const HT=async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{const r=m("thenBranch",t,e,n),s=m("elseBranch",t,e,n),a=m("cond",t,e,n),o=m("args",t,e,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=m("body",t,e,n),s=m("cond",t,e,n),a=m("args",t,e,n),o=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),i=a.map(c=>c.id);let u=await o[0].data();o.forEach(c=>{!c.kept&&i.indexOf(c.id)===-1&&c.dispose()});let l=a;for(;u[0];){const c=l;l=await n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const h=l.map(d=>d.id);c.forEach(d=>{!d.kept&&i.indexOf(d.id)===-1&&h.indexOf(d.id)===-1&&d.dispose()});const p=await n.functionMap[s].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);u=await p[0].data(),p.forEach(d=>{!d.kept&&i.indexOf(d.id)===-1&&h.indexOf(d.id)===-1&&d.dispose()})}return l}case"LoopCond":{const r=m("pred",t,e,n);return[Ht(r)]}case"Switch":{const r=m("pred",t,e,n);let s=m("data",t,e,n);return s.kept||(s=Ht(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=t.inputNames.find(s=>Ze(s,e,n)!==void 0);if(r){const s=Ze(r,e,n);return[Ht(s)]}return}case"Enter":{const r=m("frameName",t,e,n),s=m("tensor",t,e,n);return n.enterFrame(r),[Ht(s)]}case"Exit":{const r=m("tensor",t,e,n);return n.exitFrame(),[Ht(r)]}case"NextIteration":{const r=m("tensor",t,e,n);return n.nextIteration(),[Ht(r)]}case"TensorArrayV3":{const r=m("size",t,e,n),s=m("dtype",t,e,n),a=m("elementShape",t,e,n),o=m("dynamicSize",t,e,n),i=m("clearAfterRead",t,e,n),u=m("identicalElementShapes",t,e,n),l=m("name",t,e,n),c=new VT(l,s,r,a,u,o,i);return n.addTensorArray(c),[c.idTensor,se(1)]}case"TensorArrayWriteV3":{const r=m("tensorArrayId",t,e,n),s=m("index",t,e,n),a=m("tensor",t,e,n),o=n.getTensorArray(r.id);return o.write(s,a),[o.idTensor]}case"TensorArrayReadV3":{const r=m("tensorArrayId",t,e,n),s=m("index",t,e,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=m("tensorArrayId",t,e,n),s=m("indices",t,e,n),a=m("dtype",t,e,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{const r=m("tensorArrayId",t,e,n),s=m("indices",t,e,n),a=m("tensor",t,e,n),o=n.getTensorArray(r.id);return o.scatter(s,a),[o.idTensor]}case"TensorArrayConcatV3":{const r=m("tensorArrayId",t,e,n),s=n.getTensorArray(r.id),a=m("dtype",t,e,n);return[s.concat(a)]}case"TensorArraySplitV3":{const r=m("tensorArrayId",t,e,n),s=m("tensor",t,e,n),a=m("lengths",t,e,n),o=n.getTensorArray(r.id);return o.split(a,s),[o.idTensor]}case"TensorArraySizeV3":{const r=m("tensorArrayId",t,e,n),s=n.getTensorArray(r.id);return[se(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=m("tensorArrayId",t,e,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=m("tensorListId",t,e,n),s=m("index",t,e,n),a=m("tensor",t,e,n),o=n.getTensorList(r.id);return o.setItem(s,a),[o.idTensor]}case"TensorListGetItem":{const r=m("tensorListId",t,e,n),s=m("index",t,e,n),a=m("elementShape",t,e,n),o=m("elementDType",t,e,n);return[n.getTensorList(r.id).getItem(s,a,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=m("indices",t,e,n),s=m("tensor",t,e,n),a=m("elementShape",t,e,n),o=m("numElements",t,e,n),i=WT(s,r,a,o);return n.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=m("elementShape",t,e,n),s=m("elementDType",t,e,n);let a;t.op==="TensorListReserve"?a="numElements":a="maxNumElements";const o=m(a,t,e,n),i=t.op==="TensorListReserve"?-1:o,u=UT(r,s,o,i);return n.addTensorList(u),[u.idTensor]}case"TensorListGather":{const r=m("tensorListId",t,e,n),s=m("indices",t,e,n),a=m("elementShape",t,e,n),o=m("elementDType",t,e,n);return[n.getTensorList(r.id).gather(s,o,a)]}case"TensorListStack":{const r=m("tensorListId",t,e,n),s=m("elementShape",t,e,n),a=m("elementDType",t,e,n),o=m("numElements",t,e,n);return[n.getTensorList(r.id).stack(s,a,o)]}case"TensorListFromTensor":{const r=m("tensor",t,e,n),s=m("elementShape",t,e,n),a=m("elementDType",t,e,n),o=jT(r,s,a);return n.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=m("tensorListId",t,e,n),s=n.getTensorList(r.id),a=m("dtype",t,e,n),o=m("elementShape",t,e,n);return[s.concat(a,o)]}case"TensorListPushBack":{const r=m("tensorListId",t,e,n),s=m("tensor",t,e,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{const r=m("tensorListId",t,e,n),s=m("elementShape",t,e,n),a=m("elementDType",t,e,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{const r=m("tensor",t,e,n),s=m("elementShape",t,e,n),a=m("lengths",t,e,n),o=qT(r,a,s);return n.addTensorList(o),[o.idTensor]}case"TensorListLength":{const r=m("tensorListId",t,e,n),s=n.getTensorList(r.id);return[se(s.size(),"int32")]}case"TensorListResize":{const r=m("tensorListId",t,e,n),s=m("size",t,e,n),o=n.getTensorList(r.id).resize(s);return n.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};function fu(t,e,n){const[r,s]=m("fusedOps",t,e,n),a=r==="biasadd",o=!a,i=s==="prelu",u=r==="fusedbatchnorm",l=m("numArgs",t,e,n);if(a){if(i&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&a&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=m("strides",t,e,n),h=ws(t,e,n),p=m("dataFormat",t,e,n).toUpperCase(),d=m("dilations",t,e,n);let[b,v]=m("args",t,e,n);o&&(v=b,b=void 0);const N=m("leakyreluAlpha",t,e,n);return{stride:c,pad:h,dataFormat:p,dilations:d,biasArg:b,preluArg:v,activationFunc:s,leakyreluAlpha:N}}const GT=(t,e,n,r=qe)=>{switch(t.op){case"Conv1D":{const s=m("stride",t,e,n),a=m("pad",t,e,n),o=m("dataFormat",t,e,n).toUpperCase(),i=m("dilation",t,e,n);return[r.conv1d(m("x",t,e,n),m("filter",t,e,n),s,a,o,i)]}case"Conv2D":{const s=m("strides",t,e,n),a=ws(t,e,n),o=m("dataFormat",t,e,n).toUpperCase(),i=m("dilations",t,e,n);return[r.conv2d(m("x",t,e,n),m("filter",t,e,n),[s[1],s[2]],a,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:s,pad:a,dataFormat:o,dilations:i,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:h}=fu(t,e,n);return[r.fused.conv2d({x:m("x",t,e,n),filter:m("filter",t,e,n),strides:[s[1],s[2]],pad:a,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:a,dataFormat:o,dilations:i,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:h}=fu(t,e,n);return[r.fused.depthwiseConv2d({x:m("x",t,e,n),filter:m("filter",t,e,n),strides:[s[1],s[2]],pad:a,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=m("outputShape",t,e,n),a=m("strides",t,e,n),o=ws(t,e,n);return[r.conv2dTranspose(m("x",t,e,n),m("filter",t,e,n),s,[a[1],a[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=m("strides",t,e,n),a=ws(t,e,n),o=m("dilations",t,e,n),i=m("dataFormat",t,e,n).toUpperCase();return[r.depthwiseConv2d(m("input",t,e,n),m("filter",t,e,n),[s[1],s[2]],a,i,[o[1],o[2]])]}case"Conv3D":{const s=m("strides",t,e,n),a=m("pad",t,e,n),o=m("dataFormat",t,e,n).toUpperCase(),i=m("dilations",t,e,n);return[r.conv3d(m("x",t,e,n),m("filter",t,e,n),[s[1],s[2],s[3]],a,o,[i[1],i[2],i[3]])]}case"AvgPool":{const s=m("strides",t,e,n),a=m("pad",t,e,n),o=m("kernelSize",t,e,n);return[r.avgPool(m("x",t,e,n),[o[1],o[2]],[s[1],s[2]],a)]}case"MaxPool":{const s=m("strides",t,e,n),a=m("pad",t,e,n),o=m("kernelSize",t,e,n);return[r.maxPool(m("x",t,e,n),[o[1],o[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{const s=m("strides",t,e,n),a=m("pad",t,e,n),o=m("kernelSize",t,e,n),i=m("includeBatchInIndex",t,e,n),{result:u,indexes:l}=r.maxPoolWithArgmax(m("x",t,e,n),[o[1],o[2]],[s[1],s[2]],a,i);return[u,l]}case"AvgPool3D":{const s=m("strides",t,e,n),a=m("pad",t,e,n),o=m("kernelSize",t,e,n);return[r.avgPool3d(m("x",t,e,n),[o[1],o[2],o[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{const s=m("strides",t,e,n),a=m("pad",t,e,n),o=m("kernelSize",t,e,n);return[r.maxPool3d(m("x",t,e,n),[o[1],o[2],o[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{const s=m("strides",t,e,n),a=m("pad",t,e,n),o=m("dilations",t,e,n),i=s[1],u=s[2],l=o[1],c=o[2];return[r.dilation2d(m("x",t,e,n),m("filter",t,e,n),[i,u],a,[l,c],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const KT=(t,e,n,r=qe)=>{switch(t.op){case"Fill":{const s=m("shape",t,e,n),a=m("dtype",t,e,n),o=m("value",t,e,n);return[r.fill(s,o,a)]}case"LinSpace":{const s=m("start",t,e,n),a=m("stop",t,e,n),o=m("num",t,e,n);return[r.linspace(s,a,o)]}case"Multinomial":{const s=m("logits",t,e,n),a=m("numSamples",t,e,n),o=m("seed",t,e,n);return[r.multinomial(s,a,o)]}case"OneHot":{const s=m("indices",t,e,n),a=m("depth",t,e,n),o=m("onValue",t,e,n),i=m("offValue",t,e,n);return[r.oneHot(s,a,o,i)]}case"Ones":return[r.ones(m("shape",t,e,n),m("dtype",t,e,n))];case"OnesLike":return[r.onesLike(m("x",t,e,n))];case"RandomStandardNormal":return[r.randomStandardNormal(m("shape",t,e,n),m("dtype",t,e,n),m("seed",t,e,n))];case"RandomUniform":return[r.randomUniform(m("shape",t,e,n),m("minval",t,e,n),m("maxval",t,e,n),m("dtype",t,e,n))];case"Range":{const s=m("start",t,e,n),a=m("stop",t,e,n),o=m("step",t,e,n);return[r.range(s,a,o,m("dtype",t,e,n))]}case"TruncatedNormal":{const s=m("shape",t,e,n),a=m("mean",t,e,n),o=m("stdDev",t,e,n),i=m("seed",t,e,n);return[r.truncatedNormal(s,a,o,m("dtype",t,e,n),i)]}case"Zeros":return[r.zeros(m("shape",t,e,n),m("dtype",t,e,n))];case"ZerosLike":return[r.zerosLike(m("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function Sa(t,e,n){const r=m("boxes",t,e,n),s=m("scores",t,e,n),a=m("maxOutputSize",t,e,n),o=m("iouThreshold",t,e,n),i=m("scoreThreshold",t,e,n),u=m("softNmsSigma",t,e,n);return{boxes:r,scores:s,maxOutputSize:a,iouThreshold:o,scoreThreshold:i,softNmsSigma:u}}const XT=async(t,e,n,r,s=qe)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:l,softNmsSigma:c}=Sa(t,e,n),h=await s.image.nonMaxSuppressionWithScoreAsync(a,o,i,u,l,c);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:l}=Sa(t,e,n),c=m("padToMaxOutputSize",t,e,n),h=await s.image.nonMaxSuppressionPaddedAsync(a,o,i,u,l,c);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:l}=Sa(t,e,n);return[await s.image.nonMaxSuppressionAsync(a,o,i,u,l)]}case"Where":{const a=s.cast(m("condition",t,e,n),"bool"),o=[await s.whereAsync(a)];return a.dispose(),o}case"ListDiff":return s.setdiff1dAsync(m("x",t,e,n),m("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}};const YT=(t,e,n,r=qe)=>{switch(t.op){case"LowerBound":{const s=m("sortedSequence",t,e,n),a=m("values",t,e,n);return[r.lowerBound(s,a)]}case"TopKV2":{const s=m("x",t,e,n),a=m("k",t,e,n),o=m("sorted",t,e,n),i=r.topk(s,a,o);return[i.values,i.indices]}case"UpperBound":{const s=m("sortedSequence",t,e,n),a=m("values",t,e,n);return[r.upperBound(s,a)]}case"Unique":{const s=m("x",t,e,n),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{const s=m("x",t,e,n),a=m("axis",t,e,n),o=r.unique(s,a);return[o.values,o.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const ZT=(t,e,n,r=qe)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const s=m("default",t,e,n);return[Ze(t.name,e,n)||s];case"Placeholder":return[Ze(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=m("x",t,e,n);return[Ht(c)]}case"IdentityN":return m("x",t,e,n).map(c=>Ht(c));case"Snapshot":const a=m("x",t,e,n);return[Ht(a)];case"Shape":return[r.tensor1d(m("x",t,e,n).shape,"int32")];case"ShapeN":return m("x",t,e,n).map(c=>r.tensor1d(c.shape));case"Size":return[r.scalar(m("x",t,e,n).size,"int32")];case"Rank":return[r.scalar(m("x",t,e,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const o=m("x",t,e,n),i=m("data",t,e,n),u=m("message",t,e,n),l=m("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let c=0;c<i.length;c++)console.log(Array.prototype.slice.call(i[c].dataSync()).slice(0,l));return[o];default:throw TypeError(`Node type ${t.op} is not implemented`)}};class JT{constructor(e,n){this.keyDType=e,this.valueDType=n,this.handle=se(0),this.tensorMap=new Map,Rt(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return se(this.size(),"int32")}async import(e,n){this.checkKeyAndValueTensor(e,n);const r=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),Y(()=>{const s=gn(n),a=r.length,o=s.length;S(a===o,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${o} elements.`);for(let i=0;i<a;i++){const u=r[i],l=s[i];Rt(l),this.tensorMap.set(u,l)}return this.handle})}async find(e,n){this.checkKeyAndValueTensor(e,n);const r=await e.data();return Y(()=>{const s=[];for(let a=0;a<r.length;a++){const o=r[a],i=this.findWithDefault(o,n);s.push(i)}return qt(s)})}findWithDefault(e,n){const r=this.tensorMap.get(e);return r??n}checkKeyAndValueTensor(e,n){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}const QT=async(t,e,n,r)=>{switch(t.op){case"HashTable":case"HashTableV2":{const s=m("keyDType",t,e,n),a=m("valueDType",t,e,n),o=new JT(s,a);return r.addHashTable(t.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const s=m("tableHandle",t,e,n,r),a=m("keys",t,e,n),o=m("values",t,e,n);return[await r.getHashTableById(s.id).import(a,o)]}case"LookupTableFind":case"LookupTableFindV2":{const s=m("tableHandle",t,e,n,r),a=m("keys",t,e,n),o=m("defaultValue",t,e,n);return[await r.getHashTableById(s.id).find(a,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=m("tableHandle",t,e,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const eE=(t,e,n,r=qe)=>{switch(t.op){case"ResizeBilinear":{const s=m("images",t,e,n),a=m("size",t,e,n),o=m("alignCorners",t,e,n),i=m("halfPixelCenters",t,e,n);return[r.image.resizeBilinear(s,[a[0],a[1]],o,i)]}case"ResizeNearestNeighbor":{const s=m("images",t,e,n),a=m("size",t,e,n),o=m("alignCorners",t,e,n),i=m("halfPixelCenters",t,e,n);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],o,i)]}case"CropAndResize":{const s=m("image",t,e,n),a=m("boxes",t,e,n),o=m("boxInd",t,e,n),i=m("cropSize",t,e,n),u=m("method",t,e,n),l=m("extrapolationValue",t,e,n);return[r.image.cropAndResize(s,a,o,i,u,l)]}case"ImageProjectiveTransformV3":{const s=m("images",t,e,n),a=m("transforms",t,e,n),o=m("outputShape",t,e,n),i=m("fillValue",t,e,n),u=m("interpolation",t,e,n),l=m("fillMode",t,e,n);return[r.image.transform(s,a,u.toLowerCase(),l.toLowerCase(),i,o)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const tE=(t,e,n,r=qe)=>{switch(t.op){case"Equal":return[r.equal(m("a",t,e,n),m("b",t,e,n))];case"NotEqual":return[r.notEqual(m("a",t,e,n),m("b",t,e,n))];case"Greater":return[r.greater(m("a",t,e,n),m("b",t,e,n))];case"GreaterEqual":return[r.greaterEqual(m("a",t,e,n),m("b",t,e,n))];case"Less":return[r.less(m("a",t,e,n),m("b",t,e,n))];case"LessEqual":return[r.lessEqual(m("a",t,e,n),m("b",t,e,n))];case"LogicalAnd":return[r.logicalAnd(m("a",t,e,n),m("b",t,e,n))];case"LogicalNot":return[r.logicalNot(m("a",t,e,n))];case"LogicalOr":return[r.logicalOr(m("a",t,e,n),m("b",t,e,n))];case"Select":case"SelectV2":return[r.where(m("condition",t,e,n),m("a",t,e,n),m("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const nE=(t,e,n,r=qe)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(m("a",t,e,n),m("b",t,e,n),m("transposeA",t,e,n),m("transposeB",t,e,n))];case"Einsum":return[r.einsum(m("equation",t,e,n),...m("tensors",t,e,n))];case"Transpose":return[r.transpose(m("x",t,e,n),m("perm",t,e,n))];case"_FusedMatMul":const[s,a]=m("fusedOps",t,e,n),o=s==="biasadd",i=a==="prelu",u=m("numArgs",t,e,n),l=m("leakyreluAlpha",t,e,n);if(o){if(i&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,h]=m("args",t,e,n);return[r.fused.matMul({a:m("a",t,e,n),b:m("b",t,e,n),transposeA:m("transposeA",t,e,n),transposeB:m("transposeB",t,e,n),bias:c,activation:a,preluActivationWeights:h,leakyreluAlpha:l})];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const rE=(t,e,n,r=qe)=>{switch(t.op){case"EuclideanNorm":return[r.euclideanNorm(m("x",t,e,n),m("axis",t,e,n),m("keepDims",t,e,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(m("x",t,e,n),m("mean",t,e,n),m("variance",t,e,n),m("offset",t,e,n),m("scale",t,e,n),m("epsilon",t,e,n))];case"FusedBatchNormV3":return[r.batchNorm(m("x",t,e,n),m("mean",t,e,n),m("variance",t,e,n),m("offset",t,e,n),m("scale",t,e,n),m("epsilon",t,e,n))];case"LRN":return[r.localResponseNormalization(m("x",t,e,n),m("radius",t,e,n),m("bias",t,e,n),m("alpha",t,e,n),m("beta",t,e,n))];case"Softmax":return[r.softmax(m("x",t,e,n))];case"LogSoftmax":return[r.logSoftmax(m("x",t,e,n))];case"SparseToDense":return[r.sparseToDense(m("sparseIndices",t,e,n),m("outputShape",t,e,n),m("sparseValues",t,e,n),m("defaultValue",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const sE=(t,e,n,r=qe)=>{switch(t.op){case"Max":{const i=m("axis",t,e,n),u=m("keepDims",t,e,n);return[r.max(m("x",t,e,n),i,u)]}case"Mean":{const i=m("axis",t,e,n),u=m("keepDims",t,e,n);return[r.mean(m("x",t,e,n),i,u)]}case"Min":{const i=m("axis",t,e,n),u=m("keepDims",t,e,n);return[r.min(m("x",t,e,n),i,u)]}case"Sum":{const i=m("axis",t,e,n),u=m("keepDims",t,e,n);return[r.sum(m("x",t,e,n),i,u)]}case"All":{const i=m("axis",t,e,n),u=m("keepDims",t,e,n);return[r.all(m("x",t,e,n),i,u)]}case"Any":{const i=m("axis",t,e,n),u=m("keepDims",t,e,n);return[r.any(m("x",t,e,n),i,u)]}case"ArgMax":{const i=m("axis",t,e,n);return[r.argMax(m("x",t,e,n),i)]}case"ArgMin":{const i=m("axis",t,e,n);return[r.argMin(m("x",t,e,n),i)]}case"Prod":{const i=m("axis",t,e,n),u=m("keepDims",t,e,n);return[r.prod(m("x",t,e,n),i,u)]}case"Cumprod":{const i=m("axis",t,e,n),u=m("exclusive",t,e,n),l=m("reverse",t,e,n);return[r.cumprod(m("x",t,e,n),i,u,l)]}case"Cumsum":{const i=m("axis",t,e,n),u=m("exclusive",t,e,n),l=m("reverse",t,e,n);return[r.cumsum(m("x",t,e,n),i,u,l)]}case"Bincount":const s=m("x",t,e,n),a=m("weights",t,e,n),o=m("size",t,e,n);return[r.bincount(s,a,o)];case"DenseBincount":{const i=m("x",t,e,n),u=m("weights",t,e,n),l=m("size",t,e,n),c=m("binaryOutput",t,e,n);return[r.denseBincount(i,u,l,c)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const aE=(t,e,n,r=qe)=>{switch(t.op){case"ConcatV2":case"Concat":{const s=m("n",t,e,n),a=m("axis",t,e,n);let o=m("tensors",t,e,n);return o=o.slice(0,s),[r.concat(o,a)]}case"Gather":{const s=m("x",t,e,n),a=m("indices",t,e,n);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{const s=m("axis",t,e,n),a=m("batchDims",t,e,n),o=m("x",t,e,n),i=m("indices",t,e,n);return[r.gather(o,r.cast(i,"int32"),s,a)]}case"Reverse":{const s=m("dims",t,e,n),a=[];for(let i=0;i<s.length;i++)s[i]&&a.push(i);const o=m("x",t,e,n);return[r.reverse(o,a)]}case"ReverseV2":{const s=m("axis",t,e,n),a=m("x",t,e,n);return[r.reverse(a,s)]}case"Slice":{const s=m("begin",t,e,n),a=m("size",t,e,n);return[r.slice(m("x",t,e,n),s,a)]}case"StridedSlice":{const s=m("begin",t,e,n),a=m("end",t,e,n),o=m("strides",t,e,n),i=m("beginMask",t,e,n),u=m("endMask",t,e,n),l=m("ellipsisMask",t,e,n),c=m("newAxisMask",t,e,n),h=m("shrinkAxisMask",t,e,n),p=m("x",t,e,n);return[r.stridedSlice(p,s,a,o,i,u,l,c,h)]}case"Pack":return Y(()=>{const s=m("axis",t,e,n),a=m("tensors",t,e,n),o=a[0].shape,i=r.squeeze(a[0]).shape,u=a.map(l=>{const c=zt(l.shape,o);if(!c&&!zt(r.squeeze(l).shape,i))throw new Error("the input tensors shape does not match");return c?l:r.reshape(l,o)});return[r.stack(u,s)]});case"Unpack":{const s=m("axis",t,e,n),a=m("tensor",t,e,n);return r.unstack(a,s)}case"Tile":{const s=m("reps",t,e,n);return[r.tile(m("x",t,e,n),s)]}case"Split":case"SplitV":{const s=m("axis",t,e,n),a=m("numOrSizeSplits",t,e,n),o=m("x",t,e,n);return r.split(o,a,s)}case"ScatterNd":{const s=m("indices",t,e,n),a=m("values",t,e,n),o=m("shape",t,e,n);return[r.scatterND(s,a,o)]}case"GatherNd":{const s=m("x",t,e,n),a=m("indices",t,e,n);return[r.gatherND(s,a)]}case"SparseToDense":{const s=m("sparseIndices",t,e,n),a=m("outputShape",t,e,n),o=m("sparseValues",t,e,n),i=m("defaultValue",t,e,n);return[r.sparseToDense(s,o,a,o.dtype===i.dtype?i:r.cast(i,o.dtype))]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const oE=(t,e,n,r=qe)=>{switch(t.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:a,emptyRowIndicator:o,reverseIndexMap:i}=r.sparse.sparseFillEmptyRows(m("indices",t,e,n),m("values",t,e,n),m("denseShape",t,e,n),m("defaultValue",t,e,n));return[s,a,o,i]}case"SparseReshape":{const{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(m("inputIndices",t,e,n),m("inputShape",t,e,n),m("newShape",t,e,n));return[s,a]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(m("data",t,e,n),m("indices",t,e,n),m("segmentIds",t,e,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(m("data",t,e,n),m("indices",t,e,n),m("segmentIds",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const iE=(t,e,n,r=qe)=>{switch(t.op){case"FFT":return[r.fft(m("x",t,e,n))];case"IFFT":return[r.ifft(m("x",t,e,n))];case"RFFT":return[r.rfft(m("x",t,e,n))];case"IRFFT":return[r.irfft(m("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const uE=(t,e,n,r=qe)=>{switch(t.op){case"StringNGrams":{const{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(m("data",t,e,n),m("dataSplits",t,e,n),m("separator",t,e,n),m("nGramWidths",t,e,n),m("leftPad",t,e,n),m("rightPad",t,e,n),m("padWidth",t,e,n),m("preserveShortSequences",t,e,n));return[s,a]}case"StringSplit":{const{indices:s,values:a,shape:o}=r.string.stringSplit(m("input",t,e,n),m("delimiter",t,e,n),m("skipEmpty",t,e,n));return[s,a,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(m("input",t,e,n),m("numBuckets",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const lE=(t,e,n,r=qe)=>{switch(t.op){case"Cast":return[r.cast(m("x",t,e,n),m("dtype",t,e,n))];case"ExpandDims":{const s=m("axis",t,e,n);return[r.expandDims(m("x",t,e,n),s)]}case"Squeeze":{const s=m("axis",t,e,n);return[r.squeeze(m("x",t,e,n),s)]}case"Reshape":return[r.reshape(m("x",t,e,n),m("shape",t,e,n))];case"MirrorPad":return[r.mirrorPad(m("x",t,e,n),m("padding",t,e,n),m("mode",t,e,n))];case"PadV2":case"Pad":return[r.pad(m("x",t,e,n),m("padding",t,e,n),m("constantValue",t,e,n))];case"SpaceToBatchND":{const s=m("blockShape",t,e,n),a=m("paddings",t,e,n);return[r.spaceToBatchND(m("x",t,e,n),s,a)]}case"BatchToSpaceND":{const s=m("blockShape",t,e,n),a=m("crops",t,e,n);return[r.batchToSpaceND(m("x",t,e,n),s,a)]}case"DepthToSpace":{const s=m("blockSize",t,e,n),a=m("dataFormat",t,e,n).toUpperCase();return[r.depthToSpace(m("x",t,e,n),s,a)]}case"BroadcastTo":return[r.broadcastTo(m("x",t,e,n),m("shape",t,e,n))];case"BroadcastArgs":return[r.broadcastArgs(m("s0",t,e,n),m("s1",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function pu(t,e,n,r,s=Y){const a=((o,i,u)=>{switch(o.category){case"arithmetic":return s(()=>MT(o,i,u));case"basic_math":return s(()=>zT(o,i,u));case"control":return HT(o,i,u);case"convolution":return s(()=>GT(o,i,u));case"creation":return s(()=>KT(o,i,u));case"dynamic":return XT(o,i,u);case"evaluation":return s(()=>YT(o,i,u));case"image":return s(()=>eE(o,i,u));case"graph":return s(()=>ZT(o,i,u));case"logical":return s(()=>tE(o,i,u));case"matrices":return s(()=>nE(o,i,u));case"normalization":return s(()=>rE(o,i,u));case"reduction":return s(()=>sE(o,i,u));case"slice_join":return s(()=>aE(o,i,u));case"sparse":return s(()=>oE(o,i,u));case"spectral":return s(()=>iE(o,i,u));case"string":return s(()=>uE(o,i,u));case"transformation":return s(()=>lE(o,i,u));case"hash_table":return QT(o,i,u,r);case"custom":const l=Hd(o.op);if(l&&l.customExecutor)return l.customExecutor(new LT(o,i,u));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return An(a)?a.then(o=>[].concat(o)):[].concat(a)}class du{constructor(e={},n={},r={},s={}){this.weightMap=e,this.tensorArrayMap=n,this.tensorListMap=r,this.functionMap=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,n){return{id:e,frameName:n,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let n=0;n<this.contexts.length-1;n++){const r=this.contexts.slice(0,this.contexts.length-n);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(e);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(e)}}function mu(t,e,n,r){const s=new Set,a=[];let o=null,i=null;const u=new Set,l=Object.keys(t).map(p=>nt(p)[0]);let c=[];r!=null&&(c=r.map(p=>nt(p.name)[0]));const h=[...e];for(;h.length>0;){const p=h.pop();if((Xd(p)||dE(p)||mE(p))&&o==null&&(o=p,i=o.children.map(d=>d.name).filter(d=>s.has(d))),s.add(p.name),n[p.name]==null&&l.indexOf(p.name)===-1&&c.indexOf(p.name)===-1){if(p.inputs.length===0){a.push(p.name);continue}p.inputs.forEach(d=>{u.has(d.name)||(u.add(d.name),h.push(d))})}}return{inputs:t,outputs:e,usedNodes:s,missingInputs:a,dynamicNode:o,syncInputs:i}}function cE(t,e,n){const{usedNodes:r,inputs:s}=n,a=[],o=Object.keys(s).map(c=>nt(c)[0]).map(c=>t.nodes[c]),i=t.initNodes;o.forEach(c=>{r.has(c.name)&&a.push(c)}),t.weights.forEach(c=>{r.has(c.name)&&a.push(c)}),i?.forEach(c=>{r.has(c.name)&&a.push(c)});const u=new Set,l=[];for(;a.length>0;){const c=a.pop();u.add(c.name),e[c.name]||l.push(c),c.children.forEach(h=>{!u.has(h.name)&&r.has(h.name)&&h.inputs.every(p=>u.has(p.name))&&a.push(h)})}return l}const hE=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],fE=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],pE=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Xd(t){return hE.indexOf(t.op)>=0}function dE(t){return fE.indexOf(t.op)>=0}function mE(t){return pE.indexOf(t.op)>=0}class Ds{constructor(e,n){this.graph=e,this.parent=n,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new Ds(e.functions[r],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const n=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...n),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const n=e.signatureKey||e.name;return e.defaultOutput?`${n}:${e.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((e,n)=>(e[n]=this._functions[n].signature,e),{})}getCompilationKey(e,n){const r=e.map(a=>a.name).sort(),s=n.map(a=>a.name).sort();return r.join(this.SEPERATOR)+"--"+s.join(this.SEPERATOR)}compile(e,n){const r=mu(e,n,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:a,syncInputs:o}=r;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(s.length>0){const i=n.map(l=>l.name),u=Object.keys(e);throw new Error(`Cannot compute the outputs [${i}] from the provided inputs [${u}]. Missing the following inputs: [${s}]`)}return cE(this.graph,this.weightMap,r)}execute(e,n){e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n);const s=r.map(h=>this.graph.nodes[nt(h)[0]]),a=n.map(h=>nt(h)[0]);let o=a.map(h=>this.graph.nodes[h]);this.resetIntermediateTensors(),o.length===0&&(o=this._outputs);const i=this.getCompilationKey(s,o);let u=this.compiledMap.get(i);u==null&&(u=this.compile(e,o),this.compiledMap.set(i,u));const l={},c={};return Y(()=>{const h=new du(this.weightMap,l,c,this.functionExecutorMap),p=Object.assign({},this.weightMap);Object.keys(e).forEach(v=>{const[N,_]=nt(v),F=[];F[_]=e[v],p[N]=F});const d=this.getFrozenTensorIds(p),b={};for(let v=0;v<u.length;v++){const N=u[v];if(!p[N.name]){const _=pu(N,p,h,this._resourceManager);if(An(_))throw new Error(`The execution of the op '${N.op}' returned a promise. Please use model.executeAsync() instead.`);p[N.name]=_,this.checkTensorForDisposal(N.name,N,p,h,d,a,b)}}return this.parent==null&&h.dispose(d),n.map(v=>Ze(v,p,h))})}getFrozenTensorIds(e){const n=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(n)}checkTensorForDisposal(e,n,r,s,a,o,i){n.category==="control"||o.indexOf(e)!==-1||(r[e].forEach(u=>{u!=null&&(i[u.id]=(i[u.id]||0)+n.children.length)}),n.inputs.forEach(u=>{if(u.category!=="control"){const l=JN(u.name,r,s);l?.forEach(c=>{if(c&&!c.kept&&!a.has(c.id)){const h=i[c.id];if(h===1){if(!this.keepTensorForDebug)c.dispose();else{const[p,d]=Pt(n.name,s);this.intermediateTensors[p]?this.intermediateTensors[p][d]=c:(this.intermediateTensors[p]=[],this.intermediateTensors[p][d]=c)}delete i[c.id]}else h!=null&&i[c.id]--}})}}))}async executeAsync(e,n){return this._executeAsync(e,n)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach(e=>this.intermediateTensors[e].forEach(n=>n.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach(e=>{this.tensorsMap[e].forEach(r=>{r&&!r.kept&&!r.isDisposed&&!this.keepIds.has(r.id)&&r.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors)this.intermediateTensors[e].forEach(n=>n.dispose()),delete this.intermediateTensors[e]}async _executeAsync(e,n,r=!1,s={},a={}){r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepTensorForDebug=re().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){console.warn(c.message)}this.resetIntermediateTensors();const o=new du(this.weightMap,s,a,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,o,n,r);const i=n.map(c=>Ze(c,this.tensorsMap,o)),u=i.map(c=>c.id),l=Object.keys(e).map(c=>e[c].id);return this.keepIds=new Set([...u,...l,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&o.dispose(this.keepIds),i}async executeFunctionAsync(e,n,r){const s=e.reduce((a,o,i)=>(a[this.inputs[i].name]=o,a),{});return this._executeAsync(s,this.outputNodes,!0,n,r)}async executeWithControlFlow(e,n,r,s){const a=Object.keys(e),o=a.map(x=>this.graph.nodes[nt(x)[0]]),i=r.map(x=>nt(x)[0]);let u=i.map(x=>this.graph.nodes[x]);u.length===0&&(u=this._outputs);const{usedNodes:l,missingInputs:c,dynamicNode:h,syncInputs:p}=mu(e,u,this.weightMap,this._initNodes),d=[...o,...this.graph.weights,...this._initNodes||[]].map(x=>({node:x,contexts:n.currentContext})),b=Object.assign({},this.weightMap);Object.keys(e).forEach(x=>{const[$,A]=nt(x),I=[];I[A]=e[x],b[$]=I});const v={},N=this.getFrozenTensorIds(b),_={};for(;d.length>0;){const x=this.processStack(o,d,n,b,_,N,i,v,l);await Promise.all(x)}h==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const F=u.filter(x=>!Xd(x)&&!Ze(x.name,b,n)).map(x=>x.name);if(F.length>0){let x="";throw h!=null&&(x=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${F}] from the provided inputs [${a}]. Consider providing the following inputs: [${c}]. ${x}`)}return b}processStack(e,n,r,s,a,o,i,u,l){const c=[];for(;n.length>0;){const h=n.pop();r.currentContext=h.contexts;let p="";if(h.node.op==="Enter"&&m("isConstant",h.node,s,r)&&([p]=Pt(h.node.name,r)),s[h.node.name]==null){const d=pu(h.node,s,r,this._resourceManager);p||([p]=Pt(h.node.name,r));const b=r.currentContext;An(d)?c.push(d.then(v=>(s[p]=v,r.currentContext=b,this.checkTensorForDisposal(p,h.node,s,r,o,i,u),this.processChildNodes(h.node,n,r,s,a,l),v))):(s[p]=d,this.checkTensorForDisposal(p,h.node,s,r,o,i,u),this.processChildNodes(h.node,n,r,s,a,l))}else this.processChildNodes(h.node,n,r,s,a,l)}return c}processChildNodes(e,n,r,s,a,o){e.children.forEach(i=>{const[u]=Pt(i.name,r);a[u]||!o.has(i.name)||(i.op==="Merge"?i.inputNames.some(l=>!!Ze(l,s,r))&&(a[u]=!0,n.push({contexts:r.currentContext,node:i})):i.inputNames.every(l=>!!Ze(l,s,r))&&(a[u]=!0,n.push({contexts:r.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(n=>n.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(n=>{const r=e[n],[s]=nt(n),a=this.graph.nodes[s];if(a.attrParams.shape&&a.attrParams.shape.value){const o=a.attrParams.shape.value,i=o.length===r.shape.length&&r.shape.every((u,l)=>o[l]===-1||o[l]===u);S(i,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${o}], but was [${r.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&S(r.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){const n={};for(const r in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[r]!=null){const s=this._signature.inputs[r];n[s.name]=e[r]}else n[r]=e[r];return n}checkInputs(e){const n=Object.keys(e).filter(r=>{const[s]=nt(r);return this.graph.nodes[s]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(e){return e.map(n=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[n]!=null?this._signature.outputs[n].name:n,{})}checkOutputs(e){e.forEach(n=>{const[r]=nt(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}}class gE{constructor(e={},n={}){this.hashTableNameToHandle=e,this.hashTableMap=n}addHashTable(e,n){this.hashTableNameToHandle[e]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const yE="?tfjs-format=file",bE="model.json";class wE{constructor(e,n={},r=$o){this.modelUrl=e,this.loadOptions=n,this.version="n/a",this.io=r,n==null&&(this.loadOptions={}),this.resourceManager=new gE}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const n=this.io.getLoadHandlers(e,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[e]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return An(e)?e.then(n=>this.loadSync(n)):this.loadSync(e)}loadSync(e){this.artifacts=e;const n=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const a=this.artifacts.userDefinedMetadata;a.signature!=null&&(r=a.signature),a.structuredOutputKeys!=null&&(this.structuredOutputKeys=a.structuredOutputKeys)}this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`;const s=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Ds(lu.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const a=lu.Instance.transformGraph(e.modelInitializer);this.initializer=new Ds(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,n){if(typeof e=="string"){const r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,n){const r=this.execute(e,this.outputNodes);if(this.structuredOutputKeys){const s=r instanceof be?[r]:r,a={};return s.forEach((o,i)=>a[this.structuredOutputKeys[i]]=o),a}return r}normalizeInputs(e){if(!(e instanceof be)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((n,r,s)=>(n[r]=e[s],n),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,n){e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const r=this.executor.execute(e,n);return r.length>1?r:r[0]}async executeAsync(e,n){e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const r=await this.executor.executeAsync(e,n);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((n,r)=>(n[r]=[e[r]],n),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function Ni(t,e={},n=$o){if(t==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof t=="string"&&(t=vE(t));const r=new wE(t,e,n);return await r.load(),r}function vE(t){return t.endsWith("/")||(t=t+"/"),`${t}${bE}${yE}`}(function(){var t;function e(f){var g=0;return function(){return g<f.length?{done:!1,value:f[g++]}:{done:!0}}}var n=typeof Object.defineProperties=="function"?Object.defineProperty:function(f,g,y){return f==Array.prototype||f==Object.prototype||(f[g]=y.value),f};function r(f){f=[typeof globalThis=="object"&&globalThis,f,typeof window=="object"&&window,typeof self=="object"&&self,typeof Bt=="object"&&Bt];for(var g=0;g<f.length;++g){var y=f[g];if(y&&y.Math==Math)return y}throw Error("Cannot find global object")}var s=r(this);function a(f,g){if(g)e:{var y=s;f=f.split(".");for(var T=0;T<f.length-1;T++){var O=f[T];if(!(O in y))break e;y=y[O]}f=f[f.length-1],T=y[f],g=g(T),g!=T&&g!=null&&n(y,f,{configurable:!0,writable:!0,value:g})}}a("Symbol",function(f){function g(L){if(this instanceof g)throw new TypeError("Symbol is not a constructor");return new y(T+(L||"")+"_"+O++,L)}function y(L,D){this.g=L,n(this,"description",{configurable:!0,writable:!0,value:D})}if(f)return f;y.prototype.toString=function(){return this.g};var T="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",O=0;return g}),a("Symbol.iterator",function(f){if(f)return f;f=Symbol("Symbol.iterator");for(var g="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),y=0;y<g.length;y++){var T=s[g[y]];typeof T=="function"&&typeof T.prototype[f]!="function"&&n(T.prototype,f,{configurable:!0,writable:!0,value:function(){return o(e(this))}})}return f});function o(f){return f={next:f},f[Symbol.iterator]=function(){return this},f}function i(f){var g=typeof Symbol<"u"&&Symbol.iterator&&f[Symbol.iterator];return g?g.call(f):{next:e(f)}}function u(f){if(!(f instanceof Array)){f=i(f);for(var g,y=[];!(g=f.next()).done;)y.push(g.value);f=y}return f}var l=typeof Object.create=="function"?Object.create:function(f){function g(){}return g.prototype=f,new g},c;if(typeof Object.setPrototypeOf=="function")c=Object.setPrototypeOf;else{var h;e:{var p={a:!0},d={};try{d.__proto__=p,h=d.a;break e}catch{}h=!1}c=h?function(f,g){if(f.__proto__=g,f.__proto__!==g)throw new TypeError(f+" is not extensible");return f}:null}var b=c;function v(f,g){if(f.prototype=l(g.prototype),f.prototype.constructor=f,b)b(f,g);else for(var y in g)if(y!="prototype")if(Object.defineProperties){var T=Object.getOwnPropertyDescriptor(g,y);T&&Object.defineProperty(f,y,T)}else f[y]=g[y];f.ea=g.prototype}function N(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.s=this.m=0,this.j=null}function _(f){if(f.l)throw new TypeError("Generator is already running");f.l=!0}N.prototype.o=function(f){this.h=f};function F(f,g){f.j={U:g,V:!0},f.g=f.m||f.s}N.prototype.return=function(f){this.j={return:f},this.g=this.s};function x(f,g,y){return f.g=y,{value:g}}function $(f){this.g=new N,this.h=f}function A(f,g){_(f.g);var y=f.g.i;return y?I(f,"return"in y?y.return:function(T){return{value:T,done:!0}},g,f.g.return):(f.g.return(g),P(f))}function I(f,g,y,T){try{var O=g.call(f.g.i,y);if(!(O instanceof Object))throw new TypeError("Iterator result "+O+" is not an object");if(!O.done)return f.g.l=!1,O;var L=O.value}catch(D){return f.g.i=null,F(f.g,D),P(f)}return f.g.i=null,T.call(f.g,L),P(f)}function P(f){for(;f.g.g;)try{var g=f.h(f.g);if(g)return f.g.l=!1,{value:g.value,done:!1}}catch(y){f.g.h=void 0,F(f.g,y)}if(f.g.l=!1,f.g.j){if(g=f.g.j,f.g.j=null,g.V)throw g.U;return{value:g.return,done:!0}}return{value:void 0,done:!0}}function M(f){this.next=function(g){return _(f.g),f.g.i?g=I(f,f.g.i.next,g,f.g.o):(f.g.o(g),g=P(f)),g},this.throw=function(g){return _(f.g),f.g.i?g=I(f,f.g.i.throw,g,f.g.o):(F(f.g,g),g=P(f)),g},this.return=function(g){return A(f,g)},this[Symbol.iterator]=function(){return this}}function C(f,g){return g=new M(new $(g)),b&&f.prototype&&b(g,f.prototype),g}function j(f,g){f instanceof String&&(f+="");var y=0,T=!1,O={next:function(){if(!T&&y<f.length){var L=y++;return{value:g(L,f[L]),done:!1}}return T=!0,{done:!0,value:void 0}}};return O[Symbol.iterator]=function(){return O},O}var z=typeof Object.assign=="function"?Object.assign:function(f,g){for(var y=1;y<arguments.length;y++){var T=arguments[y];if(T)for(var O in T)Object.prototype.hasOwnProperty.call(T,O)&&(f[O]=T[O])}return f};a("Object.assign",function(f){return f||z}),a("Promise",function(f){function g(D){this.h=0,this.i=void 0,this.g=[],this.o=!1;var R=this.j();try{D(R.resolve,R.reject)}catch(V){R.reject(V)}}function y(){this.g=null}function T(D){return D instanceof g?D:new g(function(R){R(D)})}if(f)return f;y.prototype.h=function(D){if(this.g==null){this.g=[];var R=this;this.i(function(){R.l()})}this.g.push(D)};var O=s.setTimeout;y.prototype.i=function(D){O(D,0)},y.prototype.l=function(){for(;this.g&&this.g.length;){var D=this.g;this.g=[];for(var R=0;R<D.length;++R){var V=D[R];D[R]=null;try{V()}catch(q){this.j(q)}}}this.g=null},y.prototype.j=function(D){this.i(function(){throw D})},g.prototype.j=function(){function D(q){return function(Q){V||(V=!0,q.call(R,Q))}}var R=this,V=!1;return{resolve:D(this.C),reject:D(this.l)}},g.prototype.C=function(D){if(D===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(D instanceof g)this.F(D);else{e:switch(typeof D){case"object":var R=D!=null;break e;case"function":R=!0;break e;default:R=!1}R?this.u(D):this.m(D)}},g.prototype.u=function(D){var R=void 0;try{R=D.then}catch(V){this.l(V);return}typeof R=="function"?this.G(R,D):this.m(D)},g.prototype.l=function(D){this.s(2,D)},g.prototype.m=function(D){this.s(1,D)},g.prototype.s=function(D,R){if(this.h!=0)throw Error("Cannot settle("+D+", "+R+"): Promise already settled in state"+this.h);this.h=D,this.i=R,this.h===2&&this.D(),this.A()},g.prototype.D=function(){var D=this;O(function(){if(D.B()){var R=s.console;typeof R<"u"&&R.error(D.i)}},1)},g.prototype.B=function(){if(this.o)return!1;var D=s.CustomEvent,R=s.Event,V=s.dispatchEvent;return typeof V>"u"?!0:(typeof D=="function"?D=new D("unhandledrejection",{cancelable:!0}):typeof R=="function"?D=new R("unhandledrejection",{cancelable:!0}):(D=s.document.createEvent("CustomEvent"),D.initCustomEvent("unhandledrejection",!1,!0,D)),D.promise=this,D.reason=this.i,V(D))},g.prototype.A=function(){if(this.g!=null){for(var D=0;D<this.g.length;++D)L.h(this.g[D]);this.g=null}};var L=new y;return g.prototype.F=function(D){var R=this.j();D.J(R.resolve,R.reject)},g.prototype.G=function(D,R){var V=this.j();try{D.call(R,V.resolve,V.reject)}catch(q){V.reject(q)}},g.prototype.then=function(D,R){function V(le,te){return typeof le=="function"?function(H){try{q(le(H))}catch(ee){Q(ee)}}:te}var q,Q,Se=new g(function(le,te){q=le,Q=te});return this.J(V(D,q),V(R,Q)),Se},g.prototype.catch=function(D){return this.then(void 0,D)},g.prototype.J=function(D,R){function V(){switch(q.h){case 1:D(q.i);break;case 2:R(q.i);break;default:throw Error("Unexpected state: "+q.h)}}var q=this;this.g==null?L.h(V):this.g.push(V),this.o=!0},g.resolve=T,g.reject=function(D){return new g(function(R,V){V(D)})},g.race=function(D){return new g(function(R,V){for(var q=i(D),Q=q.next();!Q.done;Q=q.next())T(Q.value).J(R,V)})},g.all=function(D){var R=i(D),V=R.next();return V.done?T([]):new g(function(q,Q){function Se(H){return function(ee){le[H]=ee,te--,te==0&&q(le)}}var le=[],te=0;do le.push(void 0),te++,T(V.value).J(Se(le.length-1),Q),V=R.next();while(!V.done)})},g}),a("Object.is",function(f){return f||function(g,y){return g===y?g!==0||1/g===1/y:g!==g&&y!==y}}),a("Array.prototype.includes",function(f){return f||function(g,y){var T=this;T instanceof String&&(T=String(T));var O=T.length;for(y=y||0,0>y&&(y=Math.max(y+O,0));y<O;y++){var L=T[y];if(L===g||Object.is(L,g))return!0}return!1}}),a("String.prototype.includes",function(f){return f||function(g,y){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(g instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(g,y||0)!==-1}}),a("Array.prototype.keys",function(f){return f||function(){return j(this,function(g){return g})}});var G=this||self;function K(f,g){f=f.split(".");var y=G;f[0]in y||typeof y.execScript>"u"||y.execScript("var "+f[0]);for(var T;f.length&&(T=f.shift());)f.length||g===void 0?y[T]&&y[T]!==Object.prototype[T]?y=y[T]:y=y[T]={}:y[T]=g}function Z(f,g){return g=String.fromCharCode.apply(null,g),f==null?g:f+g}var ie,pe=typeof TextDecoder<"u",Oe,Ve=typeof TextEncoder<"u";function je(f){if(Ve)f=(Oe||(Oe=new TextEncoder)).encode(f);else{var g=void 0;g=g===void 0?!1:g;for(var y=0,T=new Uint8Array(3*f.length),O=0;O<f.length;O++){var L=f.charCodeAt(O);if(128>L)T[y++]=L;else{if(2048>L)T[y++]=L>>6|192;else{if(55296<=L&&57343>=L){if(56319>=L&&O<f.length){var D=f.charCodeAt(++O);if(56320<=D&&57343>=D){L=1024*(L-55296)+D-56320+65536,T[y++]=L>>18|240,T[y++]=L>>12&63|128,T[y++]=L>>6&63|128,T[y++]=L&63|128;continue}else O--}if(g)throw Error("Found an unpaired surrogate");L=65533}T[y++]=L>>12|224,T[y++]=L>>6&63|128}T[y++]=L&63|128}}f=T.subarray(0,y)}return f}var Ot={},St=null;function Jt(f,g){g===void 0&&(g=0),Tt(),g=Ot[g];for(var y=Array(Math.floor(f.length/3)),T=g[64]||"",O=0,L=0;O<f.length-2;O+=3){var D=f[O],R=f[O+1],V=f[O+2],q=g[D>>2];D=g[(D&3)<<4|R>>4],R=g[(R&15)<<2|V>>6],V=g[V&63],y[L++]=q+D+R+V}switch(q=0,V=T,f.length-O){case 2:q=f[O+1],V=g[(q&15)<<2]||T;case 1:f=f[O],y[L]=g[f>>2]+g[(f&3)<<4|q>>4]+V+T}return y.join("")}function Dt(f){var g=f.length,y=3*g/4;y%3?y=Math.floor(y):"=.".indexOf(f[g-1])!=-1&&(y="=.".indexOf(f[g-2])!=-1?y-2:y-1);var T=new Uint8Array(y),O=0;return Nt(f,function(L){T[O++]=L}),T.subarray(0,O)}function Nt(f,g){function y(V){for(;T<f.length;){var q=f.charAt(T++),Q=St[q];if(Q!=null)return Q;if(!/^[\s\xa0]*$/.test(q))throw Error("Unknown base64 encoding at char: "+q)}return V}Tt();for(var T=0;;){var O=y(-1),L=y(0),D=y(64),R=y(64);if(R===64&&O===-1)break;g(O<<2|L>>4),D!=64&&(g(L<<4&240|D>>2),R!=64&&g(D<<6&192|R))}}function Tt(){if(!St){St={};for(var f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),g=["+/=","+/","-_=","-_.","-_"],y=0;5>y;y++){var T=f.concat(g[y].split(""));Ot[y]=T;for(var O=0;O<T.length;O++){var L=T[O];St[L]===void 0&&(St[L]=O)}}}}var Et=typeof Uint8Array.prototype.slice=="function",Ft;function Qt(f,g,y){return g===y?Ft||(Ft=new Uint8Array(0)):Et?f.slice(g,y):new Uint8Array(f.subarray(g,y))}var tt=0,kt=0;function ts(f,g){g=g===void 0?{}:g,g=g.v===void 0?!1:g.v,this.h=null,this.g=this.i=this.j=0,this.l=!1,this.v=g,f&&ki(this,f)}function ki(f,g){g=g.constructor===Uint8Array?g:g.constructor===ArrayBuffer?new Uint8Array(g):g.constructor===Array?new Uint8Array(g):g.constructor===String?Dt(g):g instanceof Uint8Array?new Uint8Array(g.buffer,g.byteOffset,g.byteLength):new Uint8Array(0),f.h=g,f.j=0,f.i=f.h.length,f.g=f.j}ts.prototype.reset=function(){this.g=this.j};function pr(f){var g=f.h,y=g[f.g],T=y&127;return 128>y?(f.g+=1,T):(y=g[f.g+1],T|=(y&127)<<7,128>y?(f.g+=2,T):(y=g[f.g+2],T|=(y&127)<<14,128>y?(f.g+=3,T):(y=g[f.g+3],T|=(y&127)<<21,128>y?(f.g+=4,T):(y=g[f.g+4],T|=(y&15)<<28,128>y?(f.g+=5,T>>>0):(f.g+=5,128<=g[f.g++]&&128<=g[f.g++]&&128<=g[f.g++]&&128<=g[f.g++]&&f.g++,T)))))}function xt(f){var g=f.h[f.g],y=f.h[f.g+1],T=f.h[f.g+2],O=f.h[f.g+3];return f.g+=4,y=(g<<0|y<<8|T<<16|O<<24)>>>0,f=2*(y>>31)+1,g=y>>>23&255,y&=8388607,g==255?y?NaN:1/0*f:g==0?f*Math.pow(2,-149)*y:f*Math.pow(2,g-150)*(y+Math.pow(2,23))}var xi=[];function ns(){this.g=new Uint8Array(64),this.h=0}ns.prototype.push=function(f){if(!(this.h+1<this.g.length)){var g=this.g;this.g=new Uint8Array(Math.ceil(1+2*this.g.length)),this.g.set(g)}this.g[this.h++]=f},ns.prototype.length=function(){return this.h},ns.prototype.end=function(){var f=this.g,g=this.h;return this.h=0,Qt(f,0,g)};function en(f,g){for(;127<g;)f.push(g&127|128),g>>>=7;f.push(g)}function rs(f){var g={},y=g.N===void 0?!1:g.N;this.o={v:g.v===void 0?!1:g.v},this.N=y,g=this.o,xi.length?(y=xi.pop(),g&&(y.v=g.v),f&&ki(y,f),f=y):f=new ts(f,g),this.g=f,this.m=this.g.g,this.h=this.i=this.l=-1,this.j=!1}rs.prototype.reset=function(){this.g.reset(),this.h=this.l=-1};function jn(f){var g=f.g;if((g=g.g==g.i)||(g=f.j)||(g=f.g,g=g.l||0>g.g||g.g>g.i),g)return!1;f.m=f.g.g,g=pr(f.g);var y=g&7;return y!=0&&y!=5&&y!=1&&y!=2&&y!=3&&y!=4?(f.j=!0,!1):(f.i=g,f.l=g>>>3,f.h=y,!0)}function Un(f){switch(f.h){case 0:if(f.h!=0)Un(f);else{for(f=f.g;f.h[f.g]&128;)f.g++;f.g++}break;case 1:f.h!=1?Un(f):(f=f.g,f.g+=8);break;case 2:if(f.h!=2)Un(f);else{var g=pr(f.g);f=f.g,f.g+=g}break;case 5:f.h!=5?Un(f):(f=f.g,f.g+=4);break;case 3:g=f.l;do{if(!jn(f)){f.j=!0;break}if(f.h==4){f.l!=g&&(f.j=!0);break}Un(f)}while(1);break;default:f.j=!0}}function _i(f,g,y){var T=f.g.i,O=pr(f.g);return O=f.g.g+O,f.g.i=O,y(g,f),f.g.g=O,f.g.i=T,g}function $i(f){var g=pr(f.g);f=f.g;var y=f.g;f.g+=g,f=f.h;var T;if(pe)(T=ie)||(T=ie=new TextDecoder("utf-8",{fatal:!1})),T=T.decode(f.subarray(y,y+g));else{g=y+g;for(var O=[],L=null,D,R,V;y<g;)D=f[y++],128>D?O.push(D):224>D?y>=g?O.push(65533):(R=f[y++],194>D||(R&192)!==128?(y--,O.push(65533)):O.push((D&31)<<6|R&63)):240>D?y>=g-1?O.push(65533):(R=f[y++],(R&192)!==128||D===224&&160>R||D===237&&160<=R||((T=f[y++])&192)!==128?(y--,O.push(65533)):O.push((D&15)<<12|(R&63)<<6|T&63)):244>=D?y>=g-2?O.push(65533):(R=f[y++],(R&192)!==128||(D<<28)+(R-144)>>30!==0||((T=f[y++])&192)!==128||((V=f[y++])&192)!==128?(y--,O.push(65533)):(D=(D&7)<<18|(R&63)<<12|(T&63)<<6|V&63,D-=65536,O.push((D>>10&1023)+55296,(D&1023)+56320))):O.push(65533),8192<=O.length&&(L=Z(L,O),O.length=0);T=Z(L,O)}return T}function oa(){this.h=[],this.i=0,this.g=new ns}function Wn(f,g){g.length!==0&&(f.h.push(g),f.i+=g.length)}function ia(f){var g=f.i+f.g.length();if(g===0)return new Uint8Array(0);g=new Uint8Array(g);for(var y=f.h,T=y.length,O=0,L=0;L<T;L++){var D=y[L];D.length!==0&&(g.set(D,O),O+=D.length)}return y=f.g,T=y.h,T!==0&&(g.set(y.g.subarray(0,T),O),y.h=0),f.h=[g],g}function _t(f,g,y){if(y!=null){en(f.g,8*g+5),f=f.g;var T=y;T=(y=0>T?1:0)?-T:T,T===0?0<1/T?tt=kt=0:(kt=0,tt=2147483648):isNaN(T)?(kt=0,tt=2147483647):34028234663852886e22<T?(kt=0,tt=(y<<31|2139095040)>>>0):11754943508222875e-54>T?(T=Math.round(T/Math.pow(2,-149)),kt=0,tt=(y<<31|T)>>>0):(g=Math.floor(Math.log(T)/Math.LN2),T*=Math.pow(2,-g),T=Math.round(8388608*T)&8388607,kt=0,tt=(y<<31|g+127<<23|T)>>>0),y=tt,f.push(y>>>0&255),f.push(y>>>8&255),f.push(y>>>16&255),f.push(y>>>24&255)}}var Sm=typeof Uint8Array=="function";function Ai(f,g,y){if(f!=null)return typeof f=="object"?Sm&&f instanceof Uint8Array?y(f):Ii(f,g,y):g(f)}function Ii(f,g,y){if(Array.isArray(f)){for(var T=Array(f.length),O=0;O<f.length;O++)T[O]=Ai(f[O],g,y);return Array.isArray(f)&&f.W&&dr(T),T}T={};for(O in f)T[O]=Ai(f[O],g,y);return T}function Nm(f){return typeof f=="number"?isFinite(f)?f:String(f):f}var Tm={W:{value:!0,configurable:!0}};function dr(f){return Array.isArray(f)&&!Object.isFrozen(f)&&Object.defineProperties(f,Tm),f}var Oi;function lt(f,g,y){var T=Oi;Oi=null,f||(f=T),T=this.constructor.ca,f||(f=T?[T]:[]),this.j=T?0:-1,this.i=null,this.g=f;e:{if(T=this.g.length,f=T-1,T&&(T=this.g[f],T!==null&&typeof T=="object"&&T.constructor===Object)){this.l=f-this.j,this.h=T;break e}g!==void 0&&-1<g?(this.l=Math.max(g,f+1-this.j),this.h=null):this.l=Number.MAX_VALUE}if(y)for(g=0;g<y.length;g++)f=y[g],f<this.l?(f+=this.j,(T=this.g[f])?dr(T):this.g[f]=ss):(Di(this),(T=this.h[f])?dr(T):this.h[f]=ss)}var ss=Object.freeze(dr([]));function Di(f){var g=f.l+f.j;f.g[g]||(f.h=f.g[g]={})}function Pe(f,g,y){return g===-1?null:(y===void 0?0:y)||g>=f.l?f.h?f.h[g]:void 0:f.g[g+f.j]}function Fi(f){var g=g===void 0?!1:g,y=Pe(f,1,g);return y==null&&(y=ss),y===ss&&(y=dr([]),ve(f,1,y,g)),y}function Ct(f,g,y){return f=Pe(f,g),f=f==null?f:+f,f??(y===void 0?0:y)}function ve(f,g,y,T){(T===void 0?0:T)||g>=f.l?(Di(f),f.h[g]=y):f.g[g+f.j]=y}function ua(f,g){f.i||(f.i={});var y=f.i[1];if(!y){var T=Fi(f);y=[];for(var O=0;O<T.length;O++)y[O]=new g(T[O]);f.i[1]=y}return y}function Ci(f,g,y,T){var O=ua(f,y);g=g||new y,f=Fi(f),T!=null?(O.splice(T,0,g),f.splice(T,0,qn(g))):(O.push(g),f.push(qn(g)))}lt.prototype.toJSON=function(){var f=qn(this);return Ii(f,Nm,Jt)};function qn(f,g){if(f.i)for(var y in f.i){var T=f.i[y];if(Array.isArray(T))for(var O=0;O<T.length;O++)T[O]&&qn(T[O]);else T&&qn(T)}return f.g}lt.prototype.toString=function(){return qn(this).toString()};function Pi(f,g){return f=Pe(f,g),f??0}function Ri(f,g){return f=Pe(f,g),f??""}function la(f,g){if(f=f.m){Wn(g,g.g.end());for(var y=0;y<f.length;y++)Wn(g,f[y])}}function mr(f,g){if(g.h==4)return!1;var y=g.m;return Un(g),g.N||(g=Qt(g.g.h,y,g.g.g),(y=f.m)?y.push(g):f.m=[g]),!0}function He(f,g){var y=void 0;return new(y||(y=Promise))(function(T,O){function L(V){try{R(g.next(V))}catch(q){O(q)}}function D(V){try{R(g.throw(V))}catch(q){O(q)}}function R(V){V.done?T(V.value):new y(function(q){q(V.value)}).then(L,D)}R((g=g.apply(f,void 0)).next())})}function gr(f){lt.call(this,f)}v(gr,lt);function Em(f,g){for(;jn(g);)switch(g.i){case 8:var y=pr(g.g);ve(f,1,y);break;case 21:y=xt(g.g),ve(f,2,y);break;case 26:y=$i(g),ve(f,3,y);break;case 34:y=$i(g),ve(f,4,y);break;default:if(!mr(f,g))return f}return f}function ca(f){lt.call(this,f,-1,km)}v(ca,lt),ca.prototype.addClassification=function(f,g){Ci(this,f,gr,g)};var km=[1];function yr(f){lt.call(this,f)}v(yr,lt);function xm(f,g){for(;jn(g);)switch(g.i){case 13:var y=xt(g.g);ve(f,1,y);break;case 21:y=xt(g.g),ve(f,2,y);break;case 29:y=xt(g.g),ve(f,3,y);break;case 37:y=xt(g.g),ve(f,4,y);break;case 45:y=xt(g.g),ve(f,5,y);break;default:if(!mr(f,g))return f}return f}function Bi(f){lt.call(this,f,-1,_m)}v(Bi,lt);var _m=[1];function ha(f){lt.call(this,f)}v(ha,lt);function Li(f,g,y){if(y=f.createShader(y===0?f.VERTEX_SHADER:f.FRAGMENT_SHADER),f.shaderSource(y,g),f.compileShader(y),!f.getShaderParameter(y,f.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+f.getShaderInfoLog(y));return y}function $m(f){return ua(f,gr).map(function(g){return{index:Pi(g,1),Y:Ct(g,2),label:Pe(g,3)!=null?Ri(g,3):void 0,displayName:Pe(g,4)!=null?Ri(g,4):void 0}})}function Am(f){return{x:Ct(f,1),y:Ct(f,2),z:Ct(f,3),visibility:Pe(f,4)!=null?Ct(f,4):void 0}}function fa(f,g){this.h=f,this.g=g,this.l=0}function Mi(f,g,y){return Im(f,g),typeof f.g.canvas.transferToImageBitmap=="function"?Promise.resolve(f.g.canvas.transferToImageBitmap()):y?Promise.resolve(f.g.canvas):typeof createImageBitmap=="function"?createImageBitmap(f.g.canvas):(f.i===void 0&&(f.i=document.createElement("canvas")),new Promise(function(T){f.i.height=f.g.canvas.height,f.i.width=f.g.canvas.width,f.i.getContext("2d",{}).drawImage(f.g.canvas,0,0,f.g.canvas.width,f.g.canvas.height),T(f.i)}))}function Im(f,g){var y=f.g;if(f.m===void 0){var T=Li(y,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),O=Li(y,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),L=y.createProgram();if(y.attachShader(L,T),y.attachShader(L,O),y.linkProgram(L),!y.getProgramParameter(L,y.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+y.getProgramInfoLog(L));T=f.m=L,y.useProgram(T),O=y.getUniformLocation(T,"sampler0"),f.j={I:y.getAttribLocation(T,"aVertex"),H:y.getAttribLocation(T,"aTex"),da:O},f.s=y.createBuffer(),y.bindBuffer(y.ARRAY_BUFFER,f.s),y.enableVertexAttribArray(f.j.I),y.vertexAttribPointer(f.j.I,2,y.FLOAT,!1,0,0),y.bufferData(y.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),y.STATIC_DRAW),y.bindBuffer(y.ARRAY_BUFFER,null),f.o=y.createBuffer(),y.bindBuffer(y.ARRAY_BUFFER,f.o),y.enableVertexAttribArray(f.j.H),y.vertexAttribPointer(f.j.H,2,y.FLOAT,!1,0,0),y.bufferData(y.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),y.STATIC_DRAW),y.bindBuffer(y.ARRAY_BUFFER,null),y.uniform1i(O,0)}T=f.j,y.useProgram(f.m),y.canvas.width=g.width,y.canvas.height=g.height,y.viewport(0,0,g.width,g.height),y.activeTexture(y.TEXTURE0),f.h.bindTexture2d(g.glName),y.enableVertexAttribArray(T.I),y.bindBuffer(y.ARRAY_BUFFER,f.s),y.vertexAttribPointer(T.I,2,y.FLOAT,!1,0,0),y.enableVertexAttribArray(T.H),y.bindBuffer(y.ARRAY_BUFFER,f.o),y.vertexAttribPointer(T.H,2,y.FLOAT,!1,0,0),y.bindFramebuffer(y.DRAW_FRAMEBUFFER?y.DRAW_FRAMEBUFFER:y.FRAMEBUFFER,null),y.clearColor(0,0,0,0),y.clear(y.COLOR_BUFFER_BIT),y.colorMask(!0,!0,!0,!0),y.drawArrays(y.TRIANGLE_FAN,0,4),y.disableVertexAttribArray(T.I),y.disableVertexAttribArray(T.H),y.bindBuffer(y.ARRAY_BUFFER,null),f.h.bindTexture2d(0)}function Om(f){this.g=f}var Dm=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function Fm(f,g){return g+f}function zi(f,g){window[f]=g}function Cm(f){var g=document.createElement("script");return g.setAttribute("src",f),g.setAttribute("crossorigin","anonymous"),new Promise(function(y){g.addEventListener("load",function(){y()},!1),g.addEventListener("error",function(){y()},!1),document.body.appendChild(g)})}function Pm(){return He(this,function f(){return C(f,function(g){switch(g.g){case 1:return g.m=2,x(g,WebAssembly.instantiate(Dm),4);case 4:g.g=3,g.m=0;break;case 2:return g.m=0,g.j=null,g.return(!1);case 3:return g.return(!0)}})})}function pa(f){if(this.g=f,this.listeners={},this.j={},this.F={},this.m={},this.s={},this.G=this.o=this.R=!0,this.C=Promise.resolve(),this.P="",this.B={},this.locateFile=f&&f.locateFile||Fm,typeof window=="object")var g=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")g=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.S=g,f.options){g=i(Object.keys(f.options));for(var y=g.next();!y.done;y=g.next()){y=y.value;var T=f.options[y].default;T!==void 0&&(this.j[y]=typeof T=="function"?T():T)}}}t=pa.prototype,t.close=function(){return this.i&&this.i.delete(),Promise.resolve()};function Rm(f,g){return f.g.files===void 0?[]:typeof f.g.files=="function"?f.g.files(g):f.g.files}function Bm(f){return He(f,function g(){var y=this,T,O,L,D,R,V,q,Q,Se,le,te;return C(g,function(H){switch(H.g){case 1:return T=y,y.R?(O=Rm(y,y.j),x(H,Pm(),2)):H.return();case 2:if(L=H.h,typeof window=="object")return zi("createMediapipeSolutionsWasm",{locateFile:y.locateFile}),zi("createMediapipeSolutionsPackedAssets",{locateFile:y.locateFile}),V=O.filter(function(ee){return ee.data!==void 0}),q=O.filter(function(ee){return ee.data===void 0}),Q=Promise.all(V.map(function(ee){var ue=as(T,ee.url);if(ee.path!==void 0){var fe=ee.path;ue=ue.then(function(ze){return T.overrideFile(fe,ze),Promise.resolve(ze)})}return ue})),Se=Promise.all(q.map(function(ee){return ee.simd===void 0||ee.simd&&L||!ee.simd&&!L?Cm(T.locateFile(ee.url,T.S)):Promise.resolve()})).then(function(){return He(T,function ee(){var ue,fe,ze=this;return C(ee,function(Ee){if(Ee.g==1)return ue=window.createMediapipeSolutionsWasm,fe=window.createMediapipeSolutionsPackedAssets,x(Ee,ue(fe),2);ze.h=Ee.h,Ee.g=0})})}),le=function(){return He(T,function ee(){var ue=this;return C(ee,function(fe){return ue.g.graph&&ue.g.graph.url?fe=x(fe,as(ue,ue.g.graph.url),0):(fe.g=0,fe=void 0),fe})})}(),x(H,Promise.all([Se,Q,le]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return D=O.filter(function(ee){return ee.simd===void 0||ee.simd&&L||!ee.simd&&!L}).map(function(ee){return T.locateFile(ee.url,T.S)}),importScripts.apply(null,u(D)),x(H,createMediapipeSolutionsWasm(Module),6);case 6:y.h=H.h,y.l=new OffscreenCanvas(1,1),y.h.canvas=y.l,R=y.h.GL.createContext(y.l,{antialias:!1,alpha:!1,ba:typeof WebGL2RenderingContext<"u"?2:1}),y.h.GL.makeContextCurrent(R),H.g=4;break;case 7:if(y.l=document.createElement("canvas"),te=y.l.getContext("webgl2",{}),!te&&(te=y.l.getContext("webgl",{}),!te))return alert("Failed to create WebGL canvas context when passing video frame."),H.return();y.D=te,y.h.canvas=y.l,y.h.createContext(y.l,!0,!0,{});case 4:y.i=new y.h.SolutionWasm,y.R=!1,H.g=0}})})}function Lm(f){return He(f,function g(){var y=this,T,O,L,D,R,V,q,Q;return C(g,function(Se){if(Se.g==1){if(y.g.graph&&y.g.graph.url&&y.P===y.g.graph.url)return Se.return();if(y.o=!0,!y.g.graph||!y.g.graph.url){Se.g=2;return}return y.P=y.g.graph.url,x(Se,as(y,y.g.graph.url),3)}for(Se.g!=2&&(T=Se.h,y.i.loadGraph(T)),O=i(Object.keys(y.B)),L=O.next();!L.done;L=O.next())D=L.value,y.i.overrideFile(D,y.B[D]);if(y.B={},y.g.listeners)for(R=i(y.g.listeners),V=R.next();!V.done;V=R.next())q=V.value,jm(y,q);Q=y.j,y.j={},y.setOptions(Q),Se.g=0})})}t.reset=function(){return He(this,function f(){var g=this;return C(f,function(y){g.i&&(g.i.reset(),g.m={},g.s={}),y.g=0})})},t.setOptions=function(f,g){var y=this;if(g=g||this.g.options){for(var T=[],O=[],L={},D=i(Object.keys(f)),R=D.next();!R.done;L={K:L.K,L:L.L},R=D.next()){var V=R.value;V in this.j&&this.j[V]===f[V]||(this.j[V]=f[V],R=g[V],R!==void 0&&(R.onChange&&(L.K=R.onChange,L.L=f[V],T.push(function(q){return function(){return He(y,function Q(){var Se,le=this;return C(Q,function(te){if(te.g==1)return x(te,q.K(q.L),2);Se=te.h,Se===!0&&(le.o=!0),te.g=0})})}}(L))),R.graphOptionXref&&(V={valueNumber:R.type===1?f[V]:0,valueBoolean:R.type===0?f[V]:!1,valueString:R.type===2?f[V]:""},R=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),R.graphOptionXref),V),O.push(R))))}(T.length!==0||O.length!==0)&&(this.o=!0,this.A=(this.A===void 0?[]:this.A).concat(O),this.u=(this.u===void 0?[]:this.u).concat(T))}};function Mm(f){return He(f,function g(){var y=this,T,O,L,D,R,V,q;return C(g,function(Q){switch(Q.g){case 1:if(!y.o)return Q.return();if(!y.u){Q.g=2;break}T=i(y.u),O=T.next();case 3:if(O.done){Q.g=5;break}return L=O.value,x(Q,L(),4);case 4:O=T.next(),Q.g=3;break;case 5:y.u=void 0;case 2:if(y.A){for(D=new y.h.GraphOptionChangeRequestList,R=i(y.A),V=R.next();!V.done;V=R.next())q=V.value,D.push_back(q);y.i.changeOptions(D),D.delete(),y.A=void 0}y.o=!1,Q.g=0}})})}t.initialize=function(){return He(this,function f(){var g=this;return C(f,function(y){return y.g==1?x(y,Bm(g),2):y.g!=3?x(y,Lm(g),3):x(y,Mm(g),0)})})};function as(f,g){return He(f,function y(){var T=this,O,L;return C(y,function(D){return g in T.F?D.return(T.F[g]):(O=T.locateFile(g,""),L=fetch(O).then(function(R){return R.arrayBuffer()}),T.F[g]=L,D.return(L))})})}t.overrideFile=function(f,g){this.i?this.i.overrideFile(f,g):this.B[f]=g},t.clearOverriddenFiles=function(){this.B={},this.i&&this.i.clearOverriddenFiles()},t.send=function(f,g){return He(this,function y(){var T=this,O,L,D,R,V,q,Q,Se,le;return C(y,function(te){switch(te.g){case 1:return T.g.inputs?(O=1e3*(g??performance.now()),x(te,T.C,2)):te.return();case 2:return x(te,T.initialize(),3);case 3:for(L=new T.h.PacketDataList,D=i(Object.keys(f)),R=D.next();!R.done;R=D.next())if(V=R.value,q=T.g.inputs[V]){e:{var H=T,ee=f[V];switch(q.type){case"video":var ue=H.m[q.stream];if(ue||(ue=new fa(H.h,H.D),H.m[q.stream]=ue),H=ue,H.l===0&&(H.l=H.h.createTexture()),typeof HTMLVideoElement<"u"&&ee instanceof HTMLVideoElement){var fe=ee.videoWidth;ue=ee.videoHeight}else typeof HTMLImageElement<"u"&&ee instanceof HTMLImageElement?(fe=ee.naturalWidth,ue=ee.naturalHeight):(fe=ee.width,ue=ee.height);ue={glName:H.l,width:fe,height:ue},fe=H.g,fe.canvas.width=ue.width,fe.canvas.height=ue.height,fe.activeTexture(fe.TEXTURE0),H.h.bindTexture2d(H.l),fe.texImage2D(fe.TEXTURE_2D,0,fe.RGBA,fe.RGBA,fe.UNSIGNED_BYTE,ee),H.h.bindTexture2d(0),H=ue;break e;case"detections":for(ue=H.m[q.stream],ue||(ue=new Om(H.h),H.m[q.stream]=ue),H=ue,H.data||(H.data=new H.g.DetectionListData),H.data.reset(ee.length),ue=0;ue<ee.length;++ue){fe=ee[ue];var ze=H.data,Ee=ze.setBoundingBox,Qe=ue,Re=fe.T,oe=new ha;ve(oe,1,Re.Z),ve(oe,2,Re.$),ve(oe,3,Re.height),ve(oe,4,Re.width),ve(oe,5,Re.rotation),ve(oe,6,Re.X);var de=Re=new oa;_t(de,1,Pe(oe,1)),_t(de,2,Pe(oe,2)),_t(de,3,Pe(oe,3)),_t(de,4,Pe(oe,4)),_t(de,5,Pe(oe,5));var ge=Pe(oe,6);if(ge!=null&&ge!=null){en(de.g,48);var ae=de.g,me=ge;ge=0>me,me=Math.abs(me);var J=me>>>0;for(me=Math.floor((me-J)/4294967296),me>>>=0,ge&&(me=~me>>>0,J=(~J>>>0)+1,4294967295<J&&(J=0,me++,4294967295<me&&(me=0))),tt=J,kt=me,ge=tt,J=kt;0<J||127<ge;)ae.push(ge&127|128),ge=(ge>>>7|J<<25)>>>0,J>>>=7;ae.push(ge)}if(la(oe,de),Re=ia(Re),Ee.call(ze,Qe,Re),fe.O)for(ze=0;ze<fe.O.length;++ze)oe=fe.O[ze],de=!!oe.visibility,Ee=H.data,Qe=Ee.addNormalizedLandmark,Re=ue,oe=Object.assign(Object.assign({},oe),{visibility:de?oe.visibility:0}),de=new yr,ve(de,1,oe.x),ve(de,2,oe.y),ve(de,3,oe.z),oe.visibility&&ve(de,4,oe.visibility),ae=oe=new oa,_t(ae,1,Pe(de,1)),_t(ae,2,Pe(de,2)),_t(ae,3,Pe(de,3)),_t(ae,4,Pe(de,4)),_t(ae,5,Pe(de,5)),la(de,ae),oe=ia(oe),Qe.call(Ee,Re,oe);if(fe.M)for(ze=0;ze<fe.M.length;++ze){if(Ee=H.data,Qe=Ee.addClassification,Re=ue,oe=fe.M[ze],de=new gr,ve(de,2,oe.Y),oe.index&&ve(de,1,oe.index),oe.label&&ve(de,3,oe.label),oe.displayName&&ve(de,4,oe.displayName),ae=oe=new oa,J=Pe(de,1),J!=null&&J!=null)if(en(ae.g,8),ge=ae.g,0<=J)en(ge,J);else{for(me=0;9>me;me++)ge.push(J&127|128),J>>=7;ge.push(1)}_t(ae,2,Pe(de,2)),ge=Pe(de,3),ge!=null&&(ge=je(ge),en(ae.g,26),en(ae.g,ge.length),Wn(ae,ae.g.end()),Wn(ae,ge)),ge=Pe(de,4),ge!=null&&(ge=je(ge),en(ae.g,34),en(ae.g,ge.length),Wn(ae,ae.g.end()),Wn(ae,ge)),la(de,ae),oe=ia(oe),Qe.call(Ee,Re,oe)}}H=H.data;break e;default:H={}}}switch(Q=H,Se=q.stream,q.type){case"video":L.pushTexture2d(Object.assign(Object.assign({},Q),{stream:Se,timestamp:O}));break;case"detections":le=Q,le.stream=Se,le.timestamp=O,L.pushDetectionList(le);break;default:throw Error("Unknown input config type: '"+q.type+"'")}}return T.i.send(L),x(te,T.C,4);case 4:L.delete(),te.g=0}})})};function zm(f,g,y){return He(f,function T(){var O,L,D,R,V,q,Q=this,Se,le,te,H,ee,ue,fe,ze;return C(T,function(Ee){switch(Ee.g){case 1:if(!y)return Ee.return(g);for(O={},L=0,D=i(Object.keys(y)),R=D.next();!R.done;R=D.next())V=R.value,q=y[V],typeof q!="string"&&q.type==="texture"&&g[q.stream]!==void 0&&++L;1<L&&(Q.G=!1),Se=i(Object.keys(y)),R=Se.next();case 2:if(R.done){Ee.g=4;break}if(le=R.value,te=y[le],typeof te=="string")return fe=O,ze=le,x(Ee,Vm(Q,le,g[te]),14);if(H=g[te.stream],te.type==="detection_list"){if(H){for(var Qe=H.getRectList(),Re=H.getLandmarksList(),oe=H.getClassificationsList(),de=[],ge=0;ge<Qe.size();++ge){var ae=Qe.get(ge);e:{var me=new ha;for(ae=new rs(ae);jn(ae);)switch(ae.i){case 13:var J=xt(ae.g);ve(me,1,J);break;case 21:J=xt(ae.g),ve(me,2,J);break;case 29:J=xt(ae.g),ve(me,3,J);break;case 37:J=xt(ae.g),ve(me,4,J);break;case 45:J=xt(ae.g),ve(me,5,J);break;case 48:for(var De=ae.g,Le=128,da=0,bn=J=0;4>bn&&128<=Le;bn++)Le=De.h[De.g++],da|=(Le&127)<<7*bn;if(128<=Le&&(Le=De.h[De.g++],da|=(Le&127)<<28,J|=(Le&127)>>4),128<=Le)for(bn=0;5>bn&&128<=Le;bn++)Le=De.h[De.g++],J|=(Le&127)<<7*bn+3;128>Le?(De=da>>>0,Le=J>>>0,(J=Le&2147483648)&&(De=~De+1>>>0,Le=~Le>>>0,De==0&&(Le=Le+1>>>0)),De=4294967296*Le+(De>>>0),J=J?-De:De):(De.l=!0,J=void 0),ve(me,6,J);break;default:if(!mr(me,ae))break e}}me={Z:Ct(me,1),$:Ct(me,2),height:Ct(me,3),width:Ct(me,4),rotation:Ct(me,5,0),X:Pi(me,6)},J=Re.get(ge);e:for(ae=new Bi,J=new rs(J);jn(J);)switch(J.i){case 10:De=_i(J,new yr,xm),Ci(ae,De,yr,void 0);break;default:if(!mr(ae,J))break e}ae=ua(ae,yr).map(Am),De=oe.get(ge);e:for(J=new ca,De=new rs(De);jn(De);)switch(De.i){case 10:J.addClassification(_i(De,new gr,Em));break;default:if(!mr(J,De))break e}me={T:me,O:ae,M:$m(J)},de.push(me)}Qe=de}else Qe=[];O[le]=Qe,Ee.g=7;break}if(te.type==="proto_list"){if(H){for(Qe=Array(H.size()),Re=0;Re<H.size();Re++)Qe[Re]=H.get(Re);H.delete()}else Qe=[];O[le]=Qe,Ee.g=7;break}if(H===void 0){Ee.g=3;break}if(te.type==="float_list"){O[le]=H,Ee.g=7;break}if(te.type==="proto"){O[le]=H,Ee.g=7;break}if(te.type!=="texture")throw Error("Unknown output config type: '"+te.type+"'");return ee=Q.s[le],ee||(ee=new fa(Q.h,Q.D),Q.s[le]=ee),x(Ee,Mi(ee,H,Q.G),13);case 13:ue=Ee.h,O[le]=ue;case 7:te.transform&&O[le]&&(O[le]=te.transform(O[le])),Ee.g=3;break;case 14:fe[ze]=Ee.h;case 3:R=Se.next(),Ee.g=2;break;case 4:return Ee.return(O)}})})}function Vm(f,g,y){return He(f,function T(){var O=this,L;return C(T,function(D){return typeof y=="number"||y instanceof Uint8Array||y instanceof O.h.Uint8BlobList?D.return(y):y instanceof O.h.Texture2dDataOut?(L=O.s[g],L||(L=new fa(O.h,O.D),O.s[g]=L),D.return(Mi(L,y,O.G))):D.return(void 0)})})}function jm(f,g){for(var y=g.name||"$",T=[].concat(u(g.wants)),O=new f.h.StringList,L=i(g.wants),D=L.next();!D.done;D=L.next())O.push_back(D.value);L=f.h.PacketListener.implement({onResults:function(R){for(var V={},q=0;q<g.wants.length;++q)V[T[q]]=R.get(q);var Q=f.listeners[y];Q&&(f.C=zm(f,V,g.outs).then(function(Se){Se=Q(Se);for(var le=0;le<g.wants.length;++le){var te=V[T[le]];typeof te=="object"&&te.hasOwnProperty&&te.hasOwnProperty("delete")&&te.delete()}Se&&(f.C=Se)}))}}),f.i.attachMultiListener(O,L),O.delete()}t.onResults=function(f,g){this.listeners[g||"$"]=f},K("Solution",pa),K("OptionType",{BOOL:0,NUMBER:1,aa:2,0:"BOOL",1:"NUMBER",2:"STRING"});function Vi(f){switch(f===void 0&&(f=0),f){case 1:return"selfie_segmentation_landscape.tflite";default:return"selfie_segmentation.tflite"}}function ji(f){var g=this;f=f||{},this.g=new pa({locateFile:f.locateFile,files:function(y){return[{simd:!0,url:"selfie_segmentation_solution_simd_wasm_bin.js"},{simd:!1,url:"selfie_segmentation_solution_wasm_bin.js"},{data:!0,url:Vi(y.modelSelection)}]},graph:{url:"selfie_segmentation.binarypb"},listeners:[{wants:["segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelSelection:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelSelection",fieldName:"int_value"},onChange:function(y){return He(g,function T(){var O,L,D=this,R;return C(T,function(V){return V.g==1?(O=Vi(y),L="third_party/mediapipe/modules/selfie_segmentation/"+O,x(V,as(D.g,O),2)):(R=V.h,D.g.overrideFile(L,R),V.return(!0))})})}}}})}t=ji.prototype,t.close=function(){return this.g.close(),Promise.resolve()},t.onResults=function(f){this.g.onResults(f)},t.initialize=function(){return He(this,function f(){var g=this;return C(f,function(y){return x(y,g.g.initialize(),0)})})},t.reset=function(){this.g.reset()},t.send=function(f){return He(this,function g(){var y=this;return C(g,function(T){return x(T,y.g.send(f),0)})})},t.setOptions=function(f){this.g.setOptions(f)},K("SelfieSegmentation",ji),K("VERSION","0.1.1632777926")}).call(Bt);var SE=SelfieSegmentation;VERSION;var io=function(t,e){return io=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,r){n.__proto__=r}||function(n,r){for(var s in r)r.hasOwnProperty(s)&&(n[s]=r[s])},io(t,e)};function Yd(t,e){function n(){this.constructor=t}io(t,e),t.prototype=e===null?Object.create(e):(n.prototype=e.prototype,new n)}var Ge=function(){return Ge=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var s in e=arguments[n])Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s]);return t},Ge.apply(this,arguments)};function ce(t,e,n,r){return new(n||(n=Promise))(function(s,a){function o(l){try{u(r.next(l))}catch(c){a(c)}}function i(l){try{u(r.throw(l))}catch(c){a(c)}}function u(l){var c;l.done?s(l.value):(c=l.value,c instanceof n?c:new n(function(h){h(c)})).then(o,i)}u((r=r.apply(t,e||[])).next())})}function he(t,e){var n,r,s,a,o={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return a={next:i(0),throw:i(1),return:i(2)},typeof Symbol=="function"&&(a[Symbol.iterator]=function(){return this}),a;function i(u){return function(l){return function(c){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(s=2&c[0]?r.return:c[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,c[1])).done)return s;switch(r=0,s&&(c=[2&c[0],s.value]),c[0]){case 0:case 1:s=c;break;case 4:return o.label++,{value:c[1],done:!1};case 5:o.label++,r=c[1],c=[0];continue;case 7:c=o.ops.pop(),o.trys.pop();continue;default:if(s=o.trys,!((s=s.length>0&&s[s.length-1])||c[0]!==6&&c[0]!==2)){o=0;continue}if(c[0]===3&&(!s||c[1]>s[0]&&c[1]<s[3])){o.label=c[1];break}if(c[0]===6&&o.label<s[1]){o.label=s[1],s=c;break}if(s&&o.label<s[2]){o.label=s[2],o.ops.push(c);break}s[2]&&o.ops.pop(),o.trys.pop();continue}c=e.call(t,o)}catch(h){c=[6,h],r=0}finally{n=s=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}([u,l])}}}function Fs(t){return t instanceof SVGAnimatedLength?t.baseVal.value:t}function Ti(t){return ce(this,void 0,void 0,function(){var e,n;return he(this,function(r){switch(r.label){case 0:return e=document.createElement("canvas"),t instanceof be?[4,Wr(t,e)]:[3,2];case 1:return r.sent(),[3,3];case 2:e.width=Fs(t.width),e.height=Fs(t.height),n=e.getContext("2d"),t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0),r.label=3;case 3:return[2,e]}})})}function Zd(t){return ce(this,void 0,void 0,function(){var e,n,r,s,a,o;return he(this,function(i){switch(i.label){case 0:return t instanceof be?(e=t.shape.slice(0,2),n=e[0],r=e[1],s=ImageData.bind,[4,Wr(t)]):[3,2];case 1:return[2,new(s.apply(ImageData,[void 0,i.sent(),r,n]))];case 2:return a=document.createElement("canvas"),o=a.getContext("2d"),a.width=Fs(t.width),a.height=Fs(t.height),o.drawImage(t,0,0),[2,o.getImageData(0,0,a.width,a.height)]}})})}function Jd(t){return ce(this,void 0,void 0,function(){var e,n;return he(this,function(r){switch(r.label){case 0:return t instanceof SVGImageElement||t instanceof OffscreenCanvas?[4,Ti(t)]:[3,2];case 1:return n=r.sent(),[3,3];case 2:n=t,r.label=3;case 3:return e=n,[2,Ms(e,4)]}})})}function ra(t){if(t<0||t>=256)throw new Error("Mask value must be in range [0, 255] but got "+t);if(!Number.isInteger(t))throw new Error("Mask value must be an integer but got "+t)}function Qd(t){var e=t.shape[2],n=Bo(t,2),r=B(n,[-1]);return Dr(r,e)}function us(t,e){return Y(function(){return we(hr(t,se(e)),"int32")})}function NE(t,e){var n=e.shape,r=n[0],s=n[1],a=n[2];return Y(function(){var o=Qd(e),i=st(fn(0,a,1,"int32"),1),u=we(ye(o,i),"int32"),l=B(u,[r,s]),c=X(l,se(1,"int32"));return ne(function(h,p){return U(h,p)}(c,t),se(1,"int32"))})}var em=function(){function t(e,n){this.model=e,this.outputStride=n;var r=this.model.inputs[0].shape;S(r[1]===-1&&r[2]===-1,function(){return"Input shape ["+r[1]+", "+r[2]+"] must both be equal to or -1"})}return t.prototype.predict=function(e){var n=this;return Y(function(){var r=n.preprocessInput(we(e,"float32")),s=st(r,0),a=n.model.predict(s).map(function(i){return mt(i,[0])}),o=n.nameOutputResults(a);return{heatmapScores:Mt(o.heatmap),offsets:o.offsets,displacementFwd:o.displacementFwd,displacementBwd:o.displacementBwd,segmentation:o.segmentation,partHeatmaps:o.partHeatmaps,longOffsets:o.longOffsets,partOffsets:o.partOffsets}})},t.prototype.dispose=function(){this.model.dispose()},t}(),TE=function(t){function e(){return t!==null&&t.apply(this,arguments)||this}return Yd(e,t),e.prototype.preprocessInput=function(n){return Y(function(){return ne(ke(n,127.5),1)})},e.prototype.nameOutputResults=function(n){return{offsets:n[0],segmentation:n[1],partHeatmaps:n[2],longOffsets:n[3],heatmap:n[4],displacementFwd:n[5],displacementBwd:n[6],partOffsets:n[7]}},e}(em),sa=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],At=sa.length,Cs=sa.reduce(function(t,e,n){return t[e]=n,t},{});[["leftHip","leftShoulder"],["leftElbow","leftShoulder"],["leftElbow","leftWrist"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["rightHip","rightShoulder"],["rightElbow","rightShoulder"],["rightElbow","rightWrist"],["rightHip","rightKnee"],["rightKnee","rightAnkle"],["leftShoulder","rightShoulder"],["leftHip","rightHip"]].map(function(t){var e=t[0],n=t[1];return[Cs[e],Cs[n]]});function Ei(t,e,n){var r=t[0],s=t[1],a=e[0],o=e[1],i=n.top,u=n.bottom;return[o/(n.left+n.right+s),a/(i+u+r)]}function tm(t,e,n,r){return{y:r.get(t,e,n),x:r.get(t,e,n+At)}}function nm(t,e,n){var r=tm(t.heatmapY,t.heatmapX,t.id,n),s=r.y,a=r.x;return{x:t.heatmapX*e+a,y:t.heatmapY*e+s}}function gu(t,e,n){return t<e?e:t>n?n:t}function yu(t,e){return{x:t.x+e.x,y:t.y+e.y}}function EE(t,e,n){n===void 0&&(n=.3);for(var r=0,s=0,a=0;a<t.length;a++)e.keypoints[a].score>n&&(s+=1,r+=Math.pow(t[a].x-e.keypoints[a].position.x,2)+Math.pow(t[a].y-e.keypoints[a].position.y,2));return s===0?r=1/0:r/=s,r}function kE(t,e,n,r,s,a,o){for(var i=o[0],u=o[1],l=n(t),c=l.y*r+l.x,h=s[At*(2*c)+e],p=s[At*(2*c+1)+e],d=t.y+h,b=t.x+p,v=0;v<a;v++){d=Math.min(d,i-1);var N=n({x:b=Math.min(b,u-1),y:d}),_=N.y*r+N.x;d+=h=s[At*(2*_)+e],b+=p=s[At*(2*_+1)+e]}return{x:b,y:d}}function rm(t,e,n,r,s,a,o,i,u,l){for(var c=s[0],h=s[1],p=a[0],d=a[1],b=i[0],v=i[1],N=[],_=function(M){return function(C,j,z,G){var K=j[0],Z=j[1],ie=z[0],pe=z[1],Oe=Math.round(((K+C.y+1)*pe-1)/G);return{x:Math.round(((Z+C.x+1)*ie-1)/G),y:Oe}}(M,[c,h],[p,d],u)},F=0;F<r;F++){var x=kE(t,F,_,o,e,l,[b,v]);N.push(x)}for(var $=-1,A=1/0,I=0;I<n.length;I++){var P=EE(N,n[I]);P<A&&($=I,A=P)}return $}function sm(t,e){var n=t[0],r=t[1];return[Math.round((r-1)/e+1),Math.round((n-1)/e+1)]}function am(t,e,n,r,s,a,o,i,u,l,c){for(var h=o[0],p=o[1],d=t.shape,b=d[0],v=d[1],N=e.shape.slice(0,2),_=N[0],F=N[1],x=B(e,[_,F,2,At]),$=new Float32Array(c*At*3).fill(0),A=0;A<n.length;A++)for(var I=A*At*3,P=n[A],M=0;M<At;M++){var C=P.keypoints[M],j=I+3*M;$[j]=C.score,$[j+1]=C.position.y,$[j+2]=C.position.x}var z=Ei([r,s],[h,p],i),G=z[0],K=z[1],Z=yt($,[c,At,3]),ie=i.top,pe=i.left,Oe={variableNames:["segmentation","longOffsets","poses"],outputShape:[b,v],userCode:`
    int convertToPositionInOutput(int pos, int pad, float scale, int stride) {
      return round(((float(pos + pad) + 1.0) * scale - 1.0) / float(stride));
    }

    float convertToPositionInOutputFloat(
        int pos, int pad, float scale, int stride) {
      return ((float(pos + pad) + 1.0) * scale - 1.0) / float(stride);
    }

    float dist(float x1, float y1, float x2, float y2) {
      return pow(x1 - x2, 2.0) + pow(y1 - y2, 2.0);
    }

    float sampleLongOffsets(float h, float w, int d, int k) {
      float fh = fract(h);
      float fw = fract(w);
      int clH = int(ceil(h));
      int clW = int(ceil(w));
      int flH = int(floor(h));
      int flW = int(floor(w));
      float o11 = getLongOffsets(flH, flW, d, k);
      float o12 = getLongOffsets(flH, clW, d, k);
      float o21 = getLongOffsets(clH, flW, d, k);
      float o22 = getLongOffsets(clH, clW, d, k);
      float o1 = mix(o11, o12, fw);
      float o2 = mix(o21, o22, fw);
      return mix(o1, o2, fh);
    }

    int findNearestPose(int h, int w) {
      float prob = getSegmentation(h, w);
      if (prob < 1.0) {
        return -1;
      }

      // Done(Tyler): convert from output space h/w to strided space.
      float stridedH = convertToPositionInOutputFloat(
        h, `+ie+", "+K+", "+a+`);
      float stridedW = convertToPositionInOutputFloat(
        w, `+pe+", "+G+", "+a+`);

      float minDist = 1000000.0;
      int iMin = -1;
      for (int i = 0; i < `+c+`; i++) {
        float curDistSum = 0.0;
        int numKpt = 0;
        for (int k = 0; k < `+At+`; k++) {
          float dy = sampleLongOffsets(stridedH, stridedW, 0, k);
          float dx = sampleLongOffsets(stridedH, stridedW, 1, k);

          float y = float(h) + dy;
          float x = float(w) + dx;

          for (int s = 0; s < `+u+`; s++) {
            int yRounded = round(min(y, float(`+(r-1)+`)));
            int xRounded = round(min(x, float(`+(s-1)+`)));

            float yStrided = convertToPositionInOutputFloat(
              yRounded, `+ie+", "+K+", "+a+`);
            float xStrided = convertToPositionInOutputFloat(
              xRounded, `+pe+", "+G+", "+a+`);

            float dy = sampleLongOffsets(yStrided, xStrided, 0, k);
            float dx = sampleLongOffsets(yStrided, xStrided, 1, k);

            y = y + dy;
            x = x + dx;
          }

          float poseScore = getPoses(i, k, 0);
          float poseY = getPoses(i, k, 1);
          float poseX = getPoses(i, k, 2);
          if (poseScore > `+l+`) {
            numKpt = numKpt + 1;
            curDistSum = curDistSum + dist(x, y, poseX, poseY);
          }
        }
        if (numKpt > 0 && curDistSum / float(numKpt) < minDist) {
          minDist = curDistSum / float(numKpt);
          iMin = i;
        }
      }
      return iMin;
    }

    void main() {
        ivec2 coords = getOutputCoords();
        int nearestPose = findNearestPose(coords[0], coords[1]);
        setOutput(float(nearestPose));
      }
  `};return af().compileAndRun(Oe,[t,x,Z])}function om(){return sf()==="webgl"}function xE(t,e,n,r,s,a,o,i,u,l,c,h){var p=o[0],d=o[1];return u===void 0&&(u=.2),l===void 0&&(l=8),c===void 0&&(c=.3),h===void 0&&(h=10),ce(this,void 0,void 0,function(){var b,v,N,_,F;return he(this,function(x){switch(x.label){case 0:return b=n.filter(function($){return $.score>=u}),om()?(N=Y(function(){var $=am(t,e,b,r,s,a,[p,d],i,l,c,h),A=Ao().makeTensorFromDataId($.dataId,$.shape,$.dtype);return b.map(function(I,P){return function(M,C){return Y(function(){return we(Kr(M,se(C)),"int32")})}(A,P)})}),[4,Promise.all(N.map(function($){return $.data()}))]):[3,2];case 1:return v=x.sent(),N.forEach(function($){return $.dispose()}),[3,5];case 2:return[4,t.data()];case 3:return _=x.sent(),[4,e.data()];case 4:F=x.sent(),v=function($,A,I,P,M,C,j,z,G,K){var Z=j[0],ie=j[1];K===void 0&&(K=5);for(var pe=I.map(function(Ft){return new Uint8Array(P*M).fill(0)}),Oe=z.top,Ve=z.left,je=Ei([P,M],[Z,ie],z),Ot=je[0],St=je[1],Jt=sm([Z,ie],C)[0],Dt=0;Dt<P;Dt+=1)for(var Nt=0;Nt<M;Nt+=1){var Tt=Dt*M+Nt;if($[Tt]===1){var Et=rm({x:Nt,y:Dt},A,I,K,[Oe,Ve],[Ot,St],Jt,[P,M],C,G);Et>=0&&(pe[Et][Tt]=1)}}return pe}(_,F,b,r,s,a,[p,d],i,l),x.label=5;case 5:return[2,v.map(function($,A){return{data:$,pose:b[A],width:s,height:r}})]}})})}function _E(t,e,n,r,s,a,o,i,u,l,c,h,p){var d=i[0],b=i[1];return l===void 0&&(l=.2),c===void 0&&(c=8),h===void 0&&(h=.3),p===void 0&&(p=10),ce(this,void 0,void 0,function(){var v,N,_,F,x,$;return he(this,function(A){switch(A.label){case 0:return v=r.filter(function(I){return I.score>=l}),om()?(_=Y(function(){var I=am(t,e,v,s,a,o,[d,b],u,c,h,p),P=Ao().makeTensorFromDataId(I.dataId,I.shape,I.dtype);return v.map(function(M,C){return function(j,z,G){return Y(function(){return ne(U(we(Kr(j,se(G)),"int32"),X(z,1)),1)})}(P,n,C)})}),[4,Promise.all(_.map(function(I){return I.data()}))]):[3,2];case 1:return N=A.sent(),_.forEach(function(I){return I.dispose()}),[3,6];case 2:return[4,t.data()];case 3:return F=A.sent(),[4,e.data()];case 4:return x=A.sent(),[4,n.data()];case 5:$=A.sent(),N=function(I,P,M,C,j,z,G,K,Z,ie,pe){var Oe=K[0],Ve=K[1];pe===void 0&&(pe=5);for(var je=C.map(function(kt){return new Int32Array(j*z).fill(-1)}),Ot=Z.top,St=Z.left,Jt=Ei([j,z],[Oe,Ve],Z),Dt=Jt[0],Nt=Jt[1],Tt=sm([Oe,Ve],G)[0],Et=0;Et<j;Et+=1)for(var Ft=0;Ft<z;Ft+=1){var Qt=Et*z+Ft;if(I[Qt]===1){var tt=rm({x:Ft,y:Et},P,C,pe,[Ot,St],[Dt,Nt],Tt,[j,z],G,ie);tt>=0&&(je[tt][Qt]=M[Qt])}}return je}(F,x,$,v,s,a,o,[d,b],u,c),A.label=6;case 6:return[2,N.map(function(I,P){return{pose:v[P],data:I,height:s,width:a}})]}})})}function Na(t){return Math.floor(t/2)}var $E=function(){function t(e,n){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=n}return t.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},t.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},t.prototype.empty=function(){return this.numberOfElements===-1},t.prototype.size=function(){return this.numberOfElements+1},t.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},t.prototype.max=function(){return this.priorityQueue[0]},t.prototype.swim=function(e){for(;e>0&&this.less(Na(e),e);)this.exchange(e,Na(e)),e=Na(e)},t.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var n=2*e;if(n<this.numberOfElements&&this.less(n,n+1)&&n++,!this.less(e,n))break;this.exchange(e,n),e=n}},t.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},t.prototype.less=function(e,n){return this.getValueAt(e)<this.getValueAt(n)},t.prototype.exchange=function(e,n){var r=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[n],this.priorityQueue[n]=r},t}();function AE(t,e,n,r,s,a){for(var o=a.shape,i=o[0],u=o[1],l=!0,c=Math.max(n-s,0),h=Math.min(n+s+1,i),p=c;p<h;++p){for(var d=Math.max(r-s,0),b=Math.min(r+s+1,u),v=d;v<b;++v)if(a.get(p,v,t)>e){l=!1;break}if(!l)break}return l}var im=[["nose","leftEye"],["leftEye","leftEar"],["nose","rightEye"],["rightEye","rightEar"],["nose","leftShoulder"],["leftShoulder","leftElbow"],["leftElbow","leftWrist"],["leftShoulder","leftHip"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["nose","rightShoulder"],["rightShoulder","rightElbow"],["rightElbow","rightWrist"],["rightShoulder","rightHip"],["rightHip","rightKnee"],["rightKnee","rightAnkle"]].map(function(t){var e=t[0],n=t[1];return[Cs[e],Cs[n]]}),Ta=im.map(function(t){return t[1]}),bu=im.map(function(t){return t[0]});function Ea(t,e,n,r){return{y:gu(Math.round(t.y/e),0,n-1),x:gu(Math.round(t.x/e),0,r-1)}}function wu(t,e,n,r,s,a,o,i){i===void 0&&(i=2);for(var u=r.shape,l=u[0],c=u[1],h=function(F,x,$){var A=$.shape[2]/2;return{y:$.get(x.y,x.x,F),x:$.get(x.y,x.x,A+F)}}(t,Ea(e.position,a,l,c),o),p=yu(e.position,h),d=0;d<i;d++){var b=Ea(p,a,l,c),v=tm(b.y,b.x,n,s);p=yu({x:b.x*a,y:b.y*a},{x:v.x,y:v.y})}var N=Ea(p,a,l,c),_=r.get(N.y,N.x,n);return{position:p,part:sa[n],score:_}}function IE(t,e,n,r,s,a){var o=e.shape[2],i=Ta.length,u=new Array(o),l=t.part,c=t.score,h=nm(l,r,n);u[l.id]={score:c,part:sa[l.id],position:h};for(var p=i-1;p>=0;--p){var d=Ta[p],b=bu[p];u[d]&&!u[b]&&(u[b]=wu(p,u[d],b,e,n,r,a))}for(p=0;p<i;++p)d=bu[p],b=Ta[p],u[d]&&!u[b]&&(u[b]=wu(p,u[d],b,e,n,r,s));return u}function um(t,e,n,r){var s=n.x,a=n.y;return t.some(function(o){var i,u,l,c,h,p,d=o.keypoints[r].position;return i=a,u=s,l=d.y,c=d.x,(h=l-i)*h+(p=c-u)*p<=e})}function OE(t,e,n){var r=n.reduce(function(s,a,o){var i=a.position,u=a.score;return um(t,e,i,o)||(s+=u),s},0);return r/n.length}function ls(t,e,n,r,s,a,o,i){o===void 0&&(o=.5),i===void 0&&(i=20);for(var u=[],l=function(b,v,N){for(var _=N.shape,F=_[0],x=_[1],$=_[2],A=new $E(F*x*$,function(j){return j.score}),I=0;I<F;++I)for(var P=0;P<x;++P)for(var M=0;M<$;++M){var C=N.get(I,P,M);C<b||AE(M,C,I,P,v,N)&&A.enqueue({score:C,part:{heatmapY:I,heatmapX:P,id:M}})}return A}(o,1,t),c=i*i;u.length<a&&!l.empty();){var h=l.dequeue();if(!um(u,c,nm(h.part,s,e),h.part.id)){var p=IE(h,t,e,s,n,r),d=OE(u,c,p);u.push({keypoints:p,score:d})}}return u}var vr,DE=[-123.15,-115.9,-103.06],FE=function(t){function e(){return t!==null&&t.apply(this,arguments)||this}return Yd(e,t),e.prototype.preprocessInput=function(n){return X(n,DE)},e.prototype.nameOutputResults=function(n){var r=n[0],s=n[1],a=n[2],o=n[3],i=n[4],u=n[5];return{offsets:i,segmentation:n[6],partHeatmaps:u,longOffsets:o,heatmap:a,displacementFwd:s,displacementBwd:r,partOffsets:n[7]}},e}(em),vu="https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/resnet50/",Su="https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/";function Tr(t){if(typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&t instanceof OffscreenCanvas||typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)return function(e){if("offsetHeight"in e&&e.offsetHeight!==0&&"offsetWidth"in e&&e.offsetWidth!==0)return[e.offsetHeight,e.offsetWidth];if(e.height!=null&&e.width!=null)return[e.height,e.width];throw new Error("HTMLImageElement must have height and width attributes set.")}(t);if(typeof ImageData<"u"&&t instanceof ImageData)return[t.height,t.width];if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)return function(e){return e.hasAttribute("height")&&e.hasAttribute("width")?[e.height,e.width]:[e.videoHeight,e.videoWidth]}(t);if(t instanceof be)return[t.shape[0],t.shape[1]];throw new Error("error: Unknown input type: "+t+".")}function Nu(t,e){return function(n,r){return(n-1)%r==0}(t,e)?t:Math.floor(t/e)*e+1}var Er={low:"low",medium:"medium",high:"high",full:"full"},CE=((vr={})[Er.low]=.25,vr[Er.medium]=.5,vr[Er.high]=.75,vr[Er.full]=1,vr);function cs(t,e,n){var r=n[0],s=n[1],a=function(o){if(typeof o=="string"){var i=CE[o];return S(typeof i=="number",function(){return"string value of inputResolution must be one of "+Object.values(Er).join(",")+" but was "+o+"."}),i}return S(typeof o=="number"&&o<=2&&o>=.1,function(){return"inputResolution must be a string or number between 0.1 and 2, but was "+o}),o}(t);return[Nu(r*a,e),Nu(s*a,e)]}function Kn(t,e,n,r,s){var a=e[0],o=e[1],i=n[0],u=n[1],l=r[0],c=l[0],h=l[1],p=r[1],d=p[0],b=p[1];return s===void 0&&(s=!1),Y(function(){var v=Pn.resizeBilinear(t,[i,u],!0);return s&&(v=Mt(v)),function(N,_,F){var x=_[0],$=_[1],A=F[0],I=A[0],P=A[1],M=F[1],C=M[0],j=M[1];return Y(function(){var z=st(N);return mt(Pn.cropAndResize(z,[[I/(x+I+P-1),C/($+C+j-1),(I+x-1)/(x+I+P-1),(C+$-1)/($+C+j-1)]],[0],[x,$]),[0])})}(v,[a,o],[[c,h],[d,b]])})}function hs(t,e){var n=e[0],r=e[1],s=Tr(t),a=s[0],o=s[1],i=r/n,u=[0,0,0,0],l=u[0],c=u[1],h=u[2],p=u[3];o/a<i?(l=0,c=0,h=Math.round(.5*(i*a-o)),p=Math.round(.5*(i*a-o))):(l=Math.round(.5*(1/i*o-a)),c=Math.round(.5*(1/i*o-a)),h=0,p=0);var d=Y(function(){var b=function(v){return v instanceof be?v:Ms(v)}(t);return b=ai(b,[[l,c],[h,p],[0,0]]),Pn.resizeBilinear(b,[n,r])});return{resized:d,padding:{top:l,left:h,right:p,bottom:c}}}function fs(t){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,Promise.all(t.map(function(n){return n.buffer()}))]})})}function ps(t,e,n,r,s){var a=e[0],o=e[1],i=n[0],u=n[1],l=function(c,h,p,d,b){return d===void 0&&(d=0),b===void 0&&(b=0),p===1&&h===1&&d===0&&b===0?c:c.map(function(v){return function(N,_,F,x,$){return x===void 0&&(x=0),$===void 0&&($=0),{score:N.score,keypoints:N.keypoints.map(function(A){var I=A.score,P=A.part,M=A.position;return{score:I,part:P,position:{x:M.x*F+$,y:M.y*_+x}}})}}(v,h,p,d,b)})}(t,(a+r.top+r.bottom)/i,(o+r.left+r.right)/u,-r.top,-r.left);return s?function(c,h){return h<=0?c:c.map(function(p){return function(d,b){return{score:d.score,keypoints:d.keypoints.map(function(v){var N=v.score,_=v.part,F=v.position;return{score:N,part:_,position:{x:b-1-F.x,y:F.y}}})}}(p,h)})}(l,o):l}var Tu={architecture:"MobileNetV1",outputStride:16,quantBytes:4,multiplier:.75},Eu=["MobileNetV1","ResNet50"],ku={MobileNetV1:[8,16,32],ResNet50:[32,16]},xu={MobileNetV1:[.5,.75,1],ResNet50:[1]},_u=[1,2,4],ds={flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7,maxDetections:10,scoreThreshold:.4,nmsRadius:20},ms={flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7,maxDetections:10,scoreThreshold:.4,nmsRadius:20,minKeypointScore:.3,refineSteps:10};function $u(t){var e=t.segmentationThreshold,n=t.maxDetections,r=t.scoreThreshold,s=t.nmsRadius;if(e<0||e>1)throw new Error("segmentationThreshold "+e+". Should be in range [0.0, 1.0]");if(n<=0)throw new Error("Invalid maxDetections "+n+". Should be > 0");if(r<0||r>1)throw new Error("Invalid scoreThreshold "+r+". Should be in range [0.0, 1.0]");if(s<=0)throw new Error("Invalid nmsRadius "+s+".")}function Au(t){var e=t.segmentationThreshold,n=t.maxDetections,r=t.scoreThreshold,s=t.nmsRadius,a=t.minKeypointScore,o=t.refineSteps;if(e<0||e>1)throw new Error("segmentationThreshold "+e+". Should be in range [0.0, 1.0]");if(n<=0)throw new Error("Invalid maxDetections "+n+". Should be > 0");if(r<0||r>1)throw new Error("Invalid scoreThreshold "+r+". Should be in range [0.0, 1.0]");if(s<=0)throw new Error("Invalid nmsRadius "+s+".");if(a<0||a>1)throw new Error("Invalid minKeypointScore "+a+".Should be in range [0.0, 1.0]");if(o<=0||o>20)throw new Error("Invalid refineSteps "+o+".Should be in range [1, 20]")}var lm=function(){function t(e){this.baseModel=e}return t.prototype.predictForPersonSegmentation=function(e){var n=this.baseModel.predict(e);return{segmentLogits:n.segmentation,heatmapScores:n.heatmapScores,offsets:n.offsets,displacementFwd:n.displacementFwd,displacementBwd:n.displacementBwd}},t.prototype.predictForPersonSegmentationAndPart=function(e){var n=this.baseModel.predict(e);return{segmentLogits:n.segmentation,partHeatmapLogits:n.partHeatmaps,heatmapScores:n.heatmapScores,offsets:n.offsets,displacementFwd:n.displacementFwd,displacementBwd:n.displacementBwd}},t.prototype.predictForMultiPersonInstanceSegmentationAndPart=function(e){var n=this.baseModel.predict(e);return{segmentLogits:n.segmentation,longOffsets:n.longOffsets,heatmapScores:n.heatmapScores,offsets:n.offsets,displacementFwd:n.displacementFwd,displacementBwd:n.displacementBwd,partHeatmaps:n.partHeatmaps}},t.prototype.segmentPersonActivation=function(e,n,r){var s=this;r===void 0&&(r=.5);var a=Tr(e),o=a[0],i=a[1],u=cs(n,this.baseModel.outputStride,[o,i]),l=hs(e,u),c=l.resized,h=l.padding,p=Y(function(){var F=s.predictForPersonSegmentation(c),x=F.segmentLogits,$=F.heatmapScores,A=F.offsets,I=F.displacementFwd,P=F.displacementBwd,M=c.shape,C=M[0],j=M[1],z=Kn(x,[o,i],[C,j],[[h.top,h.bottom],[h.left,h.right]],!0);return{segmentation:us(mt(z),r),heatmapScores:$,offsets:A,displacementFwd:I,displacementBwd:P}}),d=p.segmentation,b=p.heatmapScores,v=p.offsets,N=p.displacementFwd,_=p.displacementBwd;return c.dispose(),{segmentation:d,heatmapScores:b,offsets:v,displacementFwd:N,displacementBwd:_,padding:h,internalResolutionHeightAndWidth:u}},t.prototype.segmentPerson=function(e,n){return n===void 0&&(n=ds),ce(this,void 0,void 0,function(){var r,s,a,o,i,u,l,c,h,p,d,b,v,N,_,F,x,$;return he(this,function(A){switch(A.label){case 0:return $u(n=Ge(Ge({},ds),n)),r=this.segmentPersonActivation(e,n.internalResolution,n.segmentationThreshold),s=r.segmentation,a=r.heatmapScores,o=r.offsets,i=r.displacementFwd,u=r.displacementBwd,l=r.padding,c=r.internalResolutionHeightAndWidth,h=s.shape,p=h[0],d=h[1],[4,s.data()];case 1:return b=A.sent(),s.dispose(),[4,fs([a,o,i,u])];case 2:return v=A.sent(),N=v[0],_=v[1],F=v[2],x=v[3],$=ps($=ls(N,_,F,x,this.baseModel.outputStride,n.maxDetections,n.scoreThreshold,n.nmsRadius),[p,d],c,l,!1),a.dispose(),o.dispose(),i.dispose(),u.dispose(),[2,{height:p,width:d,data:b,allPoses:$}]}})})},t.prototype.segmentMultiPerson=function(e,n){return n===void 0&&(n=ms),ce(this,void 0,void 0,function(){var r,s,a,o,i,u,l,c,h,p,d,b,v,N,_,F,x,$,A,I,P,M=this;return he(this,function(C){switch(C.label){case 0:return Au(n=Ge(Ge({},ms),n)),r=Tr(e),s=r[0],a=r[1],o=cs(n.internalResolution,this.baseModel.outputStride,[s,a]),i=hs(e,o),u=i.resized,l=i.padding,c=Y(function(){var j,z=M.predictForMultiPersonInstanceSegmentationAndPart(u),G=z.segmentLogits,K=z.longOffsets,Z=z.heatmapScores,ie=z.offsets,pe=z.displacementFwd,Oe=z.displacementBwd,Ve=Kn(G,[s,a],o,[[l.top,l.bottom],[l.left,l.right]],!0);return j=K,{segmentation:us(mt(Ve),n.segmentationThreshold),longOffsets:j,heatmapScoresRaw:Z,offsetsRaw:ie,displacementFwdRaw:pe,displacementBwdRaw:Oe}}),h=c.segmentation,p=c.longOffsets,d=c.heatmapScoresRaw,b=c.offsetsRaw,v=c.displacementFwdRaw,N=c.displacementBwdRaw,[4,fs([d,b,v,N])];case 1:return _=C.sent(),F=_[0],x=_[1],$=_[2],A=_[3],I=ps(I=ls(F,x,$,A,this.baseModel.outputStride,n.maxDetections,n.scoreThreshold,n.nmsRadius),[s,a],o,l,!1),[4,xE(h,p,I,s,a,this.baseModel.outputStride,o,l,n.scoreThreshold,n.refineSteps,n.minKeypointScore,n.maxDetections)];case 2:return P=C.sent(),u.dispose(),h.dispose(),p.dispose(),d.dispose(),b.dispose(),v.dispose(),N.dispose(),[2,P]}})})},t.prototype.segmentPersonPartsActivation=function(e,n,r){var s=this;r===void 0&&(r=.5);var a=Tr(e),o=a[0],i=a[1],u=cs(n,this.baseModel.outputStride,[o,i]),l=hs(e,u),c=l.resized,h=l.padding,p=Y(function(){var F=s.predictForPersonSegmentationAndPart(c),x=F.segmentLogits,$=F.partHeatmapLogits,A=F.heatmapScores,I=F.offsets,P=F.displacementFwd,M=F.displacementBwd,C=c.shape,j=C[0],z=C[1],G=Kn(x,[o,i],[j,z],[[h.top,h.bottom],[h.left,h.right]],!0),K=Kn($,[o,i],[j,z],[[h.top,h.bottom],[h.left,h.right]],!0);return{partSegmentation:NE(us(mt(G),r),K),heatmapScores:A,offsets:I,displacementFwd:P,displacementBwd:M}}),d=p.partSegmentation,b=p.heatmapScores,v=p.offsets,N=p.displacementFwd,_=p.displacementBwd;return c.dispose(),{partSegmentation:d,heatmapScores:b,offsets:v,displacementFwd:N,displacementBwd:_,padding:h,internalResolutionHeightAndWidth:u}},t.prototype.segmentPersonParts=function(e,n){return n===void 0&&(n=ds),ce(this,void 0,void 0,function(){var r,s,a,o,i,u,l,c,h,p,d,b,v,N,_,F,x,$;return he(this,function(A){switch(A.label){case 0:return $u(n=Ge(Ge({},ds),n)),r=this.segmentPersonPartsActivation(e,n.internalResolution,n.segmentationThreshold),s=r.partSegmentation,a=r.heatmapScores,o=r.offsets,i=r.displacementFwd,u=r.displacementBwd,l=r.padding,c=r.internalResolutionHeightAndWidth,h=s.shape,p=h[0],d=h[1],[4,s.data()];case 1:return b=A.sent(),s.dispose(),[4,fs([a,o,i,u])];case 2:return v=A.sent(),N=v[0],_=v[1],F=v[2],x=v[3],$=ps($=ls(N,_,F,x,this.baseModel.outputStride,n.maxDetections,n.scoreThreshold,n.nmsRadius),[p,d],c,l,!1),a.dispose(),o.dispose(),i.dispose(),u.dispose(),[2,{height:p,width:d,data:b,allPoses:$}]}})})},t.prototype.segmentMultiPersonParts=function(e,n){return n===void 0&&(n=ms),ce(this,void 0,void 0,function(){var r,s,a,o,i,u,l,c,h,p,d,b,v,N,_,F,x,$,A,I,P,M,C=this;return he(this,function(j){switch(j.label){case 0:return Au(n=Ge(Ge({},ms),n)),r=Tr(e),s=r[0],a=r[1],o=cs(n.internalResolution,this.baseModel.outputStride,[s,a]),i=hs(e,o),u=i.resized,l=i.padding,c=Y(function(){var z=C.predictForMultiPersonInstanceSegmentationAndPart(u),G=z.segmentLogits,K=z.longOffsets,Z=z.heatmapScores,ie=z.offsets,pe=z.displacementFwd,Oe=z.displacementBwd,Ve=z.partHeatmaps,je=Kn(G,[s,a],o,[[l.top,l.bottom],[l.left,l.right]],!0),Ot=Kn(Ve,[s,a],o,[[l.top,l.bottom],[l.left,l.right]],!0),St=K,Jt=us(mt(je),n.segmentationThreshold),Dt=function(Nt){var Tt=Nt.shape,Et=Tt[0],Ft=Tt[1],Qt=Tt[2];return Y(function(){var tt=Qd(Nt),kt=st(fn(0,Qt,1,"int32"),1),ts=we(ye(tt,kt),"int32");return B(ts,[Et,Ft])})}(Ot);return{segmentation:Jt,longOffsets:St,heatmapScoresRaw:Z,offsetsRaw:ie,displacementFwdRaw:pe,displacementBwdRaw:Oe,partSegmentation:Dt}}),h=c.segmentation,p=c.longOffsets,d=c.heatmapScoresRaw,b=c.offsetsRaw,v=c.displacementFwdRaw,N=c.displacementBwdRaw,_=c.partSegmentation,[4,fs([d,b,v,N])];case 1:return F=j.sent(),x=F[0],$=F[1],A=F[2],I=F[3],P=ps(P=ls(x,$,A,I,this.baseModel.outputStride,n.maxDetections,n.scoreThreshold,n.nmsRadius),[s,a],o,l,!1),[4,_E(h,p,_,P,s,a,this.baseModel.outputStride,o,l,n.scoreThreshold,n.refineSteps,n.minKeypointScore,n.maxDetections)];case 2:return M=j.sent(),u.dispose(),h.dispose(),p.dispose(),d.dispose(),b.dispose(),v.dispose(),N.dispose(),_.dispose(),[2,M]}})})},t.prototype.dispose=function(){this.baseModel.dispose()},t}();function PE(t){return ce(this,void 0,void 0,function(){var e,n,r,s,a,o;return he(this,function(i){switch(i.label){case 0:if(e=t.outputStride,n=t.quantBytes,r=t.multiplier,qd==null)throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this
        model.`);return s=function(u,l,c){var h={1:"100",.75:"075",.5:"050"},p="model-stride"+u+".json";return c===4?Su+"float/"+h[l]+"/"+p:Su+"quant"+c+"/"+h[l]+"/"+p}(e,r,n),[4,Ni(t.modelUrl||s)];case 1:return a=i.sent(),o=new TE(a,e),[2,new lm(o)]}})})}function RE(t){return ce(this,void 0,void 0,function(){var e,n,r,s,a;return he(this,function(o){switch(o.label){case 0:if(e=t.outputStride,n=t.quantBytes,qd==null)throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this
        model.`);return r=function(i,u){var l="model-stride"+i+".json";return u===4?vu+"float/"+l:vu+"quant"+u+"/"+l}(e,n),[4,Ni(t.modelUrl||r)];case 1:return s=o.sent(),a=new FE(s,e),[2,new lm(a)]}})})}function BE(t){return t===void 0&&(t=Tu),ce(this,void 0,void 0,function(){return he(this,function(e){return(t=function(n){if((n=n||Tu).architecture==null&&(n.architecture="MobileNetV1"),Eu.indexOf(n.architecture)<0)throw new Error("Invalid architecture "+n.architecture+". Should be one of "+Eu);if(n.outputStride==null&&(n.outputStride=16),ku[n.architecture].indexOf(n.outputStride)<0)throw new Error("Invalid outputStride "+n.outputStride+". Should be one of "+ku[n.architecture]+" for architecture "+n.architecture+".");if(n.multiplier==null&&(n.multiplier=1),xu[n.architecture].indexOf(n.multiplier)<0)throw new Error("Invalid multiplier "+n.multiplier+". Should be one of "+xu[n.architecture]+" for architecture "+n.architecture+".");if(n.quantBytes==null&&(n.quantBytes=4),_u.indexOf(n.quantBytes)<0)throw new Error("Invalid quantBytes "+n.quantBytes+". Should be one of "+_u+" for architecture "+n.architecture+".");return n}(t)).architecture==="ResNet50"?[2,RE(t)]:t.architecture==="MobileNetV1"?[2,PE(t)]:[2,null]})})}var uo=["left_face","right_face","left_upper_arm_front","left_upper_arm_back","right_upper_arm_front","right_upper_arm_back","left_lower_arm_front","left_lower_arm_back","right_lower_arm_front","right_lower_arm_back","left_hand","right_hand","torso_front","torso_back","left_upper_leg_front","left_upper_leg_back","right_upper_leg_front","right_upper_leg_back","left_lower_leg_front","left_lower_leg_back","right_lower_leg_front","right_lower_leg_back","left_feet","right_feet"],Iu=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,Ti(this.mask)]})})},t.prototype.toImageData=function(){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,this.mask]})})},t.prototype.toTensor=function(){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,Jd(this.mask)]})})},t.prototype.getUnderlyingType=function(){return"imagedata"},t}();function LE(t){if(ra(t),t!==255)throw new Error("Foreground id must be 255 but got "+t);return"person"}function ME(t){if(ra(t),t>=uo.length)throw new Error("Invalid body part value "+t);return uo[t]}var zE=function(){function t(e){this.bodyPixModel=e}return t.prototype.segmentPeople=function(e,n){return ce(this,void 0,void 0,function(){var r,s,a,o;return he(this,function(i){switch(i.label){case 0:return e instanceof ImageBitmap&&((r=document.createElement("canvas")).getContext("2d").drawImage(e,0,0),e=r),n.segmentBodyParts?n.multiSegmentation?[4,this.bodyPixModel.segmentMultiPersonParts(e,n)]:[3,2]:[3,5];case 1:return a=i.sent(),[3,4];case 2:return[4,this.bodyPixModel.segmentPersonParts(e,n)];case 3:a=[i.sent()],i.label=4;case 4:return s=a.map(function(u){var l=u.data,c=u.width,h=u.height,p=new Uint8ClampedArray(c*h*4).fill(0);return l.forEach(function(d,b){d===-1?(p[4*b]=uo.length,p[4*b+3]=0):(p[4*b]=d,p[4*b+3]=255)}),{maskValueToLabel:ME,mask:new Iu(new ImageData(p,c,h))}}),[3,10];case 5:return n.multiSegmentation?[4,this.bodyPixModel.segmentMultiPerson(e,n)]:[3,7];case 6:return o=i.sent(),[3,9];case 7:return[4,this.bodyPixModel.segmentPerson(e,n)];case 8:o=[i.sent()],i.label=9;case 9:s=o.map(function(u){var l=u.data,c=u.width,h=u.height,p=new Uint8ClampedArray(c*h*4).fill(0);return l.forEach(function(d,b){d===0?(p[4*b]=0,p[4*b+3]=0):(p[4*b]=255,p[4*b+3]=255)}),{maskValueToLabel:LE,mask:new Iu(new ImageData(p,c,h))}}),i.label=10;case 10:return[2,s]}})})},t.prototype.dispose=function(){this.bodyPixModel.dispose()},t.prototype.reset=function(){},t}();function VE(t){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,BE(t).then(function(n){return new zE(n)})]})})}var Ou={runtime:"mediapipe",modelType:"general"},jE=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,this.mask]})})},t.prototype.toImageData=function(){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,Zd(this.mask)]})})},t.prototype.toTensor=function(){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,Jd(this.mask)]})})},t.prototype.getUnderlyingType=function(){return"canvasimagesource"},t}();function UE(t){return ra(t),"person"}var WE=function(){function t(e){var n,r=this;this.selfieMode=!1,this.selfieSegmentationSolution=new SE({locateFile:function(s,a){return e.solutionPath?e.solutionPath.replace(/\/+$/,"")+"/"+s:a+"/"+s}}),e.modelType==="landscape"?n=1:n=0,this.selfieSegmentationSolution.setOptions({modelSelection:n,selfieMode:this.selfieMode}),this.selfieSegmentationSolution.onResults(function(s){r.segmentation=[{maskValueToLabel:UE,mask:new jE(s.segmentationMask)}]})}return t.prototype.segmentPeople=function(e,n){return ce(this,void 0,void 0,function(){var r,s;return he(this,function(a){switch(a.label){case 0:return n&&n.flipHorizontal&&n.flipHorizontal!==this.selfieMode&&(this.selfieMode=n.flipHorizontal,this.selfieSegmentationSolution.setOptions({selfieMode:this.selfieMode})),e instanceof be?(s=ImageData.bind,[4,Wr(e)]):[3,2];case 1:return r=new(s.apply(ImageData,[void 0,a.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:r=e,a.label=3;case 3:return e=r,[4,this.selfieSegmentationSolution.send({image:e})];case 4:return a.sent(),[2,this.segmentation]}})})},t.prototype.dispose=function(){this.selfieSegmentationSolution.close()},t.prototype.reset=function(){this.selfieSegmentationSolution.reset(),this.segmentation=null,this.selfieMode=!1},t.prototype.initialize=function(){return this.selfieSegmentationSolution.initialize()},t}();function qE(t){return ce(this,void 0,void 0,function(){var e,n;return he(this,function(r){switch(r.label){case 0:return e=function(s){if(s==null)return Ge({},Ou);var a=Ge({},s);return a.runtime="mediapipe",a.modelType==null&&(a.modelType=Ou.modelType),a}(t),[4,(n=new WE(e)).initialize()];case 1:return r.sent(),[2,n]}})})}function HE(t,e,n,r){var s=t.width,a=t.height,o=r?-1:1,i=Math.cos(t.rotation),u=Math.sin(t.rotation),l=t.xCenter,c=t.yCenter,h=1/e,p=1/n,d=new Array(16);return d[0]=s*i*o*h,d[1]=-a*u*h,d[2]=0,d[3]=(-.5*s*i*o+.5*a*u+l)*h,d[4]=s*u*o*p,d[5]=a*i*p,d[6]=0,d[7]=(-.5*a*i-.5*s*u*o+c)*p,d[8]=0,d[9]=0,d[10]=s*h,d[11]=0,d[12]=0,d[13]=0,d[14]=0,d[15]=1,function(b){if(b.length!==16)throw new Error("Array length must be 16 but got "+b.length);return[[b[0],b[1],b[2],b[3]],[b[4],b[5],b[6],b[7]],[b[8],b[9],b[10],b[11]],[b[12],b[13],b[14],b[15]]]}(d)}function cm(t){return t instanceof be?{height:t.shape[0],width:t.shape[1]}:{height:t.height,width:t.width}}function ka(t,e){S(t.width!==0,function(){return e+" width cannot be 0."}),S(t.height!==0,function(){return e+" height cannot be 0."})}function GE(t,e){var n=function(r,s,a,o){var i=s-r,u=o-a;if(i===0)throw new Error("Original min and max are both "+r+", range cannot be 0.");var l=u/i;return{scale:l,offset:a-r*l}}(0,255,e[0],e[1]);return Y(function(){return X(U(t,n.scale),n.offset)})}function KE(t,e,n){var r=e.outputTensorSize,s=e.keepAspectRatio,a=e.borderMode,o=e.outputTensorFloatRange,i=cm(t),u=function(p,d){return d?{xCenter:d.xCenter*p.width,yCenter:d.yCenter*p.height,width:d.width*p.width,height:d.height*p.height,rotation:d.rotation}:{xCenter:.5*p.width,yCenter:.5*p.height,width:p.width,height:p.height,rotation:0}}(i,n),l=function(p,d,b){if(b===void 0&&(b=!1),!b)return{top:0,left:0,right:0,bottom:0};var v=d.height,N=d.width;ka(d,"targetSize"),ka(p,"roi");var _,F,x=v/N,$=p.height/p.width,A=0,I=0;return x>$?(_=p.width,F=p.width*x,I=(1-$/x)/2):(_=p.height/x,F=p.height,A=(1-x/$)/2),p.width=_,p.height=F,{top:I,left:A,right:A,bottom:I}}(u,r,s),c=HE(u,i.width,i.height,!1),h=Y(function(){var p,d=(p=t)instanceof be?p:Ms(p),b=_n(function(_,F,x){return ka(x,"inputResolution"),[1/x.width*_[0][0]*F.width,1/x.height*_[0][1]*F.width,_[0][3]*F.width,1/x.width*_[1][0]*F.height,1/x.height*_[1][1]*F.height,_[1][3]*F.height,0,0]}(c,i,r),[1,8]),v=a==="zero"?"constant":"nearest",N=Pn.transform(st(we(d,"float32")),b,"bilinear",v,0,[r.height,r.width]);return o!=null?GE(N,o):N});return{imageTensor:h,padding:l,transformationMatrix:c}}function XE(t,e,n){return Y(function(){var r=mt(t,[0]),s=r.shape[2];if(s===1){var a=r;switch(e.activation){case"none":break;case"sigmoid":a=Mt(a);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported ("+e.activation+")")}var o=n?Pn.resizeBilinear(a,[n.height,n.width]):a;return mt(o,[2])}throw new Error("Unsupported number of tensor channels "+s)})}var Du={runtime:"tfjs",modelType:"general",modelUrl:"https://tfhub.dev/mediapipe/tfjs-model/selfie_segmentation/general/1"},Fu={flipHorizontal:!1},YE={outputTensorSize:{width:256,height:256},keepAspectRatio:!1,borderMode:"zero",outputTensorFloatRange:[0,1]},ZE={outputTensorSize:{width:256,height:144},keepAspectRatio:!1,borderMode:"zero",outputTensorFloatRange:[0,1]},JE={activation:"none"},QE=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,Ti(this.mask)]})})},t.prototype.toImageData=function(){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,Zd(this.mask)]})})},t.prototype.toTensor=function(){return ce(this,void 0,void 0,function(){return he(this,function(e){return[2,this.mask]})})},t.prototype.getUnderlyingType=function(){return"tensor"},t}();function ek(t){return ra(t),"person"}var Lr,tk=function(){function t(e,n){this.modelType=e,this.model=n}return t.prototype.segmentPeople=function(e,n){return ce(this,void 0,void 0,function(){var r,s=this;return he(this,function(a){return n=function(o){if(o==null)return Ge({},Fu);var i=Ge({},o);return i.flipHorizontal==null&&(i.flipHorizontal=Fu.flipHorizontal),i}(n),e==null?(this.reset(),[2,[]]):(r=Y(function(){var o=KE(e,s.modelType==="general"?YE:ZE).imageTensor,i=Te(s.model.predict(o),[0,0,0,1],-1),u=cm(e),l=XE(i,JE,u),c=st(l,2),h=Mn(c,[[0,0],[0,0],[0,1]]);return ri(h,[[0,0],[0,0],[0,2]],"symmetric")}),[2,[{maskValueToLabel:ek,mask:new QE(r)}]])})})},t.prototype.dispose=function(){this.model.dispose()},t.prototype.reset=function(){},t}();function nk(t){return ce(this,void 0,void 0,function(){var e,n,r;return he(this,function(s){switch(s.label){case 0:return e=function(a){if(a==null)return Ge({},Du);var o=Ge({},a);if(o.runtime="tfjs",o.modelType==null&&(o.modelType=Du.modelType),o.modelType!=="general"&&o.modelType!=="landscape")throw new Error("Model type must be one of general or landscape, but got "+o.modelType);return o.modelUrl==null&&(o.modelType==="general"?o.modelUrl="https://tfhub.dev/mediapipe/tfjs-model/selfie_segmentation/general/1":o.modelUrl="https://tfhub.dev/mediapipe/tfjs-model/selfie_segmentation/landscape/1"),o}(t),n=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,Ni(e.modelUrl,{fromTFHub:n})];case 1:return r=s.sent(),[2,new tk(e.modelType,r)]}})})}function rk(t,e){return ce(this,void 0,void 0,function(){var n,r;return he(this,function(s){switch(t){case Lr.MediaPipeSelfieSegmentation:if(n=void 0,(r=e)!=null){if(r.runtime==="tfjs")return[2,nk(r)];if(r.runtime==="mediapipe")return[2,qE(r)];n=r.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got "+n);case Lr.BodyPix:return[2,VE(r=e)];default:throw new Error(t+" is not a supported model name.")}})})}(function(t){t.BodyPix="BodyPix",t.MediaPipeSelfieSegmentation="MediaPipeSelfieSegmentation"})(Lr||(Lr={}));var sk="blurred",ak="blurred-mask",ok="mask",ik="draw-image",xa={};function aa(t){if(typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&t instanceof OffscreenCanvas||typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)return function(e){if("offsetHeight"in e&&e.offsetHeight!==0&&"offsetWidth"in e&&e.offsetWidth!==0)return[e.offsetHeight,e.offsetWidth];if(e.height!=null&&e.width!=null)return[e.height,e.width];throw new Error("HTMLImageElement must have height and width attributes set.")}(t);if(typeof ImageData<"u"&&t instanceof ImageData)return[t.height,t.width];if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)return function(e){return e.hasAttribute("height")&&e.hasAttribute("width")?[e.height,e.width]:[e.videoHeight,e.videoWidth]}(t);if(t instanceof be)return[t.shape[0],t.shape[1]];throw new Error("error: Unknown input type: "+t+".")}function hm(t){return xa[t]||(xa[t]=function(){if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(0,0);throw new Error("Cannot create a canvas in this context")}()),xa[t]}function fm(t,e){var n=hm(e);return function(r,s){s.width=r.width,s.height=r.height,s.getContext("2d").putImageData(r,0,0)}(t,n),n}function es(t,e,n,r,s,a){return ce(this,void 0,void 0,function(){var o,i,u,l;return he(this,function(c){switch(c.label){case 0:return e instanceof be?[4,Wr(e)]:[3,2];case 1:o=c.sent(),i=aa(e),u=i[0],l=i[1],e=new ImageData(o,l,u),c.label=2;case 2:return e instanceof ImageData&&(e=fm(e,ik)),s==null||a==null?t.drawImage(e,n,r):t.drawImage(e,n,r,s,a),[2]}})})}function uk(t,e){return ce(this,void 0,void 0,function(){var n,r,s;return he(this,function(a){switch(a.label){case 0:return n=aa(t),r=n[0],s=n[1],e.width=s,e.height=r,[4,es(e.getContext("2d"),t,0,0,s,r)];case 1:return a.sent(),[2]}})})}function lk(t){var e=t.getContext("2d");e.scale(-1,1),e.translate(-t.width,0)}function Cu(t,e,n){return ce(this,void 0,void 0,function(){return he(this,function(r){switch(r.label){case 0:return t.globalCompositeOperation=n,[4,es(t,e,0,0)];case 1:return r.sent(),[2]}})})}function ck(t,e,n){return ce(this,void 0,void 0,function(){var r,s,a,o,i,u,l,c;return he(this,function(h){switch(h.label){case 0:for(r=t.getContext("2d"),s=0,a=5,o=1/(2*Math.PI*a*a),i=n<3?1:2,l=-n;l<=n;l+=i)for(c=-n;c<=n;c+=i)u=o*Math.exp(-(c*c+l*l)/(2*a*a)),s+=u;l=-n,h.label=1;case 1:if(!(l<=n))return[3,6];c=-n,h.label=2;case 2:return c<=n?(r.globalAlpha=o*Math.exp(-(c*c+l*l)/(2*a*a))/s*n,[4,es(r,e,c,l)]):[3,5];case 3:h.sent(),h.label=4;case 4:return c+=i,[3,2];case 5:return l+=i,[3,1];case 6:return r.globalAlpha=1,[2]}})})}function hk(t,e,n){return ce(this,void 0,void 0,function(){var r,s,a,o;return he(this,function(i){switch(i.label){case 0:return r=aa(t),s=r[0],a=r[1],o=n.getContext("2d"),n.width=a,n.height=s,o.clearRect(0,0,a,s),o.save(),/^((?!chrome|android).)*safari/i.test(navigator.userAgent)?[4,ck(n,t,e)]:[3,2];case 1:return i.sent(),[3,4];case 2:return o.filter="blur("+e+"px)",[4,es(o,t,0,0,a,s)];case 3:i.sent(),i.label=4;case 4:return o.restore(),[2]}})})}function pm(t,e,n){return ce(this,void 0,void 0,function(){var r;return he(this,function(s){switch(s.label){case 0:return r=hm(n),e!==0?[3,2]:[4,uk(t,r)];case 1:return s.sent(),[3,4];case 2:return[4,hk(t,e,r)];case 3:s.sent(),s.label=4;case 4:return[2,r]}})})}function fk(t,e,n,r,s,a){a===void 0&&(a={r:0,g:255,b:255,a:255});for(var o=-s;o<=s;o++)for(var i=-s;i<=s;i++)if(o!==0&&i!==0){var u=(e+o)*r+(n+i);t[4*u+0]=a.r,t[4*u+1]=a.g,t[4*u+2]=a.b,t[4*u+3]=a.a}}function pk(t,e,n,r,s,a,o){o===void 0&&(o=1);for(var i=0,u=-o;u<=o;u++)for(var l=-o;l<=o;l++)if(u!==0&&l!==0){var c=(e+u)*r+(n+l);(!s[t[4*c]]||t[4*c+3]<a)&&(i+=1)}return i>0}function dk(t,e,n,r,s,a){return e===void 0&&(e={r:0,g:0,b:0,a:0}),n===void 0&&(n={r:0,g:0,b:0,a:255}),r===void 0&&(r=!1),s===void 0&&(s=.5),a===void 0&&(a=Array.from(Array(256).keys())),ce(this,void 0,void 0,function(){var o,i,u,l,c,h,p,d,b,v,N,_,F,x;return he(this,function($){switch($.label){case 0:return(o=Array.isArray(t)?t:[t]).length===0?[2,null]:[4,Promise.all(o.map(function(A){return A.mask.toImageData()}))];case 1:for(i=$.sent(),u=i[0],l=u.width,c=u.height,h=new Uint8ClampedArray(l*c*4),p=Math.round(255*s),d=new Array(256).fill(!1),a.forEach(function(A){return d[A]=!0}),b=0;b<c;b++)for(v=0;v<l;v++)for(h[4*(N=b*l+v)+0]=n.r,h[4*N+1]=n.g,h[4*N+2]=n.b,h[4*N+3]=n.a,_=0,F=i;_<F.length;_++)x=F[_],d[x.data[4*N]]&&x.data[4*N+3]>=p&&(h[4*N]=e.r,h[4*N+1]=e.g,h[4*N+2]=e.b,h[4*N+3]=e.a,r&&b-1>=0&&b+1<c&&v-1>=0&&v+1<l&&pk(x.data,b,v,l,d,p)&&fk(h,b,v,l,1));return[2,new ImageData(h,l,c)]}})})}function mk(t,e,n){return ce(this,void 0,void 0,function(){var r,s;return he(this,function(a){switch(a.label){case 0:return[4,dk(t,{r:0,g:0,b:0,a:255},{r:0,g:0,b:0,a:0},!1,e)];case 1:return r=a.sent(),s=fm(r,ok),n===0?[2,s]:[2,pm(s,n,ak)]}})})}function gk(t,e,n,r,s,a,o){return r===void 0&&(r=.5),s===void 0&&(s=3),a===void 0&&(a=3),o===void 0&&(o=!1),ce(this,void 0,void 0,function(){var i,u,l,c,h,p;return he(this,function(d){switch(d.label){case 0:return[4,pm(e,s,sk)];case 1:return i=d.sent(),t.width=i.width,t.height=i.height,u=t.getContext("2d"),Array.isArray(n)&&n.length===0?(u.drawImage(i,0,0),[2]):[4,mk(n,r,a)];case 2:return l=d.sent(),u.save(),o&&lk(t),c=aa(e),h=c[0],p=c[1],[4,es(u,e,0,0,p,h)];case 3:return d.sent(),[4,Cu(u,l,"destination-in")];case 4:return d.sent(),[4,Cu(u,i,"destination-over")];case 5:return d.sent(),u.restore(),[2]}})})}var dm,mm,Zn,gm,ym,bm,wm,vm;({camera:gm}=ng);dm="video";Zn=0;bm=.5;mm=20;ym=3;vm=`precision highp float;
attribute vec2 pos;
attribute vec2 uv;
varying vec2 vUv;
uniform float flipX;
uniform float flipY;

void main(void) {
  vUv = uv;
  gl_Position = vec4(pos.x*flipX, pos.y*flipY, 0.0, 1.0);
}`;wm=`precision highp float;
uniform vec2 singleStepOffset;
uniform sampler2D texture;
uniform vec4 params;
uniform float brightness;
varying vec2 vUv;
const highp vec3 W = vec3(0.299,0.587,0.114);
const mat3 saturateMatrix = mat3(1.1102,-0.0598,-0.061,-0.0774,1.0826,-0.1186,-0.0228,-0.0228,1.1772);
vec2 blurCoordinates[24];

float hardLight(float color){
  if(color <= 0.5){
  color = color * color * 2.0;
  } else {
  color = 1.0 - ((1.0 - color)*(1.0 - color) * 2.0);
  }
  return color;
}
void main(){
  vec3 centralColor = texture2D(texture, vUv).rgb;
  blurCoordinates[0] = vUv.xy + singleStepOffset * vec2(0.0, -10.0);
  blurCoordinates[1] = vUv.xy + singleStepOffset * vec2(0.0, 10.0);
  blurCoordinates[2] = vUv.xy + singleStepOffset * vec2(-10.0, 0.0);
  blurCoordinates[3] = vUv.xy + singleStepOffset * vec2(10.0, 0.0);
  blurCoordinates[4] = vUv.xy + singleStepOffset * vec2(5.0, -8.0);
  blurCoordinates[5] = vUv.xy + singleStepOffset * vec2(5.0, 8.0);
  blurCoordinates[6] = vUv.xy + singleStepOffset * vec2(-5.0, 8.0);
  blurCoordinates[7] = vUv.xy + singleStepOffset * vec2(-5.0, -8.0);
  blurCoordinates[8] = vUv.xy + singleStepOffset * vec2(8.0, -5.0);
  blurCoordinates[9] = vUv.xy + singleStepOffset * vec2(8.0, 5.0);
  blurCoordinates[10] = vUv.xy + singleStepOffset * vec2(-8.0, 5.0);
  blurCoordinates[11] = vUv.xy + singleStepOffset * vec2(-8.0, -5.0);
  blurCoordinates[12] = vUv.xy + singleStepOffset * vec2(0.0, -6.0);
  blurCoordinates[13] = vUv.xy + singleStepOffset * vec2(0.0, 6.0);
  blurCoordinates[14] = vUv.xy + singleStepOffset * vec2(6.0, 0.0);
  blurCoordinates[15] = vUv.xy + singleStepOffset * vec2(-6.0, 0.0);
  blurCoordinates[16] = vUv.xy + singleStepOffset * vec2(-4.0, -4.0);
  blurCoordinates[17] = vUv.xy + singleStepOffset * vec2(-4.0, 4.0);
  blurCoordinates[18] = vUv.xy + singleStepOffset * vec2(4.0, -4.0);
  blurCoordinates[19] = vUv.xy + singleStepOffset * vec2(4.0, 4.0);
  blurCoordinates[20] = vUv.xy + singleStepOffset * vec2(-2.0, -2.0);
  blurCoordinates[21] = vUv.xy + singleStepOffset * vec2(-2.0, 2.0);
  blurCoordinates[22] = vUv.xy + singleStepOffset * vec2(2.0, -2.0);
  blurCoordinates[23] = vUv.xy + singleStepOffset * vec2(2.0, 2.0);

  float sampleColor = centralColor.g * 22.0;
  sampleColor += texture2D(texture, blurCoordinates[0]).g;
  sampleColor += texture2D(texture, blurCoordinates[1]).g;
  sampleColor += texture2D(texture, blurCoordinates[2]).g;
  sampleColor += texture2D(texture, blurCoordinates[3]).g;
  sampleColor += texture2D(texture, blurCoordinates[4]).g;
  sampleColor += texture2D(texture, blurCoordinates[5]).g;
  sampleColor += texture2D(texture, blurCoordinates[6]).g;
  sampleColor += texture2D(texture, blurCoordinates[7]).g;
  sampleColor += texture2D(texture, blurCoordinates[8]).g;
  sampleColor += texture2D(texture, blurCoordinates[9]).g;
  sampleColor += texture2D(texture, blurCoordinates[10]).g;
  sampleColor += texture2D(texture, blurCoordinates[11]).g;
  sampleColor += texture2D(texture, blurCoordinates[12]).g * 2.0;
  sampleColor += texture2D(texture, blurCoordinates[13]).g * 2.0;
  sampleColor += texture2D(texture, blurCoordinates[14]).g * 2.0;
  sampleColor += texture2D(texture, blurCoordinates[15]).g * 2.0;
  sampleColor += texture2D(texture, blurCoordinates[16]).g * 2.0;
  sampleColor += texture2D(texture, blurCoordinates[17]).g * 2.0;
  sampleColor += texture2D(texture, blurCoordinates[18]).g * 2.0;
  sampleColor += texture2D(texture, blurCoordinates[19]).g * 2.0;
  sampleColor += texture2D(texture, blurCoordinates[20]).g * 3.0;
  sampleColor += texture2D(texture, blurCoordinates[21]).g * 3.0;
  sampleColor += texture2D(texture, blurCoordinates[22]).g * 3.0;
  sampleColor += texture2D(texture, blurCoordinates[23]).g * 3.0;
  sampleColor = sampleColor / 62.0;
  float highPass = centralColor.g - sampleColor + 0.5;
  
  for(int i = 0; i < 5;i++){
    highPass = hardLight(highPass);
  }

  float luminance = dot(centralColor, W);
  float alpha = pow(luminance, params.r);
  vec3 smoothColor = centralColor + (centralColor-vec3(highPass))*alpha*0.1;

  smoothColor.r = clamp(pow(smoothColor.r, params.g),0.0,1.0);
  smoothColor.g = clamp(pow(smoothColor.g, params.g),0.0,1.0);
  smoothColor.b = clamp(pow(smoothColor.b, params.g),0.0,1.0);
  
  vec3 screen = vec3(1.0) - (vec3(1.0)-smoothColor) * (vec3(1.0)-centralColor);
  vec3 lighten = max(smoothColor, centralColor);
  vec3 softLight = 2.0 * centralColor*smoothColor + centralColor*centralColor - 2.0 * centralColor*centralColor * smoothColor;
  
  gl_FragColor = vec4(mix(centralColor, screen, alpha), 1.0);
  gl_FragColor.rgb = mix(gl_FragColor.rgb, lighten, alpha);
  gl_FragColor.rgb = mix(gl_FragColor.rgb, softLight, params.b);

  vec3 satColor = gl_FragColor.rgb * saturateMatrix;
  gl_FragColor.rgb = mix(gl_FragColor.rgb, satColor, params.a);
  gl_FragColor.rgb = vec3(gl_FragColor.rgb + vec3(brightness));
}`;var yk={setup:()=>{var t,e,n,r,s,a,o,i,u,l,c,h,p,d,b,v,N,_,F,x,$;return $=tn(),l=tn(),v=tn(),o=tn(localStorage.beauty!==void 0?localStorage.beauty-0:0),a=tn(0),N=tn(localStorage.mirror!==void 0?localStorage.mirror-0:0),p=tn("加载中..."),_=void 0,u=void 0,c=void 0,d=void 0,Zn!==void 0&&window.cancelAnimationFrame(Zn),Zn=void 0,i={beautyParams:{beauty:.59,brightness:.5,ruddy:.54},brightness:void 0,params:void 0,singleStepOffset:void 0,flipX:void 0,flipY:void 0,pos:0,uv:0,initialled:!1,sourceTexture:void 0,vertexBuffer:void 0,program:void 0,width:0,height:0,applied:!1},r=()=>{var A,I,P,M,C;i.initialled!==!0&&(C=d.createShader(d.VERTEX_SHADER),A=d.createShader(d.FRAGMENT_SHADER),d.shaderSource(C,vm),d.shaderSource(A,wm),d.compileShader(C),d.compileShader(A),d.getShaderParameter(C,d.COMPILE_STATUS)||console.error("vtx_shader init failed",d.getShaderInfoLog(C)),d.getShaderParameter(A,d.COMPILE_STATUS)||console.error("frag_shader init failed",d.getShaderInfoLog(A)),I=d.createProgram(),d.attachShader(I,C),d.attachShader(I,A),d.linkProgram(I),d.useProgram(I),i.program=I,i.pos=d.getAttribLocation(I,"pos"),i.uv=d.getAttribLocation(I,"uv"),i.singleStepOffset=d.getUniformLocation(I,"singleStepOffset"),i.params=d.getUniformLocation(I,"params"),i.brightness=d.getUniformLocation(I,"brightness"),i.flipX=d.getUniformLocation(I,"flipX"),i.flipY=d.getUniformLocation(I,"flipY"),P=Float32Array.BYTES_PER_ELEMENT,M=4*P,d.enableVertexAttribArray(i.pos),d.vertexAttribPointer(i.pos,2,d.FLOAT,!1,M,0),d.enableVertexAttribArray(i.uv),d.vertexAttribPointer(i.uv,2,d.FLOAT,!1,M,2*P),i.initialled=!0)},s=()=>{var A,I;i.vertexBuffer===void 0&&(I=new Float32Array([-1,-1,0,1,1,-1,1,1,-1,1,0,0,-1,1,0,0,1,-1,1,1,1,1,1,0]),i.vertexBuffer=d.createBuffer(),d.bindBuffer(d.ARRAY_BUFFER,i.vertexBuffer),d.bufferData(d.ARRAY_BUFFER,I,d.STATIC_DRAW),d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0)),d.viewport(0,0,i.width,i.height),d.bindTexture(d.TEXTURE_2D,i.sourceTexture),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.NEAREST),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,d.NEAREST),i.applied===!0?d.texSubImage2D(d.TEXTURE_2D,0,0,0,d.RGB,d.UNSIGNED_BYTE,$.value):(d.texImage2D(d.TEXTURE_2D,0,d.RGB,d.RGB,d.UNSIGNED_BYTE,$.value),i.applied=!0),r(),d.uniform2f(i.singleStepOffset,2/i.width,2/i.height),A=new Float32Array([1-.8*i.beautyParams.beauty,1-.6*i.beautyParams.beauty,.1+.45*i.beautyParams.ruddy,.1+.45*i.beautyParams.ruddy]),d.uniform4fv(i.params,A),d.uniform1f(i.brightness,.12*i.beautyParams.brightness),d.bindTexture(d.TEXTURE_2D,i.sourceTexture),d.bindFramebuffer(d.FRAMEBUFFER,null),d.uniform1f(i.flipX,1),d.uniform1f(i.flipY,1),d.drawArrays(d.TRIANGLES,0,6)},e=async A=>{for(var I,P;;){try{P=await tg(A)}catch(M){I=M,console.error(A,I),p.value="请授权"+{audio:"麦克风",video:"摄像头"}[A],await sg(1e3);continue}return P}},F=async()=>{var A,I,P;_===void 0&&(A=Lr.MediaPipeSelfieSegmentation,P="/mediapipe",I={runtime:"mediapipe",solutionPath:P,modelType:"general"},_=await rk(A,I))},h=async()=>{var A,I,P,M,C,j;try{$.value.readyState===4&&(p.value=!1,u===void 0&&(u=l.value.getContext("2d"),l.value.width=$.value.videoWidth,l.value.height=$.value.videoHeight),d===void 0&&(c=new OffscreenCanvas($.value.videoWidth,$.value.videoHeight),d=c.getContext("webgl"),i.sourceTexture=d.createTexture(),i.width=$.value.videoWidth,i.height=$.value.videoHeight),o.value-0===1?(s(),C=c):C=$.value,I=N.value-0,a.value-0===0?(u.save(),P=I===1?-1:1,j=I===1?-1*l.value.width:0,u.scale(P,1),u.drawImage(C,j,0),u.restore()):(await F(),M=await _.segmentPeople(C),await gk(l.value,C,M,bm,mm,ym,I===1)))}catch(z){A=z,console.error(A)}Zn=window.requestAnimationFrame(h)},b=Gn.src==="camera",Um(async()=>{var A,I,P,M,C,j,z,G;p.value="加载中...",ag(v.value),C=await e(dm),$.value.srcObject=C,M=l.value,b&&(j=await Qm(Gn.sys_audio),I=await e("audio"),P=I?I.getTracks():[],z=M.captureStream(30),G=z?z.getVideoTracks():[],A=C?C.getVideoTracks():[],A=A.concat(G),setTimeout(async()=>{var K;K=new MediaStream([...G,...eg(P,j)]),Wm(()=>{var Z,ie,pe;pe=!!Gn.video;for(Z of A)Z.enabled=pe;Gn.audio;for(Z of P)Z.enabled=pe;ie=Gn.sys_audio;for(Z of j)Z.enabled=ie}),(await qm(()=>import("./d.js"),["d.js","-.js","o.js","$0.js","0.js","q.js","f.js",".js","l.js","a.js","_.css","h.js"])).default(K,P)})),Zn=window.requestAnimationFrame(h)}),x=tn(outerWidth),n=()=>{localStorage.beauty=(o.value=!o.value)-0},t=()=>{a.value=1-a.value},{v:$,cvs:l,main:v,size:x,mirror:N,beauty:o,background:a,err:p,w:A=>{localStorage.face_area_size=A,x.value=A,gm.size(A)},turn:()=>{localStorage.mirror=(N.value=!N.value)-0},makeup:()=>{n()},blur:()=>{t()},x:()=>{Gn.video=""}}}};const Vn=t=>(Xm("data-v-0641bf1a"),t=t(),Ym(),t),bk={style:{display:"none"},autoplay:"",ref:"v"},wk={ref:"cvs",id:"canvasOutput"},vk=Vn(()=>Ne("svg",{fill:"none",height:"11",viewBox:"0 0 10 11",width:"10",xmlns:"http://www.w3.org/2000/svg"},[Ne("circle",{cx:"5",cy:"5.5",opacity:"0.6",r:"4.5",stroke:"var(--c)"})],-1)),Sk=Vn(()=>Ne("svg",{class:"now",fill:"none",height:"24",viewBox:"0 0 24 24",width:"24",xmlns:"http://www.w3.org/2000/svg"},[Ne("circle",{cx:"12",cy:"12",fill:"var(--c)",opacity:"0.7",r:"4.5",stroke:"var(--c)"})],-1)),Nk=[vk,Sk],Tk=Vn(()=>Ne("svg",{fill:"none",height:"15",viewBox:"0 0 14 15",width:"14",xmlns:"http://www.w3.org/2000/svg"},[Ne("circle",{cx:"7",cy:"7.5",opacity:"0.7",r:"6.5",stroke:"var(--c)"})],-1)),Ek=Vn(()=>Ne("svg",{class:"now",fill:"none",height:"25",viewBox:"0 0 24 25",width:"24",xmlns:"http://www.w3.org/2000/svg"},[Ne("circle",{cx:"12",cy:"12.5",fill:"var(--c)",opacity:"0.7",r:"6.5",stroke:"var(--c)"})],-1)),kk=[Tk,Ek],xk=Vn(()=>Ne("svg",{fill:"none",height:"25",viewBox:"0 0 24 25",width:"24",xmlns:"http://www.w3.org/2000/svg"},[Ne("g",{opacity:"0.6"},[Ne("path",{d:"M10 18.5V6.5L3 18.5H10Z",fill:"var(--c)",stroke:"var(--c)","stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"1.5"}),Ne("path",{d:"M14 18.5V6.5L21 18.5H14Z",stroke:"var(--c)","stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"1.5"})])],-1)),_k=[xk],$k=Zm('<svg fill="none" height="25" viewBox="0 0 24 25" width="24" xmlns="http://www.w3.org/2000/svg" data-v-0641bf1a><g opacity="0.6" data-v-0641bf1a><circle cx="9" cy="10.5" r="1" fill="var(--c)" data-v-0641bf1a></circle><circle cx="15" cy="10.5" r="1" fill="var(--c)" data-v-0641bf1a></circle><path d="M19.5448 9.83333C19.8396 10.6674 20 11.565 20 12.5C20 16.9183 16.4183 20.5 12 20.5C7.58172 20.5 4 16.9183 4 12.5C4 8.08172 7.58172 4.5 12 4.5C12.935 4.5 13.8326 4.66041 14.6667 4.95522" stroke="var(--c)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-v-0641bf1a></path><path d="M15.2427 14.7427C13.5858 16.3995 10.8995 16.3995 9.24268 14.7427" stroke="var(--c)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-v-0641bf1a></path><path fill-rule="evenodd" clip-rule="evenodd" d="M17.5 4.5C18.0509 5.90137 18.5605 6.48753 20 7C18.5605 7.51247 18.0509 8.09863 17.5 9.5C16.9875 8.06046 16.4014 7.55095 15 7C16.4014 6.44905 16.9875 5.93954 17.5 4.5Z" fill="var(--c)" data-v-0641bf1a></path></g></svg>',1),Ak=[$k],Ik=Vn(()=>Ne("svg",{fill:"none",height:"25",viewBox:"0 0 24 25",width:"24",xmlns:"http://www.w3.org/2000/svg"},[Ne("g",{opacity:"0.6"},[Ne("path",{d:"M19 5.5H12.875M19 5.5L5 19.5M19 5.5V11.625M5 19.5V13.375M5 19.5H11.125M5 13.375V10.75V8.5C5 6.84315 6.34315 5.5 8 5.5H10.25H12.875M5 13.375L12.875 5.5M19 11.625L11.125 19.5M19 11.625V14.25V16.5C19 18.1569 17.6569 19.5 16 19.5H13.75H11.125",stroke:"var(--c)","stroke-width":"1.5","stroke-linecap":"round","stroke-linejoin":"round"})])],-1)),Ok=[Ik],Dk=Vn(()=>Ne("svg",{fill:"none",height:"25",viewBox:"0 0 24 25",width:"24",xmlns:"http://www.w3.org/2000/svg"},[Ne("g",{opacity:"0.6"},[Ne("path",{d:"M16 8.5L8 16.5",stroke:"var(--c)","stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"1.5"}),Ne("path",{d:"M16 16.5L8 8.5",stroke:"var(--c)","stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"1.5"})])],-1)),Fk=[Dk];function Ck(t,e){return Km(),Hm("main",{ref:"main",class:Hn({err:t.err!=!1})},[Ne("h3",null,Gm(t.err),1),Ne("video",bk,null,512),Ne("canvas",wk,null,512),Ne("nav",null,[Ne("a",{class:Hn(["circle",{now:t.size<=250}]),onClick:e[0]||(e[0]=n=>t.w(204))},Nk,2),Ne("a",{class:Hn(["circle",{now:t.size>=310}]),onClick:e[1]||(e[1]=n=>t.w(324))},kk,2),Ne("a",{class:Hn({mirror:t.mirror}),onClick:e[2]||(e[2]=(...n)=>t.turn&&t.turn(...n))},_k,2),Ne("a",{class:Hn({beauty:t.beauty}),onClick:e[3]||(e[3]=(...n)=>t.makeup&&t.makeup(...n))},Ak,2),Ne("a",{class:Hn({background:t.background}),onClick:e[4]||(e[4]=(...n)=>t.blur&&t.blur(...n))},Ok,2),Ne("a",{onClick:e[5]||(e[5]=(...n)=>t.x&&t.x(...n))},Fk)])],2)}var Wk=Jm(yk,[["render",Ck],["__scopeId","data-v-0641bf1a"]]);export{Wk as default};
