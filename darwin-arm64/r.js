import{s as tn,o as Um,k as qm,l as Wm,a as ma,t as Hm,F as Gm,e as Ee,m as Hn,d as ga,p as Km,i as Xm,q as Ym,_ as Zm}from"./d.js";import{c as Gn}from"./i.js";import{g as Jm,m as Qm,a as eg}from"./e.js";import{i as tg}from"./1.js";import{d as ng}from"./a.js";import{c as Bt}from"./o.js";import"./x.js";import"./..js";import"./-.js";import"./q.js";function rg(t,e){return e.forEach(function(n){n&&typeof n!="string"&&!Array.isArray(n)&&Object.keys(n).forEach(function(r){if(r!=="default"&&!(r in t)){var s=Object.getOwnPropertyDescriptor(n,r);Object.defineProperty(t,r,s.get?s:{enumerable:!0,get:function(){return n[r]}})}})}),Object.freeze(Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}))}var sg=t=>new Promise(e=>setTimeout(e,t));const ag=1e-7,og=1e-4;class ig{constructor(e,n){this.backend=e,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,n){this.dataIdsCount++,this.data.set(e,n)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Bu{refCount(e){return ut("refCount")}incRef(e){return ut("incRef")}timerAvailable(){return!0}time(e){return ut("time")}read(e){return ut("read")}readSync(e){return ut("readSync")}readToGPU(e,n){return ut("readToGPU")}numDataIds(){return ut("numDataIds")}disposeData(e,n){return ut("disposeData")}write(e,n,r){return ut("write")}move(e,n,r,s,a){return ut("move")}memory(){return ut("memory")}floatPrecision(){return ut("floatPrecision")}epsilon(){return this.floatPrecision()===32?ag:og}dispose(){return ut("dispose")}}function ut(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Lu(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,vs(t,e,n)}function ug(t,e){if(t.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${t.length}Second array length was ${e.length}`);let n=t.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,vs(t,n,r),vs(e,n,r)}function xr(t,e,n){return Math.max(t,Math.min(e,n))}function lg(t){return t%2===0?t:t+1}function vs(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function cg(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function hg(t,e){const n=Math.random();return e*n+(1-n)*t}function fg(t,e){let n=0;for(let r=0;r<t.length;r++){const s=Number(t[r])-Number(e[r]);n+=s*s}return n}function N(t,e){if(!t)throw new Error(typeof e=="string"?e:e())}function Je(t,e,n=""){N(zt(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function Bn(t){N(t!=null,()=>"The input to the tensor constructor must be a non-null value.")}function $n(t,e=[],n=!1){if(e==null&&(e=[]),Array.isArray(t)||Ue(t)&&!n)for(let r=0;r<t.length;++r)$n(t[r],e,n);else e.push(t);return e}function $e(t){if(t.length===0)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function pg(t){return t.length===0}function zt(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function nr(t){return t%1===0}function dg(t){if(Math.tanh!=null)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const e=Math.exp(2*t);return(e-1)/(e+1)}}function mg(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function gg(t){const e=new Uint32Array(t);for(let n=0;n<t;++n)e[n]=n;return Lu(e),e}function kr(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function yg(t,e=r=>0,n){return new Promise((r,s)=>{let a=0;const o=()=>{if(t()){r();return}a++;const i=e(a);if(n!=null&&a>=n){s();return}setTimeout(o,i)};o()})}function bg(t,e){let n=1,r=-1;for(let a=0;a<t.length;++a)if(t[a]>=0)n*=t[a];else if(t[a]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(t[a]<0)throw Error(`Shapes can not be < 0. Found ${t[a]} at dim ${a}`);if(r===-1){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(n===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const s=t.slice();return s[r]=e/n,s}function Mr(t,e){const n=e.length;return t=t==null?e.map((r,s)=>s):[].concat(t),N(t.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),N(t.every(r=>nr(r)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(r=>r<0?n+r:r)}function Mu(t,e){const n=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,a=e==null||s?null:Mr(e,t).sort();let o=0;for(let i=0;i<t.length;++i){if(a!=null){if(a[o]===i&&t[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${t[i]}' is not 1`);(a[o]==null||a[o]>i)&&t[i]===1&&(n.push(t[i]),r.push(i)),a[o]<=i&&o++}t[i]!==1&&(n.push(t[i]),r.push(i))}return{newShape:n,keptDims:r}}function zu(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else throw new Error(`Unknown data type ${t}`);return n}function Vu(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else if(t==="string")n=new Array(e);else throw new Error(`Unknown data type ${t}`);return n}function ju(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function Uu(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function wg(t,e){return!(e==="complex64"||e==="float32"&&t!=="complex64"||e==="int32"&&t!=="float32"&&t!=="complex64"||e==="bool"&&t==="bool")}function Ue(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}function Aa(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function qu(t){if(t==null)return 0;let e=0;return t.forEach(n=>e+=n.length),e}function an(t){return typeof t=="string"||t instanceof String}function Wu(t){return typeof t=="boolean"}function Hu(t){return typeof t=="number"}function Rs(t){return Array.isArray(t)?Rs(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":Hu(t)?"float32":an(t)?"string":Wu(t)?"bool":"float32"}function cn(t){return!!(t&&t.constructor&&t.call&&t.apply)}function Ss(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function cr(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function Gu(t,e,n,r=!1){const s=new Array;if(e.length===1){const a=e[0]*(r?2:1);for(let o=0;o<a;o++)s[o]=n[t+o]}else{const a=e[0],o=e.slice(1),i=o.reduce((u,l)=>u*l)*(r?2:1);for(let u=0;u<a;u++)s[u]=Gu(t+u*i,o,n,r)}return s}function En(t,e,n=!1){if(t.length===0)return e[0];const r=t.reduce((s,a)=>s*a)*(n?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return Gu(0,t,e,n)}function ho(t,e){const n=Cs(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function Cs(t,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function vg(t,e){const n=t.reduce((r,s)=>r*s,1);if(e==null||e==="float32")return En(t,new Float32Array(n));if(e==="int32")return En(t,new Int32Array(n));if(e==="bool")return En(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function fo(t){t.forEach(e=>{N(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function Sg(t,e,n){if(e===0)return 0;if(e===1)return t[0];let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=n[s]*t[s];return r}function Ng(t,e,n){if(e===0)return[];if(e===1)return[t];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(t/n[s]),t-=r[s]*n[s];return r[r.length-1]=t,r}function An(t){return t&&t.then&&typeof t.then=="function"}const Wi="tfjsflags";class Ku{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Tg,this.populateURLFlags()}setPlatform(e,n){this.platform!=null&&(re().getBool("IS_TEST")||re().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=n}registerFlag(e,n,r){if(this.flagRegistry[e]={evaluationFn:n,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];re().getBool("IS_TEST")||re().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const n=this.evaluateFlag(e);if(An(n))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=n,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,n){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=n,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(n)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);Wi in e&&e[Wi].split(",").forEach(r=>{const[s,a]=r.split(":");this.urlFlags[s]=kg(s,a)})}}function Tg(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(Eg(e,r[0],r[1]),r.join("="))),e}function Eg(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function kg(t,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}function re(){return po}let po=null;function _g(t){po=t}let ya;function Xu(){if(ya==null){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else if(typeof self<"u")t=self;else throw new Error("Could not find a global object");ya=t}return ya}function xg(){const t=Xu();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function mo(t,e){const n=xg();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const Yu="Abs",Zu="Acos",Ju="Acosh",go="Add",Qu="AddN",el="All",tl="Any",nl="ArgMax",rl="ArgMin",sl="Asin",al="Asinh",ol="Atan",il="Atanh",ul="Atan2",ll="AvgPool",$g="AvgPoolGrad",cl="AvgPool3D",Ag="AvgPool3DGrad",hl="BatchMatMul",fl="BatchToSpaceND",pl="Bincount",Ig="BroadcastTo",dl="BroadcastArgs",yo="Cast",ml="Ceil",gl="ClipByValue",yl="Complex",bl="ComplexAbs",wl="Concat",vl="Conv2D",Sl="Conv2DBackpropFilter",Nl="Conv2DBackpropInput",Tl="Conv3D",Og="Conv3DBackpropFilterV2",El="Conv3DBackpropInputV2",kl="Cos",_l="Cosh",xl="Cumprod",$l="Cumsum",Al="CropAndResize",Il="DenseBincount",Ol="DepthToSpace",Dl="DepthwiseConv2dNative",Fl="DepthwiseConv2dNativeBackpropFilter",Pl="DepthwiseConv2dNativeBackpropInput",Rl="Diag",Cl="Dilation2D",Dg="Dilation2DBackpropInput",Fg="Dilation2DBackpropFilter",Bl="RealDiv",Ll="Einsum",Ml="Elu",Pg="EluGrad",zl="Erf",Vl="Equal",jl="Exp",Ul="ExpandDims",ql="Expm1",Wl="FFT",Hl="Fill",Gl="FlipLeftRight",Kl="Floor",Xl="FloorDiv",Yl="FusedBatchNorm",Zl="GatherV2",Jl="GatherNd",Ql="Greater",ec="GreaterEqual",bo="Identity",tc="IFFT",nc="Imag",rc="IsFinite",sc="IsInf",ac="IsNan",oc="LeakyRelu",ic="Less",uc="LessEqual",lc="LinSpace",cc="Log",hc="Log1p",fc="LogicalAnd",pc="LogicalNot",dc="LogicalOr",Rg="LogicalXor",Cg="LogSoftmax",Bg="LowerBound",mc="LRN",Lg="LRNGrad",gc="Max",yc="Maximum",bc="MaxPool",Mg="MaxPoolGrad",wc="MaxPool3D",zg="MaxPool3DGrad",vc="MaxPoolWithArgmax",Sc="Mean",Nc="Min",Tc="Minimum",Ec="MirrorPad",kc="Mod",_c="Multinomial",xc="Multiply",$c="Neg",Ac="NotEqual",Ic="NonMaxSuppressionV3",Oc="NonMaxSuppressionV4",Dc="NonMaxSuppressionV5",Fc="OnesLike",Pc="OneHot",Rc="Pack",Cc="PadV2",Vg="Pool",Bc="Pow",Lc="Prelu",Mc="Prod",zc="Range",Vc="Real",jc="Reciprocal",Uc="Relu",qc="Reshape",Wc="ResizeNearestNeighbor",jg="ResizeNearestNeighborGrad",Hc="ResizeBilinear",Ug="ResizeBilinearGrad",Gc="Relu6",Kc="Reverse",Xc="Round",Yc="Rsqrt",Zc="ScatterNd",Jc="SearchSorted",Qc="Select",eh="Selu",th="Slice",nh="Sin",rh="Sinh",sh="Sign",ah="Sigmoid",oh="Softplus",ih="Sqrt",uh="Sum",lh="SpaceToBatchND",ch="SplitV",hh="Softmax",fh="SparseFillEmptyRows",ph="SparseReshape",dh="SparseSegmentMean",mh="SparseSegmentSum",gh="SparseToDense",yh="SquaredDifference",qg="Square",bh="StridedSlice",wh="StringNGrams",vh="StringSplit",Sh="StringToHashBucketFast",Nh="Sub",Th="Tan",Eh="Tanh",wo="Tile",kh="TopK",_h="Transform",gs="Transpose",xh="Unique",$h="Unpack",Ah="UnsortedSegmentSum",Wg="UpperBound",Ih="ZerosLike",Oh="Step",Ia="FromPixels",Dh="RotateWithOffset",Oa="_FusedMatMul",Da="FusedConv2D",Fa="FusedDepthwiseConv2D";function rn(...t){re().getBool("IS_TEST")||re().getBool("PROD")||console.warn(...t)}function Hg(...t){re().getBool("IS_TEST")||re().getBool("PROD")||console.log(...t)}const rr=mo("kernelRegistry",()=>new Map),$r=mo("gradRegistry",()=>new Map);function Ns(t,e){const n=vo(t,e);return rr.get(n)}function Pa(t){return $r.get(t)}function Ts(t){const e=rr.entries(),n=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[a,o]=s,[i]=a.split("_");i===t&&n.push(o)}return n}function Fh(t){const{kernelName:e,backendName:n}=t,r=vo(e,n);rr.has(r)&&rn(`The kernel '${e}' for backend '${n}' is already registered`),rr.set(r,t)}function Gg(t){const{kernelName:e}=t;$r.has(e)&&re().getBool("DEBUG")&&rn(`Overriding the gradient for '${e}'`),$r.set(e,t)}function Kg(t,e){const n=vo(t,e);if(!rr.has(n))throw new Error(`The kernel '${t}' for backend '${e}' is not registered`);rr.delete(n)}function Xg(t){if(!$r.has(t))throw new Error(`The gradient '${t}' for backend is not registered`);$r.delete(t)}function Yg(t,e){Ts(t).forEach(r=>{const s=Object.assign({},r,{backendName:e});Fh(s)})}function vo(t,e){return`${e}_${t}`}var Ra=Ae,ft=null;try{ft=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Ae(t,e,n){this.low=t|0,this.high=e|0,this.unsigned=!!n}Ae.prototype.__isLong__;Object.defineProperty(Ae.prototype,"__isLong__",{value:!0});function it(t){return(t&&t.__isLong__)===!0}Ae.isLong=it;var Hi={},Gi={};function Ln(t,e){var n,r,s;return e?(t>>>=0,(s=0<=t&&t<256)&&(r=Gi[t],r)?r:(n=Ie(t,(t|0)<0?-1:0,!0),s&&(Gi[t]=n),n)):(t|=0,(s=-128<=t&&t<128)&&(r=Hi[t],r)?r:(n=Ie(t,t<0?-1:0,!1),s&&(Hi[t]=n),n))}Ae.fromInt=Ln;function pt(t,e){if(isNaN(t))return e?Nn:dt;if(e){if(t<0)return Nn;if(t>=Ph)return Bh}else{if(t<=-Xi)return at;if(t+1>=Xi)return Ch}return t<0?pt(-t,e).neg():Ie(t%sr|0,t/sr|0,e)}Ae.fromNumber=pt;function Ie(t,e,n){return new Ae(t,e,n)}Ae.fromBits=Ie;var Es=Math.pow;function So(t,e,n){if(t.length===0)throw Error("empty string");if(t==="NaN"||t==="Infinity"||t==="+Infinity"||t==="-Infinity")return dt;if(typeof e=="number"?(n=e,e=!1):e=!!e,n=n||10,n<2||36<n)throw RangeError("radix");var r;if((r=t.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return So(t.substring(1),e,n).neg();for(var s=pt(Es(n,8)),a=dt,o=0;o<t.length;o+=8){var i=Math.min(8,t.length-o),u=parseInt(t.substring(o,o+i),n);if(i<8){var l=pt(Es(n,i));a=a.mul(l).add(pt(u))}else a=a.mul(s),a=a.add(pt(u))}return a.unsigned=e,a}Ae.fromString=So;function It(t,e){return typeof t=="number"?pt(t,e):typeof t=="string"?So(t,e):Ie(t.low,t.high,typeof e=="boolean"?e:t.unsigned)}Ae.fromValue=It;var Ki=1<<16,Zg=1<<24,sr=Ki*Ki,Ph=sr*sr,Xi=Ph/2,Yi=Ln(Zg),dt=Ln(0);Ae.ZERO=dt;var Nn=Ln(0,!0);Ae.UZERO=Nn;var Jn=Ln(1);Ae.ONE=Jn;var Rh=Ln(1,!0);Ae.UONE=Rh;var Ca=Ln(-1);Ae.NEG_ONE=Ca;var Ch=Ie(-1,2147483647,!1);Ae.MAX_VALUE=Ch;var Bh=Ie(-1,-1,!0);Ae.MAX_UNSIGNED_VALUE=Bh;var at=Ie(0,-2147483648,!1);Ae.MIN_VALUE=at;var q=Ae.prototype;q.toInt=function(){return this.unsigned?this.low>>>0:this.low};q.toNumber=function(){return this.unsigned?(this.high>>>0)*sr+(this.low>>>0):this.high*sr+(this.low>>>0)};q.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(at)){var n=pt(e),r=this.div(n),s=r.mul(n).sub(this);return r.toString(e)+s.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var a=pt(Es(e,6),this.unsigned),o=this,i="";;){var u=o.div(a),l=o.sub(u.mul(a)).toInt()>>>0,c=l.toString(e);if(o=u,o.isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}};q.getHighBits=function(){return this.high};q.getHighBitsUnsigned=function(){return this.high>>>0};q.getLowBits=function(){return this.low};q.getLowBitsUnsigned=function(){return this.low>>>0};q.getNumBitsAbs=function(){if(this.isNegative())return this.eq(at)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,n=31;n>0&&(e&1<<n)==0;n--);return this.high!=0?n+33:n+1};q.isZero=function(){return this.high===0&&this.low===0};q.eqz=q.isZero;q.isNegative=function(){return!this.unsigned&&this.high<0};q.isPositive=function(){return this.unsigned||this.high>=0};q.isOdd=function(){return(this.low&1)===1};q.isEven=function(){return(this.low&1)===0};q.equals=function(e){return it(e)||(e=It(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};q.eq=q.equals;q.notEquals=function(e){return!this.eq(e)};q.neq=q.notEquals;q.ne=q.notEquals;q.lessThan=function(e){return this.comp(e)<0};q.lt=q.lessThan;q.lessThanOrEqual=function(e){return this.comp(e)<=0};q.lte=q.lessThanOrEqual;q.le=q.lessThanOrEqual;q.greaterThan=function(e){return this.comp(e)>0};q.gt=q.greaterThan;q.greaterThanOrEqual=function(e){return this.comp(e)>=0};q.gte=q.greaterThanOrEqual;q.ge=q.greaterThanOrEqual;q.compare=function(e){if(it(e)||(e=It(e)),this.eq(e))return 0;var n=this.isNegative(),r=e.isNegative();return n&&!r?-1:!n&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};q.comp=q.compare;q.negate=function(){return!this.unsigned&&this.eq(at)?at:this.not().add(Jn)};q.neg=q.negate;q.add=function(e){it(e)||(e=It(e));var n=this.high>>>16,r=this.high&65535,s=this.low>>>16,a=this.low&65535,o=e.high>>>16,i=e.high&65535,u=e.low>>>16,l=e.low&65535,c=0,h=0,p=0,m=0;return m+=a+l,p+=m>>>16,m&=65535,p+=s+u,h+=p>>>16,p&=65535,h+=r+i,c+=h>>>16,h&=65535,c+=n+o,c&=65535,Ie(p<<16|m,c<<16|h,this.unsigned)};q.subtract=function(e){return it(e)||(e=It(e)),this.add(e.neg())};q.sub=q.subtract;q.multiply=function(e){if(this.isZero())return dt;if(it(e)||(e=It(e)),ft){var n=ft.mul(this.low,this.high,e.low,e.high);return Ie(n,ft.get_high(),this.unsigned)}if(e.isZero())return dt;if(this.eq(at))return e.isOdd()?at:dt;if(e.eq(at))return this.isOdd()?at:dt;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(Yi)&&e.lt(Yi))return pt(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,s=this.high&65535,a=this.low>>>16,o=this.low&65535,i=e.high>>>16,u=e.high&65535,l=e.low>>>16,c=e.low&65535,h=0,p=0,m=0,b=0;return b+=o*c,m+=b>>>16,b&=65535,m+=a*c,p+=m>>>16,m&=65535,m+=o*l,p+=m>>>16,m&=65535,p+=s*c,h+=p>>>16,p&=65535,p+=a*l,h+=p>>>16,p&=65535,p+=o*u,h+=p>>>16,p&=65535,h+=r*c+s*l+a*u+o*i,h&=65535,Ie(m<<16|b,h<<16|p,this.unsigned)};q.mul=q.multiply;q.divide=function(e){if(it(e)||(e=It(e)),e.isZero())throw Error("division by zero");if(ft){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var n=(this.unsigned?ft.div_u:ft.div_s)(this.low,this.high,e.low,e.high);return Ie(n,ft.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Nn:dt;var r,s,a;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Nn;if(e.gt(this.shru(1)))return Rh;a=Nn}else{if(this.eq(at)){if(e.eq(Jn)||e.eq(Ca))return at;if(e.eq(at))return Jn;var o=this.shr(1);return r=o.div(e).shl(1),r.eq(dt)?e.isNegative()?Jn:Ca:(s=this.sub(e.mul(r)),a=r.add(s.div(e)),a)}else if(e.eq(at))return this.unsigned?Nn:dt;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=dt}for(s=this;s.gte(e);){r=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(r)/Math.LN2),u=i<=48?1:Es(2,i-48),l=pt(r),c=l.mul(e);c.isNegative()||c.gt(s);)r-=u,l=pt(r,this.unsigned),c=l.mul(e);l.isZero()&&(l=Jn),a=a.add(l),s=s.sub(c)}return a};q.div=q.divide;q.modulo=function(e){if(it(e)||(e=It(e)),ft){var n=(this.unsigned?ft.rem_u:ft.rem_s)(this.low,this.high,e.low,e.high);return Ie(n,ft.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};q.mod=q.modulo;q.rem=q.modulo;q.not=function(){return Ie(~this.low,~this.high,this.unsigned)};q.and=function(e){return it(e)||(e=It(e)),Ie(this.low&e.low,this.high&e.high,this.unsigned)};q.or=function(e){return it(e)||(e=It(e)),Ie(this.low|e.low,this.high|e.high,this.unsigned)};q.xor=function(e){return it(e)||(e=It(e)),Ie(this.low^e.low,this.high^e.high,this.unsigned)};q.shiftLeft=function(e){return it(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Ie(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Ie(0,this.low<<e-32,this.unsigned)};q.shl=q.shiftLeft;q.shiftRight=function(e){return it(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Ie(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Ie(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};q.shr=q.shiftRight;q.shiftRightUnsigned=function(e){if(it(e)&&(e=e.toInt()),e&=63,e===0)return this;var n=this.high;if(e<32){var r=this.low;return Ie(r>>>e|n<<32-e,n>>>e,this.unsigned)}else return e===32?Ie(n,0,this.unsigned):Ie(n>>>e-32,0,this.unsigned)};q.shru=q.shiftRightUnsigned;q.shr_u=q.shiftRightUnsigned;q.toSigned=function(){return this.unsigned?Ie(this.low,this.high,!1):this};q.toUnsigned=function(){return this.unsigned?this:Ie(this.low,this.high,!0)};q.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};q.toBytesLE=function(){var e=this.high,n=this.low;return[n&255,n>>>8&255,n>>>16&255,n>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};q.toBytesBE=function(){var e=this.high,n=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,n>>>24,n>>>16&255,n>>>8&255,n&255]};Ae.fromBytes=function(e,n,r){return r?Ae.fromBytesLE(e,n):Ae.fromBytesBE(e,n)};Ae.fromBytesLE=function(e,n){return new Ae(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,n)};Ae.fromBytesBE=function(e,n){return new Ae(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],n)};var Jg=rg({__proto__:null,default:Ra},[Ra]);const Sn=Ra||Jg;function zr(t){return Sn.fromString(t,!0,16)}const Lh=zr("c3a5c85c97cb3127"),vn=zr("b492b66fbe98f273"),Xe=zr("9ae16a3b2f90404f");function Ba(t){return t.xor(t.shru(47))}function Mh(t,e,n){const r=t.slice(e,e+n);return Sn.fromBytes(Array.from(r),!0,!0)}function _e(t,e){return Mh(t,e,8)}function Zi(t,e){return Mh(t,e,4)}function Me(t,e){return e===0?t:t.shru(e).or(t.shl(64-e))}function ln(t,e,n=zr("9ddfea08eb382d69")){let r=t.xor(e).mul(n);r=r.xor(r.shru(47));let s=e.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function Qg(t,e,n,r,s,a){s=s.add(t),a=Me(a.add(s).add(r),21);const o=s;return s=s.add(e),s=s.add(n),a=a.add(Me(s,44)),[s.add(r),a.add(o)]}function os(t,e,n,r){return Qg(_e(t,e),_e(t,e+8),_e(t,e+16),_e(t,e+24),n,r)}function ey(t,e=t.length){if(e>=8){const n=Xe.add(e*2),r=_e(t,0).add(Xe),s=_e(t,e-8),a=Me(s,37).mul(n).add(r),o=Me(r,25).add(s).mul(n);return ln(a,o,n)}if(e>=4){const n=Xe.add(e*2),r=Zi(t,0);return ln(r.shl(3).add(e),Zi(t,e-4),n)}if(e>0){const n=t[0],r=t[e>>1],s=t[e-1],a=n+(r<<8),o=e+(s<<2);return Ba(Xe.mul(a).xor(Lh.mul(o))).mul(Xe)}return Xe}function ty(t,e=t.length){const n=Xe.add(e*2),r=_e(t,0).mul(vn),s=_e(t,8),a=_e(t,e-8).mul(n),o=_e(t,e-16).mul(Xe);return ln(Me(r.add(s),43).add(Me(a,30)).add(o),r.add(Me(s.add(Xe),18)).add(a),n)}function ny(t,e=t.length){const n=Xe.add(e*2),r=_e(t,0).mul(Xe),s=_e(t,8),a=_e(t,e-8).mul(n),o=_e(t,e-16).mul(Xe),i=Me(r.add(s),43).add(Me(a,30)).add(o),u=ln(i,r.add(Me(s.add(Xe),18)).add(a),n),l=_e(t,16).mul(n),c=_e(t,24),h=i.add(_e(t,e-32)).mul(n),p=u.add(_e(t,e-24)).mul(n);return ln(Me(l.add(c),43).add(Me(h,30)).add(p),l.add(Me(c.add(r),18)).add(h),n)}function ry(t,e=t.length){const n=Sn.fromNumber(81,!0);if(e<=32)return e<=16?ey(t,e):ty(t,e);if(e<=64)return ny(t,e);let r=n,s=n.mul(vn).add(113),a=Ba(s.mul(Xe).add(113)).mul(Xe),o=[Sn.UZERO,Sn.UZERO],i=[Sn.UZERO,Sn.UZERO];r=r.mul(Xe).add(_e(t,0));let u=0;const l=(e-1>>6)*64,c=l+(e-1&63)-63;do r=Me(r.add(s).add(o[0]).add(_e(t,u+8)),37).mul(vn),s=Me(s.add(o[1]).add(_e(t,u+48)),42).mul(vn),r=r.xor(i[1]),s=s.add(o[0]).add(_e(t,u+40)),a=Me(a.add(i[0]),33).mul(vn),o=os(t,u,o[1].mul(vn),r.add(i[0])),i=os(t,u+32,a.add(i[1]),s.add(_e(t,u+16))),[a,r]=[r,a],u+=64;while(u!==l);const h=vn.add(a.and(255).shl(1));return u=c,i[0]=i[0].add(e-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),r=Me(r.add(s).add(o[0]).add(_e(t,u+8)),37).mul(h),s=Me(s.add(o[1]).add(_e(t,u+48)),42).mul(h),r=r.xor(i[1].mul(9)),s=s.add(o[0].mul(9).add(_e(t,u+40))),a=Me(a.add(i[0]),33).mul(h),o=os(t,u,o[1].mul(h),r.add(i[0])),i=os(t,u+32,a.add(i[1]),s.add(_e(t,u+16))),[a,r]=[r,a],ln(ln(o[0],i[0],h).add(Ba(s).mul(Lh)).add(a),ln(o[1],i[1],h).add(r),h)}function sy(t,e){return e==="string"?Vr(t):Bs([t],e)}function ay(t,e){return t instanceof Float32Array&&e==="float32"||t instanceof Int32Array&&e==="int32"||t instanceof Uint8Array&&e==="bool"}function Bs(t,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=$n(t)),re().getBool("DEBUG")&&ju(t,e),ay(t,e))return t;if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool"){const n=new Uint8Array(t.length);for(let r=0;r<n.length;++r)Math.round(t[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${e}`)}function Ar(){return re().platform.now()}function oy(t,e){return re().platform.fetch(t,e)}function Vr(t,e="utf-8"){return e=e||"utf-8",re().platform.encode(t,e)}function ks(t,e="utf-8"){return e=e||"utf-8",re().platform.decode(t,e)}var iy=Object.freeze(Object.defineProperty({__proto__:null,createScalarValue:sy,toTypedArray:Bs,now:Ar,fetch:oy,encodeString:Vr,decodeString:ks,shuffle:Lu,shuffleCombo:ug,clamp:xr,nearestLargerEven:lg,swap:vs,sum:cg,randUniform:hg,distSquared:fg,assert:N,assertShapesMatch:Je,assertNonNull:Bn,flatten:$n,sizeFromShape:$e,isScalarShape:pg,arraysEqual:zt,isInt:nr,tanh:dg,sizeToSquarishShape:mg,createShuffledIndices:gg,rightPad:kr,repeatedTry:yg,inferFromImplicitShape:bg,parseAxisParam:Mr,squeezeShape:Mu,getTypedArrayFromDType:zu,getArrayFromDType:Vu,checkConversionForErrors:ju,isValidDtype:Uu,hasEncodingLoss:wg,isTypedArray:Ue,bytesPerElement:Aa,bytesFromStringArray:qu,isString:an,isBoolean:Wu,isNumber:Hu,inferDtype:Rs,isFunction:cn,nearestDivisor:Ss,computeStrides:cr,toNestedArray:En,makeOnesTypedArray:ho,makeZerosTypedArray:Cs,makeZerosNestedTypedArray:vg,assertNonNegativeIntegerDimensions:fo,locToIndex:Sg,indexToLoc:Ng,isPromise:An,hexToLong:zr,fingerPrint64:ry},Symbol.toStringTag,{value:"Module"}));class uy{constructor(e,n){this.backendTimer=e,this.logger=n,n==null&&(this.logger=new cy)}profileKernel(e,n,r){let s;const a=()=>{s=r()};let o;const i=Ar();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(a);else{a();for(const l of s)l.dataSync();o=Promise.resolve({kernelMs:Ar()-i})}if(re().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<s.length;l++){const c=s[l];c.data().then(h=>{ly(h,c.dtype,e)})}return{kernelName:e,outputs:s,inputs:n,timeMs:o.then(l=>l.kernelMs),extraInfo:o.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:n,outputs:r,timeMs:s,inputs:a,extraInfo:o}=e;r.forEach(i=>{Promise.all([i.data(),s,o]).then(u=>{this.logger.logKernelProfile(n,i,u[0],u[1],a,u[2])})})}}function ly(t,e,n){if(e!=="float32")return!1;for(let r=0;r<t.length;r++){const s=t[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}class cy{logKernelProfile(e,n,r,s,a,o){const i=typeof s=="number"?kr(`${s}ms`,9):s.error,u=kr(e,25),l=n.rank,c=n.size,h=kr(n.shape.toString(),14);let p="";for(const m in a){const b=a[m];if(b!=null){const v=b.shape||n.shape,S=v.length;p+=`${m}: ${S}D ${S>0?v:""} `}}console.log(`%c${u}	%c${i}	%c${l}D ${h}	%c${c}	%c${p}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function hy(t,e,n){const r={},s={};for(let u=0;u<e.length;u++)r[e[u].id]=!0;for(let u=0;u<t.length;u++){const l=t[u],c=l.inputs;for(const h in c){const p=c[h];let m=!1;for(let b=0;b<e.length;b++)if(r[p.id]){l.outputs.forEach(v=>r[v.id]=!0),m=!0,s[l.id]=!0;break}if(m)break}}const a={};a[n.id]=!0;const o={};for(let u=t.length-1;u>=0;u--){const l=t[u],c=l.inputs;for(let h=0;h<l.outputs.length;h++)if(a[l.outputs[h].id]){for(const p in c)a[c[p].id]=!0,o[l.id]=!0;break}}const i=[];for(let u=0;u<t.length;u++){const l=t[u];if(s[l.id]&&o[l.id]){const c={};for(const p in l.inputs){const m=l.inputs[p];r[m.id]&&(c[p]=m)}const h=Object.assign({},l);h.inputs=c,h.outputs=l.outputs,i.push(h)}}return i}function fy(t,e,n,r){for(let s=e.length-1;s>=0;s--){const a=e[s],o=[];if(a.outputs.forEach(u=>{const l=t[u.id];l!=null?o.push(l):o.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const i=a.gradient(o);for(const u in a.inputs){if(!(u in i))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(i)}.`);const l=n(()=>i[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);const c=a.inputs[u];if(!zt(l.shape,c.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${c.shape}'`);if(t[c.id]==null)t[c.id]=l;else{const h=t[c.id];t[c.id]=r(h,l),h.dispose()}}}}const Ji=20,br=3,ba=7;function py(t,e,n,r){const s=cr(e),a=dy(t,e,n,s),o=e.length,i=ys(t,e,n,s,a),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${o}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(i.map(l=>"    "+l).join(`
`)),u.join(`
`)}function dy(t,e,n,r){const s=$e(e),a=r[r.length-1],o=new Array(a).fill(0),i=e.length,u=n==="complex64"?Nr(t):t;if(i>1)for(let l=0;l<s/a;l++){const c=l*a;for(let h=0;h<a;h++)o[h]=Math.max(o[h],Sr(u[c+h],0,n).length)}return o}function Sr(t,e,n){let r;return Array.isArray(t)?r=`${parseFloat(t[0].toFixed(ba))} + ${parseFloat(t[1].toFixed(ba))}j`:an(t)?r=`'${t}'`:n==="bool"?r=zh(t):r=parseFloat(t.toFixed(ba)).toString(),kr(r,e)}function zh(t){return t===0?"false":"true"}function ys(t,e,n,r,s,a=!0){const o=n==="complex64"?2:1,i=e[0],u=e.length;if(u===0){if(n==="complex64"){const v=Nr(t);return[Sr(v[0],0,n)]}return n==="bool"?[zh(t[0])]:[t[0].toString()]}if(u===1){if(i>Ji){const S=br*o;let x=Array.from(t.slice(0,S)),O=Array.from(t.slice((i-br)*o,i*o));return n==="complex64"&&(x=Nr(x),O=Nr(O)),["["+x.map((E,$)=>Sr(E,s[$],n)).join(", ")+", ..., "+O.map((E,$)=>Sr(E,s[i-br+$],n)).join(", ")+"]"]}const v=n==="complex64"?Nr(t):Array.from(t);return["["+v.map((S,x)=>Sr(S,s[x],n)).join(", ")+"]"]}const l=e.slice(1),c=r.slice(1),h=r[0]*o,p=[];if(i>Ji){for(let v=0;v<br;v++){const S=v*h,x=S+h;p.push(...ys(t.slice(S,x),l,n,c,s,!1))}p.push("...");for(let v=i-br;v<i;v++){const S=v*h,x=S+h;p.push(...ys(t.slice(S,x),l,n,c,s,v===i-1))}}else for(let v=0;v<i;v++){const S=v*h,x=S+h;p.push(...ys(t.slice(S,x),l,n,c,s,v===i-1))}const m=u===2?",":"";p[0]="["+p[0]+m;for(let v=1;v<p.length-1;v++)p[v]=" "+p[v]+m;let b=`,
`;for(let v=2;v<u;v++)b+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(a?"":b),p}function Nr(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class _s{constructor(e,n,r){if(this.dtype=n,this.shape=e.slice(),this.size=$e(e),r!=null){const s=r.length;N(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Vu(n,this.size),this.strides=cr(e)}set(e,...n){n.length===0&&(n=[0]),N(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const r=this.locToIndex(n);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let n=0;for(const s of e){if(s<0||s>=this.shape[n]){const a=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(a)}n++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return n}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const n=new Array(this.shape.length);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(e/this.strides[r]),e-=n[r]*this.strides[r];return n[n.length-1]=e,n}get rank(){return this.shape.length}toTensor(){return $t().makeTensor(this.values,this.shape,this.dtype)}}let $t=null,Xn=null;function my(t){$t=t}function gy(t){Xn=t}class ye{constructor(e,n,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=n||"float32",this.size=$e(e),this.strides=cr(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Xn.buffer(this.shape,this.dtype,e)}bufferSync(){return Xn.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return En(this.shape,e,this.dtype==="complex64")}arraySync(){return En(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=$t().read(this.dataId);if(this.dtype==="string"){const n=await e;try{return n.map(r=>ks(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),$t().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=$t().readSync(this.dataId);if(this.dtype==="string")try{return e.map(n=>ks(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await $t().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||($t().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Xn.print(this,e)}clone(){return this.throwIfDisposed(),Xn.clone(this)}toString(e=!1){const n=this.dataSync();return py(n,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Xn.cast(this,e)}variable(e=!0,n,r){return this.throwIfDisposed(),$t().makeVariable(this,e,n,r)}}Object.defineProperty(ye,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function yy(){return mo("Tensor",()=>ye)}yy();class Ir extends ye{constructor(e,n,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=n,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!zt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);$t().disposeTensor(this),this.dataId=e.dataId,$t().incRef(this,null)}dispose(){$t().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Ir,Symbol.hasInstance,{value:t=>t instanceof ye&&t.assign!=null&&t.assign instanceof Function});var La;(function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"})(La||(La={}));var Ma;(function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"})(Ma||(Ma={}));var za;(function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"})(za||(za={}));var Va;(function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"})(Va||(Va={}));var ja;(function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"})(ja||(ja={}));const by={float32:Va,int32:Ma,bool:za,complex64:ja};function Ls(t,e){if(t==="string"||e==="string"){if(t==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return by[t][e]}function wy(t){return Ls(t,"int32")}function Pe(t,e){if(t.dtype===e.dtype)return[t,e];const n=Ls(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function Vh(t,e){N(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function vy(t,e){return e.some(n=>n.id===t.id)}function No(t){const e=[];return jh(t,e,new Set),e}function jh(t,e,n){if(t==null)return;if(t instanceof ye){e.push(t);return}if(!Sy(t))return;const r=t;for(const s in r){const a=r[s];n.has(a)||(n.add(a),jh(a,e,n))}}function Sy(t){return Array.isArray(t)||typeof t=="object"}var Ny=Object.freeze(Object.defineProperty({__proto__:null,makeTypesMatch:Pe,assertTypesMatch:Vh,isTensorInList:vy,getTensorsInContainer:No},Symbol.toStringTag,{value:"Module"}));function wa(t){return t.kernelName!=null}class Qi{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class ar{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Qi}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:n}=this.initializeBackend(e);if(n)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,n,r=1){return e in this.registryFactory?(rn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:n,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:n,asyncInit:r}=this.initializeBackend(e);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new uy(this.backendInstance),!0}setupRegisteredKernels(){Ts(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Ts(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const n=this.registryFactory[e];if(n==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=n.factory();if(r&&!(r instanceof Bu)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,a=r.then(o=>s<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,rn(`Initialization of backend ${e} failed`),rn(o.stack||o.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return rn(`Initialization of backend ${e} failed`),rn(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,n)=>this.registryFactory[n].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n],{success:s,asyncInit:a}=this.initializeBackend(r);if(a||s)return{name:r,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,n){const r=this.state.tensorInfo.get(n),s=r.backend,a=this.readSync(n),o=s.refCount(n);s.disposeData(n,!0),r.backend=e,e.move(n,a,r.shape,r.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,n){let r=null;if(n==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");n=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=n(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,n,r){e();try{const s=r();return n(),s}catch(s){throw n(),s}}nextTensorId(){return ar.nextTensorId++}nextVariableId(){return ar.nextVariableId++}clone(e){const n=_.runKernel(bo,{x:e}),r={x:e},s=o=>({x:()=>{const i="float32",u={x:o},l={dtype:i};return _.runKernel(yo,u,l)}}),a=[];return this.addTapeNode(this.state.activeScope.name,r,[n],s,a,{}),n}runKernel(e,n,r){if(this.backendName==null&&this.backend,!(Ns(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,n,r){const s=this.backend.numDataIds();let a=0;r.forEach(u=>{a+=u.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=s-n-a-o;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let n,r=[];const s=this.isTapeOn(),a=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let u;const l=wa(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(wa(e)){const{kernelName:b,inputs:v,attrs:S}=e;this.backendName==null&&this.backend;const x=Ns(b,this.backendName);N(x!=null,()=>`Cannot find registered kernel '${b}' for backend '${this.backendName}'`),i=()=>{const O=this.backend.numDataIds();u=x.kernelFunc({inputs:v,attrs:S,backend:this.backend});const E=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(b,O,E);const $=E.map(I=>I.rank!=null?I:this.makeTensorFromTensorInfo(I));if(s){const I=this.getTensorsForGradient(b,v,$);r=this.saveTensorsForBackwardMode(I)}return $}}else{const{forwardFunc:b}=e,v=S=>{!s||(r=S.map(x=>this.keep(this.clone(x))))};i=()=>{const S=this.backend.numDataIds();u=this.tidy(()=>b(this.backend,v));const x=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,S,x),x}}const{inputs:c,attrs:h}=e,p=wa(e)?null:e.backwardsFunc;let m;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=i():(m=this.profiler.profileKernel(l,c,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(m),n=m.outputs)}),s&&this.addTapeNode(l,c,n,p,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(b=>c[b]!=null?c[b].shape:null),outputShapes:n.map(b=>b.shape),kernelTimeMs:m.timeMs,extraInfo:m.extraInfo}),Array.isArray(u)?n:n[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,n,r){const s=Pa(e);if(s!=null){const a=s.inputsToSave||[],o=s.outputsToSave||[];let i;s.saveAllInputs?(N(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(n).map(l=>n[l])):i=a.map(l=>n[l]);const u=r.filter((l,c)=>o[c]);return i.concat(u)}return[]}makeTensor(e,n,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let a=e;r==="string"&&an(e[0])&&(a=e.map(u=>Vr(u)));const o=s.write(a,n,r),i=new ye(n,r,o,this.nextTensorId());if(this.trackTensor(i,s),r==="string"){const u=this.state.tensorInfo.get(o),l=qu(a);this.state.numBytes+=l-u.bytes,u.bytes=l}return i}makeTensorFromDataId(e,n,r,s){r=r||"float32";const a={dataId:e,shape:n,dtype:r};return this.makeTensorFromTensorInfo(a,s)}makeTensorFromTensorInfo(e,n){const{dataId:r,shape:s,dtype:a}=e,o=new ye(s,a,r,this.nextTensorId());return this.trackTensor(o,n),o}makeVariable(e,n=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const a=new Ir(e,n,r,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,n){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*Aa(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:n||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof Ir||this.track(e)}incRef(e,n){this.trackTensor(e,n),this.backend.incRef(e.dataId)}removeDataId(e,n){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===n&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const n=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*Aa(e.dtype);this.state.numBytes-=r}n.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,n.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const n=this.state.registeredVariables[e];this.disposeVariable(n)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,n,r,s,a,o){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:n,outputs:r,saved:a},u=Pa(e);u!=null&&(s=u.gradFunc),s!=null&&(i.gradient=l=>(l=l.map((c,h)=>{if(c==null){const p=r[h],m=Cs(p.size,p.dtype);return this.makeTensor(m,p.shape,p.dtype)}return c}),s(l.length>1?l:l[0],a,o))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(n.name=e),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(e){const n=No(e),r=new Set(n.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const o=this.state.activeScope.track[a];!o.kept&&!r.has(o.id)&&o.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(a=>{!a.kept&&a.scopeId===s.id&&this.track(a)})}gradients(e,n,r,s=!1){if(N(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));N(a instanceof ye,()=>"The result y returned by f() must be a tensor.");const o=hy(this.state.activeTape,n,a);if(!s&&o.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const i={};i[a.id]=r??Ty(a.shape),fy(i,o,l=>this.tidy(l),Ey);const u=n.map(l=>i[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(const c of l.saved)c.dispose()}),this.state.activeTape=null),{value:a,grads:u}})}customGrad(e){return N(cn(e),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{N(n.every(i=>i instanceof ye),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};n.forEach((i,u)=>{s[u]=i});const a=(i,u)=>(r=e(...n,u),N(r.value instanceof ye,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),N(cn(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),o=(i,u)=>{const l=r.gradFunc(i,u),c=Array.isArray(l)?l:[l];N(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),N(c.every(p=>p instanceof ye),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return c.forEach((p,m)=>{h[m]=()=>p}),h};return this.runKernelFunc({forwardFunc:a,backwardsFunc:o,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,n){return this.state.tensorInfo.get(e).backend.readToGPU(e,n)}async time(e){const n=Ar(),r=await this.backend.time(e);return r.wallMs=Ar()-n,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Qi;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}ar.nextTensorId=0;ar.nextVariableId=0;function Ty(t){const e=ho($e(t),"float32");return _.makeTensor(e,t,"float32")}function Uh(){const t=Xu();if(t._tfengine==null){const e=new Ku(t);t._tfengine=new ar(e)}return _g(t._tfengine.ENV),my(()=>t._tfengine),t._tfengine}const _=Uh();function Ey(t,e){const n={a:t,b:e};return _.runKernel(go,n)}function ky(){return typeof navigator<"u"&&navigator!=null}let Ua;function _y(t){Ua=t}function xy(t){if(Ua!==void 0)return Ua;if(t||ky()){if(t||(t=navigator),t.product==="ReactNative")return!0;const e=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");if(!e){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function qh(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var $y=Object.freeze(Object.defineProperty({__proto__:null,mockIsMobile:_y,isMobile:xy,isBrowser:qh},Symbol.toStringTag,{value:"Module"}));const wt=re();wt.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});wt.registerFlag("IS_BROWSER",()=>qh());wt.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");wt.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));wt.registerFlag("PROD",()=>!1);wt.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>wt.getBool("DEBUG"));wt.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);wt.registerFlag("IS_TEST",()=>!1);wt.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);wt.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);wt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Vt(t,e){let n=t;if(Ue(t))return e==="string"?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||Ue(n)&&e!=="string";)r.push(n.length),n=n[0];return Array.isArray(t)&&re().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Wh(t,r,[]),r}function Wh(t,e,n){if(n=n||[],!Array.isArray(t)&&!Ue(t)){N(e.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}N(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),N(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const r=e.slice(1);for(let s=0;s<t.length;++s)Wh(t[s],r,n.concat(s))}function eu(t,e,n,r){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==e||t==="numeric"&&e==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function w(t,e,n,r="numeric"){if(t instanceof ye)return eu(r,t.dtype,e,n),t;let s=Rs(t);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),eu(r,s,e,n),t==null||!Ue(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){const u=t==null?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${u}'`)}const a=Vt(t,s);!Ue(t)&&!Array.isArray(t)&&(t=[t]);const i=s!=="string"?Bs(t,s):$n(t,[],!0);return _.makeTensor(i,a,s)}function Or(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((a,o)=>w(a,`${e}[${o}]`,n,r))}const To="__op";function k(t){const e=Object.keys(t);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+To;const s=(...a)=>{_.startScope(n);try{const o=r(...a);return An(o)&&console.error("Cannot return a Promise inside of tidy."),_.endScope(o),o}catch(o){throw _.endScope(null),o}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}function Ay(t,e){const n=w(t,"real","complex"),r=w(e,"imag","complex");Je(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return _.runKernel(yl,s)}const Xt=k({complex_:Ay});function dn(t,e,n,r){if(r==null&&(r=Rs(t)),r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Ue(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){fo(e);const s=$e(e),a=$e(n);N(s===a,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${a}`);for(let o=0;o<n.length;++o){const i=n[o],u=o===n.length-1?i!==$e(e.slice(o)):!0;N(n[o]===e[o]||!u,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return!Ue(t)&&!Array.isArray(t)&&(t=[t]),e=e||n,t=r!=="string"?Bs(t,r):$n(t,[],!0),_.makeTensor(t,e,r)}function yt(t,e,n){const r=Vt(t,n);return dn(t,e,r,n)}const qa={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};const xs=4;async function Iy(t,e){const n=[],r=[],s=Array.isArray(t)?t.map(o=>o.name):Object.keys(t);for(let o=0;o<s.length;++o){const i=s[o],u=Array.isArray(t)?t[o].tensor:t[i];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${u.dtype}`);const l={name:i,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const c=new Promise(async h=>{const p=await u.bytes(),m=p.reduce((S,x)=>S+x.length,0)+xs*p.length,b=new Uint8Array(m);let v=0;for(let S=0;S<p.length;S++){const x=p[S],O=new Uint8Array(new Uint32Array([x.length]).buffer);b.set(O,v),v+=xs,b.set(x,v),v+=x.length}h(b)});r.push(c)}else r.push(u.data());e!=null&&(l.group=e),n.push(l)}const a=await Promise.all(r);return{data:Oy(a),specs:n}}function Hh(t,e){const n={};let r,s=0;for(const a of e){const o=a.name,i=a.dtype,u=a.shape,l=$e(u);let c;if("quantization"in a){const h=a.quantization;if(h.dtype==="uint8"||h.dtype==="uint16"){if(!("min"in h&&"scale"in h))throw new Error(`Weight ${a.name} with quantization ${h.dtype} doesn't have corresponding metadata min and scale.`)}else if(h.dtype==="float16"){if(i!=="float32")throw new Error(`Weight ${a.name} is quantized with ${h.dtype} which only supports weights of type float32 not ${i}.`)}else throw new Error(`Weight ${a.name} has unknown quantization dtype ${h.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const p=qa[h.dtype],m=t.slice(s,s+l*p),b=h.dtype==="uint8"?new Uint8Array(m):new Uint16Array(m);if(i==="float32")if(h.dtype==="uint8"||h.dtype==="uint16"){c=new Float32Array(b.length);for(let v=0;v<b.length;v++){const S=b[v];c[v]=S*h.scale+h.min}}else if(h.dtype==="float16")r===void 0&&(r=By()),c=r(b);else throw new Error(`Unsupported quantization type ${h.dtype} for weight type float32.`);else if(i==="int32"){if(h.dtype!=="uint8"&&h.dtype!=="uint16")throw new Error(`Unsupported quantization type ${h.dtype} for weight type int32.`);c=new Int32Array(b.length);for(let v=0;v<b.length;v++){const S=b[v];c[v]=Math.round(S*h.scale+h.min)}}else throw new Error(`Unsupported dtype in weight '${o}': ${i}`);s+=l*p}else if(i==="string"){const h=$e(a.shape);c=[];for(let p=0;p<h;p++){const m=new Uint32Array(t.slice(s,s+xs))[0];s+=xs;const b=new Uint8Array(t.slice(s,s+m));c.push(b),s+=m}}else{const h=qa[i],p=t.slice(s,s+l*h);if(i==="float32")c=new Float32Array(p);else if(i==="int32")c=new Int32Array(p);else if(i==="bool")c=new Uint8Array(p);else if(i==="complex64"){c=new Float32Array(p);const m=new Float32Array(c.length/2),b=new Float32Array(c.length/2);for(let x=0;x<m.length;x++)m[x]=c[x*2],b[x]=c[x*2+1];const v=yt(m,u,"float32"),S=yt(b,u,"float32");n[o]=Xt(v,S),v.dispose(),S.dispose()}else throw new Error(`Unsupported dtype in weight '${o}': ${i}`);s+=l*h}i!=="complex64"&&(n[o]=yt(c,u,i))}return n}function Oy(t){if(t===null)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(a=>{if(e+=a.byteLength,n.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const r=new Uint8Array(e);let s=0;return n.forEach(a=>{r.set(new Uint8Array(a.buffer),s),s+=a.byteLength}),r.buffer}const Eo=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function tu(t){return Eo?Buffer.byteLength(t):new Blob([t]).size}function Dy(t){if(Eo)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,s=e.length;r<s;r++)n+=String.fromCharCode(e[r]);return btoa(n)}function Fy(t){if(Eo){const r=Buffer.from(t,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}function ko(t){if(t.length===1)return t[0];let e=0;t.forEach(s=>{e+=s.byteLength});const n=new Uint8Array(e);let r=0;return t.forEach(s=>{n.set(new Uint8Array(s),r),r+=s.byteLength}),n.buffer}function nu(t){const e="/";for(t=t.trim();t.endsWith(e);)t=t.slice(0,t.length-1);const n=t.split(e);return n[n.length-1]}function Gh(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),n}async function _o(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),t.weightsManifest!=null){const[r,s]=await e(t.weightsManifest);n.weightSpecs=r,n.weightData=s}return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),n}function jr(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:tu(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:tu(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:t.weightData.byteLength}}function Py(){const t=n=>{let r=n<<13,s=0;for(;(r&8388608)===0;)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}function Ry(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}function Cy(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}function By(){const t=Py(),e=Ry(),n=Cy();return r=>{const s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let o=0;o<r.length;o++){const i=r[o],u=t[n[i>>10]+(i&1023)]+e[i>>10];a[o]=u}return new Float32Array(s)}}class Fe{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Fe.instance==null&&(Fe.instance=new Fe),Fe.instance}static registerSaveRouter(e){Fe.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Fe.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Fe.getHandlers(e,"save")}static getLoadHandlers(e,n){return Fe.getHandlers(e,"load",n)}static getHandlers(e,n,r){const s=[];return(n==="load"?Fe.getInstance().loadRouters:Fe.getInstance().saveRouters).forEach(o=>{const i=o(e,r);i!==null&&s.push(i)}),s}}const Ly=t=>Fe.registerSaveRouter(t),My=t=>Fe.registerLoadRouter(t),zy=t=>Fe.getSaveHandlers(t),Vy=(t,e)=>Fe.getLoadHandlers(t,e);const Wa="tensorflowjs",Ha=1,Tn="models_store",on="model_info_store";function Kh(){if(!re().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Ga(t){const e=t.result;e.createObjectStore(Tn,{keyPath:"modelPath"}),e.createObjectStore(on,{keyPath:"modelPath"})}class In{constructor(e){if(this.indexedDB=Kh(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,n){return new Promise((r,s)=>{const a=this.indexedDB.open(Wa,Ha);a.onupgradeneeded=()=>Ga(a),a.onsuccess=()=>{const o=a.result;if(n==null){const i=o.transaction(Tn,"readonly"),l=i.objectStore(Tn).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return o.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(l.result.modelArtifacts)},l.onerror=c=>(o.close(),s(l.error)),i.oncomplete=()=>o.close()}else{const i=jr(n),u=o.transaction(on,"readwrite");let l=u.objectStore(on);const c=l.put({modelPath:this.modelPath,modelArtifactsInfo:i});let h;c.onsuccess=()=>{h=o.transaction(Tn,"readwrite");const m=h.objectStore(Tn).put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:i});m.onsuccess=()=>r({modelArtifactsInfo:i}),m.onerror=b=>{l=u.objectStore(on);const v=l.delete(this.modelPath);v.onsuccess=()=>(o.close(),s(m.error)),v.onerror=S=>(o.close(),s(m.error))}},c.onerror=p=>(o.close(),s(c.error)),u.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},a.onerror=o=>s(a.error)})}}In.URL_SCHEME="indexeddb://";const Xh=t=>re().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(In.URL_SCHEME)?jy(t.slice(In.URL_SCHEME.length)):null;Fe.registerSaveRouter(Xh);Fe.registerLoadRouter(Xh);function jy(t){return new In(t)}function Uy(t){return t.startsWith(In.URL_SCHEME)?t.slice(In.URL_SCHEME.length):t}class qy{constructor(){this.indexedDB=Kh()}async listModels(){return new Promise((e,n)=>{const r=this.indexedDB.open(Wa,Ha);r.onupgradeneeded=()=>Ga(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(on,"readonly"),i=a.objectStore(on).getAll();i.onsuccess=()=>{const u={};for(const l of i.result)u[l.modelPath]=l.modelArtifactsInfo;e(u)},i.onerror=u=>(s.close(),n(i.error)),a.oncomplete=()=>s.close()},r.onerror=s=>n(r.error)})}async removeModel(e){return e=Uy(e),new Promise((n,r)=>{const s=this.indexedDB.open(Wa,Ha);s.onupgradeneeded=()=>Ga(s),s.onsuccess=()=>{const a=s.result,o=a.transaction(on,"readwrite"),i=o.objectStore(on),u=i.get(e);let l;u.onsuccess=()=>{if(u.result==null)return a.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=i.delete(e),h=()=>{l=a.transaction(Tn,"readwrite");const m=l.objectStore(Tn).delete(e);m.onsuccess=()=>n(u.result.modelArtifactsInfo),m.onerror=b=>r(u.error)};c.onsuccess=h,c.onerror=p=>(h(),a.close(),r(u.error))}},u.onerror=c=>(a.close(),r(u.error)),o.oncomplete=()=>{l==null?a.close():l.oncomplete=()=>a.close()}},s.onerror=a=>r(s.error)})}}const Gt="/",Yn="tensorflowjs_models",Yh="info",Wy="model_topology",Hy="weight_specs",Gy="weight_data",Ky="model_metadata";function Zh(t){return{info:[Yn,t,Yh].join(Gt),topology:[Yn,t,Wy].join(Gt),weightSpecs:[Yn,t,Hy].join(Gt),weightData:[Yn,t,Gy].join(Gt),modelMetadata:[Yn,t,Ky].join(Gt)}}function Jh(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function Xy(t){const e=t.split(Gt);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(Gt)}function Yy(t){return t.startsWith(On.URL_SCHEME)?t.slice(On.URL_SCHEME.length):t}class On{constructor(e){if(!re().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Zh(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=jr(e);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,Dy(e.weightData));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:s}}catch{throw Jh(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=s;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const i=JSON.parse(a);n.format=i.format,n.generatedBy=i.generatedBy,n.convertedBy=i.convertedBy,i.signature!=null&&(n.signature=i.signature),i.userDefinedMetadata!=null&&(n.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(n.modelInitializer=i.modelInitializer),i.trainingConfig!=null&&(n.trainingConfig=i.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=Fy(o),n}}On.URL_SCHEME="localstorage://";const Qh=t=>re().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(On.URL_SCHEME)?Zy(t.slice(On.URL_SCHEME.length)):null;Fe.registerSaveRouter(Qh);Fe.registerLoadRouter(Qh);function Zy(t){return new On(t)}class Jy{constructor(){N(re().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),N(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},n=Yn+Gt,r=Gt+Yh;for(let s=0;s<this.LS.length;++s){const a=this.LS.key(s);if(a.startsWith(n)&&a.endsWith(r)){const o=Xy(a);e[o]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=Yy(e);const n=Zh(e);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return Jh(n),r}}const Qn="://";class Ke{constructor(){this.managers={}}static getInstance(){return Ke.instance==null&&(Ke.instance=new Ke),Ke.instance}static registerManager(e,n){N(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Qn)&&(e=e.slice(0,e.indexOf(Qn))),N(e.length>0,()=>"scheme must not be an empty string.");const r=Ke.getInstance();N(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=n}static getManager(e){const n=Ke.getInstance().managers[e];if(n==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return n}static getSchemes(){return Object.keys(Ke.getInstance().managers)}}function bs(t){if(t.indexOf(Qn)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ke.getSchemes().join(",")}`);return{scheme:t.split(Qn)[0],path:t.split(Qn)[1]}}async function ef(t,e,n=!1){N(t!==e,()=>`Old path and new path are the same: '${t}'`);const r=Fe.getLoadHandlers(t);N(r.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),N(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`);const s=r[0],a=Fe.getSaveHandlers(e);N(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),N(a.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const o=a[0],i=bs(t).scheme,u=bs(t).path,l=i===bs(t).scheme,c=await s.load();n&&l&&await Ke.getManager(i).removeModel(u);const h=await o.save(c);return n&&!l&&await Ke.getManager(i).removeModel(u),h.modelArtifactsInfo}async function Qy(){const t=Ke.getSchemes(),e={};for(const n of t){const r=await Ke.getManager(n).listModels();for(const s in r){const a=n+Qn+s;e[a]=r[s]}}return e}async function e0(t){const e=bs(t);return Ke.getManager(e.scheme).removeModel(e.path)}async function t0(t,e){return ef(t,e,!1)}async function n0(t,e){return ef(t,e,!0)}class r0{fetch(e,n){return fetch(e,n)}now(){return performance.now()}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,n){return new TextDecoder(n).decode(e)}}if(re().get("IS_BROWSER")){re().setPlatform("browser",new r0);try{Ke.registerManager(On.URL_SCHEME,new Jy)}catch{}try{Ke.registerManager(In.URL_SCHEME,new qy)}catch{}}const s0={importFetch:()=>require("node-fetch")};let va;class a0{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return re().global.fetch!=null?re().global.fetch(e,n):(va==null&&(va=s0.importFetch()),va(e,n))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(e)}decode(e,n){return e.length===0?"":new this.util.TextDecoder(n).decode(e)}}re().get("IS_NODE")&&!re().get("IS_BROWSER")&&re().setPlatform("node",new a0);function jt(t,e="float32",n){return e=e||"float32",fo(t),new _s(t,e,n)}function o0(t,e){const n=w(t,"x","cast");if(!Uu(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&n.dtype!=="string"||e!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:e};return _.runKernel(yo,r,s)}const be=k({cast_:o0});function i0(t){const n={x:w(t,"x","clone","string_or_numeric")};return _.runKernel(bo,n)}const Kt=k({clone_:i0});function xo(t,e=!1){console.log(t.toString(e))}Uh();const u0={buffer:jt,cast:be,clone:Kt,print:xo};gy(u0);const l0="model",c0=".json",h0=".weights.bin";function ru(t){return new Promise(e=>setTimeout(e)).then(t)}class Dn{constructor(e){if(!re().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Dn.URL_SCHEME)&&(e=e.slice(Dn.URL_SCHEME.length)),(e==null||e.length===0)&&(e=l0),this.modelJsonFileName=e+c0,this.weightDataFileName=e+h0}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],s=Gh(e,r),a=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=a,await ru(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=n,await ru(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:jr(e)}}}}Dn.URL_SCHEME="downloads://";class f0{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,n)=>{const r=new FileReader;r.onload=s=>{const a=JSON.parse(s.target.result),o=a.modelTopology;if(o==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:o});return}const u=_o(a,l=>this.loadWeights(l));e(u)},r.onerror=s=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){const n=[],r=[];for(const o of e)n.push(...o.weights),r.push(...o.paths);const s=this.checkManifestAndWeightFiles(e),a=r.map(o=>this.loadWeightsFile(o,s[o]));return Promise.all(a).then(o=>[n,ko(o)])}loadWeightsFile(e,n){return new Promise((r,s)=>{const a=new FileReader;a.onload=o=>{const i=o.target.result;r(i)},a.onerror=o=>s(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(e){const n=[],r=this.weightsFiles.map(a=>nu(a.name)),s={};for(const a of e)a.paths.forEach(o=>{const i=nu(o);if(n.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(n.push(i),r.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);s[o]=this.weightsFiles[r.indexOf(i)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}const p0=t=>re().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Dn.URL_SCHEME)?d0(t.slice(Dn.URL_SCHEME.length)):null;Fe.registerSaveRouter(p0);function d0(t="model"){return new Dn(t)}function m0(t){return new f0(t)}function su(t,e,n,r){o(t),n=n??0,r=r??1,i(n,r);let s=0;const a=u=>(u.then(l=>{const c=n+ ++s/t.length*(r-n);return e(c),l}),u);function o(u){N(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function i(u,l){N(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),N(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),N(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(t.map(a))}async function tf(t,e){e==null&&(e={});const n=e.fetchFunc==null?re().platform.fetch:e.fetchFunc,r=t.map(h=>n(h,e.requestInit,{isBinary:!0})),s=0,a=.5,i=(e.onProgress==null?await Promise.all(r):await su(r,e.onProgress,s,a)).map(h=>h.arrayBuffer()),u=.5,l=1;return e.onProgress==null?await Promise.all(i):await su(i,e.onProgress,u,l)}async function g0(t,e="",n,r){return nf(o=>tf(o,{requestInit:r}))(t,e,n)}function nf(t){return async(e,n="",r)=>{const s=e.map(()=>!1),a={},o=r!=null?r.map(()=>!1):[],i=[];if(e.forEach((m,b)=>{let v=0;m.weights.forEach(S=>{const x="quantization"in S?S.quantization.dtype:S.dtype,O=qa[x]*$e(S.shape),E=()=>{s[b]=!0,a[b]==null&&(a[b]=[]),a[b].push({manifestEntry:S,groupOffset:v,sizeBytes:O})};r!=null?r.forEach(($,I)=>{$===S.name&&(E(),o[I]=!0)}):E(),i.push(S.name),v+=O})}),!o.every(m=>m)){const m=r.filter((b,v)=>!o[v]);throw new Error(`Could not find weights in manifest with names: ${m.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}const u=s.reduce((m,b,v)=>(b&&m.push(v),m),[]),l=[];u.forEach(m=>{e[m].paths.forEach(b=>{const v=n+(n.endsWith("/")?"":"/")+b;l.push(v)})});const c=await t(l),h={};let p=0;return u.forEach(m=>{const b=e[m].paths.length;let v=0;for(let $=0;$<b;$++)v+=c[p+$].byteLength;const S=new ArrayBuffer(v),x=new Uint8Array(S);let O=0;for(let $=0;$<b;$++){const I=new Uint8Array(c[p+$]);x.set(I,O),O+=I.byteLength}a[m].forEach($=>{const I=S.slice($.groupOffset,$.groupOffset+$.sizeBytes),F=Hh(I,[$.manifestEntry]);for(const L in F)h[L]=F[L]}),p+=b}),h}}const y0="application/octet-stream",b0="application/json";class $o{constructor(e,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.onProgress=n.onProgress,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(N(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=re().platform.fetch,N(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&N(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=Gh(e,r);n.body.append("model.json",new Blob([JSON.stringify(s)],{type:b0}),"model.json"),e.weightData!=null&&n.body.append("model.weights.bin",new Blob([e.weightData],{type:y0}),"model.weights.bin");const a=await this.fetch(this.path,n);if(a.ok)return{modelArtifactsInfo:jr(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const r=n.modelTopology,s=n.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return _o(n,a=>this.loadWeights(a))}async loadWeights(e){const n=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=w0(n),a=this.weightPathPrefix||r,o=[];for(const c of e)o.push(...c.weights);const i=[],u=[];for(const c of e)for(const h of c.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(h)):i.push(a+h+s);this.weightUrlConverter&&i.push(...await Promise.all(u));const l=await tf(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,ko(l)]}}$o.URL_SCHEME_REGEX=/^https?:\/\//;function w0(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),s=n>e?t.substring(n):"";return[r+"/",s]}function Ka(t){return t.match($o.URL_SCHEME_REGEX)!=null}const rf=(t,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let n=!0;if(Array.isArray(t)?n=t.every(r=>Ka(r)):n=Ka(t),n)return Ao(t,e)}return null};Fe.registerSaveRouter(rf);Fe.registerLoadRouter(rf);function Ao(t,e){return new $o(t,e)}function v0(t,e){return Ao(t,e)}class Sa{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class sf{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class S0{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=n=>Promise.resolve(e.save(n)))}}function N0(t,e,n,r){const s=arguments;return new S0(af(...s))}function af(t,e,n,r){return arguments.length===1?t.modelTopology!=null||t.weightSpecs!=null?new Sa(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Sa({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Sa({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r}))}function T0(t){return new sf(t)}function E0(t){return new sf(t)}var Io=Object.freeze(Object.defineProperty({__proto__:null,browserFiles:m0,browserHTTPRequest:v0,concatenateArrayBuffers:ko,decodeWeights:Hh,encodeWeights:Iy,fromMemory:N0,fromMemorySync:af,getLoadHandlers:Vy,getModelArtifactsForJSON:_o,getModelArtifactsInfoForJSON:jr,getSaveHandlers:zy,http:Ao,isHTTPScheme:Ka,loadWeights:g0,registerLoadRouter:My,registerSaveRouter:Ly,weightsLoaderFactory:nf,withSaveHandler:T0,withSaveHandlerSync:E0,copyModel:t0,listModels:Qy,moveModel:n0,removeModel:e0},Symbol.toStringTag,{value:"Module"}));function k0(t,e,n=!1,r=!1){let s=w(t,"a","matMul"),a=w(e,"b","matMul");[s,a]=Pe(s,a);const o={a:s,b:a},i={transposeA:n,transposeB:r};return _.runKernel(hl,o,i)}const ge=k({matMul_:k0});function _0(t,e,n=1,r=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const a={indices:w(t,"indices","oneHot","int32")},o={depth:e,onValue:n,offValue:r};return _.runKernel(Pc,a,o)}const Dr=k({oneHot_:_0});function x0(){re().set("PROD",!0)}function $0(){re().set("DEBUG",!0)}function A0(){re().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function I0(t){re().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function O0(){_.disposeVariables()}function Oo(){return _}function D0(){return _.memory()}function F0(t){return _.profile(t)}function Y(t,e){return _.tidy(t,e)}function et(t){No(t).forEach(n=>n.dispose())}function Ct(t){return _.keep(t)}function P0(t){return _.time(t)}function R0(t){return _.setBackend(t)}function C0(){return _.ready()}function of(){return _.backendName}function B0(t){_.removeBackend(t)}function L0(t){return _.findBackend(t)}function M0(t){return _.findBackendFactory(t)}function z0(t,e,n=1){return _.registerBackend(t,e,n)}function uf(){return _.backend}function V0(t,e){re().setPlatform(t,e)}function j0(t){const n={input:w(t,"input","imag")};return _.runKernel(nc,n)}const Ur=k({imag_:j0});function U0(t){const n={x:w(t,"x","neg")};return _.runKernel($c,n)}const Lt=k({neg_:U0});function q0(t){const n={input:w(t,"input","real")};return _.runKernel(Vc,n)}const or=k({real_:q0});function W0(t,e,n){const r=w(t,"x","transpose");if(e==null&&(e=r.shape.map((o,i)=>i).reverse()),N(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(o=>{N(o>=0&&o<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const s={x:r},a={perm:e};return r.dtype==="complex64"?Y(()=>{let o=or(r),i=Ur(r);return o=_.runKernel(gs,{x:o},a),i=_.runKernel(gs,{x:i},a),n&&(i=Lt(i)),Xt(o,i)}):_.runKernel(gs,s,a)}const Fr=k({transpose_:W0});function H0(t,e,n){const r=w(t,"labels","confusionMatrix"),s=w(e,"predictions","confusionMatrix");N(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),N(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),N(s.rank===1,()=>`Expected the rank of predictions to be 1, but got ${s.rank}`),N(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),N(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);const a=Dr(be(r,"int32"),n),o=Dr(be(s,"int32"),n),i=Fr(a),u=ge(i,o);return be(u,"int32")}const G0=k({confusionMatrix_:H0});var K0=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:G0},Symbol.toStringTag,{value:"Module"}));function lf(t,e){const n=t.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,o=t[a]||1;(e[e.length-1-s]||1)>1&&o===1&&r.unshift(a)}return r}function Do(t,e){const n=[];for(let r=0;r<e.length;r++){const s=t[t.length-r-1],a=e.length-r-1,o=e[a];(s==null||s===1&&o>1)&&n.unshift(a)}return n}function Be(t,e){const n=[],r=Math.max(t.length,e.length);for(let s=0;s<r;s++){let a=t[t.length-s-1];a==null&&(a=1);let o=e[e.length-s-1];if(o==null&&(o=1),a===1)n.unshift(o);else if(o===1)n.unshift(a);else if(a!==o){const i=`Operands could not be broadcast together with shapes ${t} and ${e}.`;throw Error(i)}else n.unshift(a)}return n}var X0=Object.freeze(Object.defineProperty({__proto__:null,getBroadcastDims:lf,getReductionAxes:Do,assertAndGetBroadcastShape:Be},Symbol.toStringTag,{value:"Module"}));function Fo(t,e,n){if(Bn(t),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=Vt(t,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return dn(t,e,r,n)}let wn;function cf(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(t==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,o=!1,i=!1;if(t.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&t instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)a=!0;else if(t.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&t instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);if(s&&s&&t.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(Ns(Ia,_.backendName)!=null){const b={pixels:t},v={numChannels:e};return _.runKernel(Ia,b,v)}const[l,c]=s?[t.videoWidth,t.videoHeight]:[t.width,t.height];let h;if(o)h=t.getContext("2d").getImageData(0,0,l,c).data;else if(r||n)h=t.data;else if(a||s||i){if(wn==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")wn=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else wn=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});wn.canvas.width=l,wn.canvas.height=c,wn.drawImage(t,0,0,l,c),h=wn.getImageData(0,0,l,c).data}let p;if(e===4)p=new Int32Array(h);else{const b=l*c;p=new Int32Array(b*e);for(let v=0;v<b;v++)for(let S=0;S<e;++S)p[v*e+S]=h[v*4+S]}return Fo(p,[c,l,e],"int32")}function Y0(t){return t!=null&&t.data instanceof Uint8Array}function Z0(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function J0(t){return t!=null&&t.width!==0&&t.height!==0}function Q0(t){return Z0()&&!(t instanceof ImageBitmap)&&J0(t)&&!Y0(t)}async function eb(t,e=3){let n=null;if(re().getBool("WRAP_TO_IMAGEBITMAP")&&Q0(t)){let r;try{r=await createImageBitmap(t,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===t.width&&r.height===t.height?n=r:n=t}else n=t;return cf(n,e)}async function qr(t,e){let n=w(t,"img","toPixels");if(!(t instanceof ye)){const l=n;n=be(l,"int32"),l.dispose()}if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[r,s]=n.shape.slice(0,2),a=n.rank===2?1:n.shape[2];if(a>4||a===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${a}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);const o=await n.data(),i=n.dtype==="float32"?255:1,u=new Uint8ClampedArray(s*r*4);for(let l=0;l<r*s;++l){const c=[0,0,0,255];for(let p=0;p<a;p++){const m=o[l*a+p];if(n.dtype==="float32"){if(m<0||m>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${m}.`)}else if(n.dtype==="int32"&&(m<0||m>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${m}.`);a===1?(c[0]=m*i,c[1]=m*i,c[2]=m*i):c[p]=m*i}const h=l*4;u[h+0]=Math.round(c[0]),u[h+1]=Math.round(c[1]),u[h+2]=Math.round(c[2]),u[h+3]=Math.round(c[3])}if(e!=null){e.width=s,e.height=r;const l=e.getContext("2d"),c=new ImageData(u,s,r);l.putImageData(c,0,0)}return n!==t&&n.dispose(),u}const Ms=k({fromPixels_:cf});var tb=Object.freeze(Object.defineProperty({__proto__:null,fromPixelsAsync:eb,toPixels:qr,fromPixels:Ms},Symbol.toStringTag,{value:"Module"}));function hf(t,e){const n=t.shape.length,r=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${n}`);if($e(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const s=e.shape,a=s[s.length-1];let o=1;for(let h=0;h<s.length-1;++h)o*=s[h];const i=t.shape,u=s.slice();u.pop();let l=1;for(let h=a;h<n;++h)l*=i[h],u.push(i[h]);const c=[...cr(t.shape).map(h=>h/l),1].slice(0,a);return[u,o,l,c]}var nb=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:hf},Symbol.toStringTag,{value:"Module"}));function Po(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(t.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+t.length-r)throw new Error(a+` update.rank != ${s+t.length-r}`);for(let o=0;o<s;++o)if(n.shape[o]!==e.shape[o])throw new Error(a+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<n.rank-s;++o)if(n.shape[o+s]!==t[o+r])throw new Error(a+` updates.shape[${o+s}] (${n.shape[o+s]}) != shape[${o+s}] (${t[o+s]})`)}function Ro(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}Po(n,e,t)}function ff(t,e,n){const r=e.shape.length,s=r>1?e.shape[r-1]:1,a=n.length;let o=1;for(let h=s;h<a;++h)o*=n[h];const i=s<1?1:s,u=$e(e.shape)/i,l=[...cr(n.slice(0,s)),1],c=$e(n);return{sliceRank:s,numUpdates:u,sliceSize:o,strides:l,outputSize:c}}var rb=Object.freeze(Object.defineProperty({__proto__:null,validateUpdateShape:Po,validateInput:Ro,calculateShapes:ff},Symbol.toStringTag,{value:"Module"}));const Xa=-2,sb=-1;function ab(t,e,n){const r=t.shape.length;N(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),N(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)N(e[s]+n[s]<=t.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+n[s]}) would overflow input.shape[${s}] (${t.shape[s]})`)}function ob(t){const e=[];let n=0;for(;t>0;)t&1&&e.push(n),t/=2,n++;return e}function ib(t,e,n){const r=[];for(let s=0;s<t.length;s++)r[s]=Math.ceil((e[s]-t[s])/n[s]);return r}function pf(t,e,n,r){const s=[...t];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<n;a++)a===0?s[e]=1:(s.splice(e,0,1),s.pop());return s}function df(t,e,n){return n<=t?n:n-(e-1)}function mf(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function ub(t,e,n,r,s,a,o,i,u){const l=t.length;let c=new Array(l),h=new Array(l),p=new Array(l);if(e.length&&n>0){const m=e[0],b=n+1;c=gf(o,m,b,r,t),h=yf(i,m,b,s,t),p=pf(a,m,b,t)}else for(let m=0;m<l;m++)c[m]=wf(o,r,a,t,m,u),h[m]=vf(i,s,a,t,m,u),p[m]=bf(a,m,u);return{begin:c,end:h,strides:p}}function gf(t,e,n,r,s){const a=[...s],o=mf(n,e);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=0;else{const u=df(e,n,i);let l=r[u];t&1<<u&&(l=0),a[i]=l}return a}function yf(t,e,n,r,s){const a=[...s],o=mf(n,e);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=Number.MAX_SAFE_INTEGER;else{const u=df(e,n,i);let l=r[u];t&1<<u&&(l=Number.MAX_SAFE_INTEGER),a[i]=l}for(let i=0;i<a.length;i++){const u=s[i];a[i]<0&&(a[i]+=u),a[i]=xr(0,a[i],s[i])}return a}function bf(t,e,n){let r=t[e];return(n&1<<e||r==null)&&(r=1),r}function wf(t,e,n,r,s,a){let o=e[s];const i=n[s]||1;(t&1<<s||a&1<<s||o==null)&&(i>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const u=r[s];return o<0&&(o+=u),o=xr(0,o,u-1),o}function vf(t,e,n,r,s,a){let o=e[s];const i=n[s]||1;(t&1<<s||a&1<<s||o==null)&&(i>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const u=r[s];return o<0&&(o+=u),i>0?o=xr(0,o,u):o=xr(-1,o,u-1),o}function lb(t,e,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(e[s]>0||n[s]!==t[s])return!1;return!0}function cb(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function hb(t,e,n){let r;const s=t.shape.length;typeof e=="number"?r=[e,...new Array(s-1).fill(0)]:e.length<s?r=e.concat(new Array(s-e.length).fill(0)):r=e.slice(),r.forEach(o=>{N(o!==-1,()=>"slice() does not support negative begin indexing.")});let a;return n==null?a=new Array(s).fill(-1):typeof n=="number"?a=[n,...new Array(s-1).fill(-1)]:n.length<s?a=n.concat(new Array(s-n.length).fill(-1)):a=n,a=a.map((o,i)=>o>=0?o:(N(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${i}.`),t.shape[i]-r[i])),[r,a]}function fb(t,e,n,r,s,a,o,i,u){let l;if(r==null?(l=new Array(e.length),l.fill(1)):l=r,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:l.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:l.slice(),beginMask:s,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};for(let E=0;E<h.dims;E++)c&&(1<<E&i)!==0&&h.numAddAxisAfterEllipsis++,1<<E&o&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const p={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};pb(h,p);let m=!0,b=!0,v=!0;const S=[],x=[];for(let E=0;E<t.length;++E){if(p.strides[E]===0)throw Error(`strides[${E}] must be non-zero`);const $=!!(p.shrinkAxisMask&1<<E),I=t[E];if(I===-1){S.push($?1:-1);continue}const F=[p.beginMask&1<<E,p.endMask&1<<E],L=[p.strides[E]>0?0:-1,p.strides[E]>0?I:I-1];if($&&p.strides[E]<=0)throw Error("only stride 1 allowed on non-range indexing.");v=v&&p.strides[E]===1;const M=!!(p.beginMask&1<<E&&p.endMask&1<<E);if(p.beginValid&&p.endValid){if($){const G=p.begin[E]<0?I+p.begin[E]:p.begin[E];if(p.begin[E]=G,p.end[E]=p.begin[E]+1,G<0||G>=I)throw Error(`slice index ${p.begin[E]} of dimension ${E} out of bounds.`)}else p.begin[E]=au(p.begin[E],0,p.strides[E],I,F,L),p.end[E]=au(p.end[E],1,p.strides[E],I,F,L);const V=p.strides[E]===1&&p.begin[E]===0&&p.end[E]===I;m=m&&V,b=b&&(E===0&&p.strides[E]===1||V)}else m=m&&p.strides[E]===1&&M,b=b&&(E===0&&p.strides[E]===1||M);let C,j=!1;if(p.beginValid&&p.endValid?(C=p.end[E]-p.begin[E],j=!0):$?(C=1,j=!0):M&&I>=0&&(p.strides[E]<0?C=-I:C=I,j=!0),j){let V;C===0||C<0!=p.strides[E]<0?V=0:V=Math.trunc(C/p.strides[E])+(C%p.strides[E]!==0?1:0),S.push(V)}else S.push(-1)}for(let E=0;E<p.finalShapeGatherIndices.length;++E){const $=p.finalShapeGatherIndices[E];$>=0?x.push(S[$]):$===Xa&&x.push(1)}return{finalShapeSparse:x.filter((E,$)=>p.finalShapeGatherIndices[$]!==Xa),finalShape:x,isIdentity:m,sliceDim0:b,isSimpleSlice:v,begin:p.begin,end:p.end,strides:p.strides}}function pb(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=t.begin!=null,e.endValid=t.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const s=Math.min(e.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<s;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&t.newAxisMask)e.finalShapeGatherIndices.push(Xa),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);t.begin!=null&&(e.begin[n]=t.begin[r]),t.end!=null&&(e.end[n]=t.end[r]),e.strides[n]=t.strides[r],t.beginMask&1<<r&&(e.beginMask|=1<<n),t.endMask&1<<r&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(sb),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[n]=r,n++}}function au(t,e,n,r,s,a){if(s[e])return n>0?a[e]:a[e+1&1];{const o=t<0?r+t:t;return o<a[0]?a[0]:o>a[1]?a[1]:o}}var Sf=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:ab,maskToAxes:ob,computeOutShape:ib,stridesWithElidedDims:pf,getNormalizedAxes:ub,startIndicesWithElidedDims:gf,stopIndicesWithElidedDims:yf,stridesForAxis:bf,startForAxis:wf,stopForAxis:vf,isSliceContinous:lb,computeFlatOffset:cb,parseSliceParams:hb,sliceInfo:fb},Symbol.toStringTag,{value:"Module"}));class Nf{getClassName(){return this.constructor.className}static fromConfig(e,n){return new e(n)}}class sn{constructor(){this.classNameMap={}}static getMap(){return sn.instance==null&&(sn.instance=new sn),sn.instance}static register(e){sn.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function mn(t){N(t.className!=null,()=>"Class being registered does not have the static className property defined."),N(typeof t.className=="string",()=>"className is required to be a string, but got type "+typeof t.className),N(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),sn.register(t)}var db=Object.freeze(Object.defineProperty({__proto__:null,Serializable:Nf,SerializationMap:sn,registerClass:mn},Symbol.toStringTag,{value:"Module"}));const mb=.001,Tf=.1;function gb(t,e,n){return n==null&&(n=Co()),Ya(t,e,(r,s)=>Bo(r,s,n))}function Co(){return _.backend.floatPrecision()===32?mb:Tf}function Ya(t,e,n){let r=!0;if((Ue(t)||Ue(e))&&(r=!1),Ue(t)&&Ue(e)&&(r=!0),r){const o=t.constructor.name,i=e.constructor.name;if(o!==i)throw new Error(`Arrays are of different type. Actual: ${o}. Expected: ${i}`)}if(Array.isArray(t)&&Array.isArray(e)){const o=Vt(t),i=Vt(e);if(!zt(o,i))throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${i}]`)}const s=Ue(t)?t:$n(t),a=Ue(e)?e:$n(e);if(s.length!==a.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${a.length}.
Actual:   ${s}.
Expected: ${a}.`);for(let o=0;o<a.length;++o){const i=s[o],u=a[o];if(!n(i,u))throw new Error(`Arrays differ: actual[${o}] = ${i}, expected[${o}] = ${u}.
Actual:   ${s}.
Expected: ${a}.`)}}function yb(t,e){t().then(()=>e.fail(),()=>e())}function bb(t,e){const n=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return an(t)||an(t[0])||an(e)||an(e[0])?Ya(t,n,(r,s)=>r==s):Ya(t,e,(r,s)=>Bo(r,s,0))}function wb(t,e,n){if(n==null&&(n=Co()),!Bo(t,e,n))throw new Error(`Numbers differ: actual === ${t}, expected === ${e}`)}function Bo(t,e,n){return!isFinite(t)&&!isFinite(e)?!0:!(isNaN(t)||isNaN(e)||Math.abs(t-e)>n)}function vb(t,e,n){for(let r=0;r<t.length;r++)if(t[r]<e||t[r]>n)throw new Error(`Value out of range:${t[r]} low: ${e}, high: ${n}`)}function Sb(t,e){const n=new Float32Array(t),r=new Float32Array(e);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let s=0;s<r.length;s++)if(n[s]!==r[s])throw new Error(`Expected ArrayBuffer value at ${s} to be ${r[s]} but got ${n[s]} instead`)}function Ef(t){for(let e=0;e<t.length;e++){const n=t[e];Array.isArray(n)?Ef(n):t[e]=Vr(n)}return t}var Nb=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:Tf,expectArraysClose:gb,testEpsilon:Co,expectPromiseToFail:yb,expectArraysEqual:bb,expectNumbersClose:wb,expectValuesInRange:vb,expectArrayBuffersEqual:Sb,encodeStrings:Ef},Symbol.toStringTag,{value:"Module"}));const Tb="3.19.0";function Eb(t,e){let n=w(t,"a","add"),r=w(e,"b","add");[n,r]=Pe(n,r);const s={a:n,b:r};return _.runKernel(go,s)}const K=k({add_:Eb});function kb(t,e){let n=w(t,"a","floorDiv"),r=w(e,"b","floorDiv");[n,r]=Pe(n,r);const s={a:n,b:r};return _.runKernel(Xl,s)}const Lo=k({floorDiv_:kb});function _b(t,e){let n=w(t,"a","div"),r=w(e,"b","div");if([n,r]=Pe(n,r),n.dtype==="int32"&&r.dtype==="int32")return Lo(n,r);const s={a:n,b:r},a={};return _.runKernel(Bl,s,a)}const ke=k({div_:_b});function xb(t,e){let n=w(t,"a","mul"),r=w(e,"b","mul");[n,r]=Pe(n,r);const s={a:n,b:r};return _.runKernel(xc,s)}const U=k({mul_:xb});function $b(t){const e=w(t,"x","abs");if(e.dtype==="complex64"){const n={x:e};return _.runKernel(bl,n)}else{const n={x:e};return _.runKernel(Yu,n)}}const rt=k({abs_:$b});function Ab(t){const n={x:w(t,"x","acos")};return _.runKernel(Zu,n)}const kf=k({acos_:Ab});function Ib(t){const n={x:w(t,"x","acosh")};return _.runKernel(Ju,n)}const _f=k({acosh_:Ib});function Ob(t){N(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),N(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((s,a)=>w(s,`tensors${a}`,"addN")),n=e[0];e.forEach(s=>{if(s.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!zt(s.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return _.runKernel(Qu,r)}const xf=k({addN_:Ob});function Db(t,e=null,n=!1){const s={x:w(t,"x","all","bool")},a={axis:e,keepDims:n};return _.runKernel(el,s,a)}const $f=k({all_:Db});function Fb(t,e=null,n=!1){const s={x:w(t,"x","any","bool")},a={axis:e,keepDims:n};return _.runKernel(tl,s,a)}const Af=k({any_:Fb});function Pb(t,e=0){const r={x:w(t,"x","argMax")},s={axis:e};return _.runKernel(nl,r,s)}const Mo=k({argMax_:Pb});function Rb(t,e=0){const r={x:w(t,"x","argMin")},s={axis:e};return _.runKernel(rl,r,s)}const If=k({argMin_:Rb});function Cb(t){const n={x:w(t,"x","asin")};return _.runKernel(sl,n)}const Of=k({asin_:Cb});function Bb(t){const n={x:w(t,"x","asinh")};return _.runKernel(al,n)}const Df=k({asinh_:Bb});function Lb(t){const n={x:w(t,"x","atan")};return _.runKernel(ol,n)}const Ff=k({atan_:Lb});function Mb(t,e){let n=w(t,"a","atan2"),r=w(e,"b","atan2");[n,r]=Pe(n,r);const s={a:n,b:r};return _.runKernel(ul,s)}const Pf=k({atan2_:Mb});function zb(t){const n={x:w(t,"x","atanh")};return _.runKernel(il,n)}const Rf=k({atanh_:zb});function Vb(t,e,n,r,s="NHWC",a){const o=t[3],i=[...e,o],u=Lf(s);return Wr(t,i,n,a,r,null,null,u)}function Cf(t,e,n,r,s,a,o="channelsLast"){const[i,u]=$s(e);let l;if(o==="channelsLast")l=[i,u,t[3],t[3]];else if(o==="channelsFirst")l=[i,u,t[1],t[1]];else throw new Error(`Unknown dataFormat ${o}`);return Wr(t,l,n,r,s,a,!1,o)}function jb(t,e,n,r,s,a,o="NDHWC"){const[i,u,l]=Za(e);let c,h;if(o==="NDHWC")h="channelsLast",c=[i,u,l,t[4],t[4]];else if(o==="NCDHW")h="channelsFirst",c=[i,u,l,t[1],t[1]];else throw new Error(`Unknown dataFormat ${o}`);return Bf(t,c,n,r,s,!1,h,a)}function Wr(t,e,n,r,s,a,o=!1,i="channelsLast"){let[u,l,c,h]=[-1,-1,-1,-1];if(i==="channelsLast")[u,l,c,h]=t;else if(i==="channelsFirst")[u,h,l,c]=t;else throw new Error(`Unknown dataFormat ${i}`);const[p,m,,b]=e,[v,S]=$s(n),[x,O]=$s(r),E=er(p,x),$=er(m,O),{padInfo:I,outHeight:F,outWidth:L}=Wb(s,l,c,v,S,E,$,a,i),M=o?b*h:b;let C;return i==="channelsFirst"?C=[u,M,F,L]:i==="channelsLast"&&(C=[u,F,L,M]),{batchSize:u,dataFormat:i,inHeight:l,inWidth:c,inChannels:h,outHeight:F,outWidth:L,outChannels:M,padInfo:I,strideHeight:v,strideWidth:S,filterHeight:p,filterWidth:m,effectiveFilterHeight:E,effectiveFilterWidth:$,dilationHeight:x,dilationWidth:O,inShape:t,outShape:C,filterShape:e}}function Bf(t,e,n,r,s,a=!1,o="channelsLast",i){let[u,l,c,h,p]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[u,l,c,h,p]=t;else if(o==="channelsFirst")[u,p,l,c,h]=t;else throw new Error(`Unknown dataFormat ${o}`);const[m,b,v,,S]=e,[x,O,E]=Za(n),[$,I,F]=Za(r),L=er(m,$),M=er(b,I),C=er(v,F),{padInfo:j,outDepth:V,outHeight:G,outWidth:X}=Hb(s,l,c,h,x,O,E,L,M,C,i),ee=a?S*p:S;let he;return o==="channelsFirst"?he=[u,ee,V,G,X]:o==="channelsLast"&&(he=[u,V,G,X,ee]),{batchSize:u,dataFormat:o,inDepth:l,inHeight:c,inWidth:h,inChannels:p,outDepth:V,outHeight:G,outWidth:X,outChannels:ee,padInfo:j,strideDepth:x,strideHeight:O,strideWidth:E,filterDepth:m,filterHeight:b,filterWidth:v,effectiveFilterDepth:L,effectiveFilterHeight:M,effectiveFilterWidth:C,dilationDepth:$,dilationHeight:I,dilationWidth:F,inShape:t,outShape:he,filterShape:e}}function Ub(t,e,n,r,s){r==null&&(r=zo(t,e,n));const a=t[0],o=t[1],i=kn((a-e+2*r)/n+1,s),u=kn((o-e+2*r)/n+1,s);return[i,u]}function qb(t,e,n,r,s,a){s==null&&(s=zo(t,e,r));const o=t[0],i=t[1],u=t[2],l=kn((o-e+2*s)/r+1,a),c=kn((i-e+2*s)/r+1,a),h=kn((u-e+2*s)/r+1,a);return[l,c,h,n]}function zo(t,e,n,r=1){const s=er(e,r);return Math.floor((t[0]*(n-1)-n+s)/2)}function $s(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function Za(t){return typeof t=="number"?[t,t,t]:t}function er(t,e){return e<=1?t:t+(t-1)*(e-1)}function Wb(t,e,n,r,s,a,o,i,u){let l,c,h;if(typeof t=="number"){l={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};const m=Ub([e,n],a,r,t,i);c=m[0],h=m[1]}else if(t==="same"){c=Math.ceil(e/r),h=Math.ceil(n/s);const p=Math.max(0,(c-1)*r+a-e),m=Math.max(0,(h-1)*s+o-n),b=Math.floor(p/2),v=p-b,S=Math.floor(m/2),x=m-S;l={top:b,bottom:v,left:S,right:x,type:"SAME"}}else if(t==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-a+1)/r),h=Math.ceil((n-o+1)/s);else if(typeof t=="object"){const p=u==="channelsLast"?t[1][0]:t[2][0],m=u==="channelsLast"?t[1][1]:t[2][1],b=u==="channelsLast"?t[2][0]:t[3][0],v=u==="channelsLast"?t[2][1]:t[3][1];l={top:p,bottom:m,left:b,right:v,type:p===0&&m===0&&b===0&&v===0?"VALID":"EXPLICIT"},c=kn((e-a+p+m)/r+1,i),h=kn((n-o+b+v)/s+1,i)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:l,outHeight:c,outWidth:h}}function Hb(t,e,n,r,s,a,o,i,u,l,c){let h,p,m,b;if(typeof t=="number"){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};const S=qb([e,n,r,1],i,1,s,t,c);p=S[0],m=S[1],b=S[2]}else if(t==="same"){p=Math.ceil(e/s),m=Math.ceil(n/a),b=Math.ceil(r/o);const v=(p-1)*s+i-e,S=(m-1)*a+u-n,x=(b-1)*o+l-r,O=Math.floor(v/2),E=v-O,$=Math.floor(S/2),I=S-$,F=Math.floor(x/2),L=x-F;h={top:$,bottom:I,left:F,right:L,front:O,back:E,type:"SAME"}}else if(t==="valid")h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},p=Math.ceil((e-i+1)/s),m=Math.ceil((n-u+1)/a),b=Math.ceil((r-l+1)/o);else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:h,outDepth:p,outHeight:m,outWidth:b}}function kn(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function Pr(t){const[e,n,r]=$s(t);return e===1&&n===1&&r===1}function Yt(t,e){return Pr(t)||Pr(e)}function Lf(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function vt(t,e,n){if(n!=null){if(typeof e=="string")throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if(typeof e=="number")N(nr(e),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(s=>{N(nr(s),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${s}.`)})});else throw Error(`Error in ${t}: Unknown padding parameter: ${e}`)}}function Gb(t,e){const r={x:w(t,"x","reshape","string_or_numeric")},s={shape:e};return _.runKernel(qc,r,s)}const R=k({reshape_:Gb});function Kb(t,e,n,r,s){const a=w(t,"x","avgPool","float32"),o=1;N(Yt(n,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);let i=a,u=!1;a.rank===3&&(u=!0,i=R(a,[1,a.shape[0],a.shape[1],a.shape[2]])),N(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),vt("avgPool",r,s);const l={x:i},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s};let h=_.runKernel(ll,l,c);return h=be(h,a.dtype),u?R(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Vo=k({avgPool_:Kb});function Xb(t,e,n,r,s,a="NDHWC"){const o=w(t,"x","avgPool3d","float32");let i=o,u=!1;o.rank===4&&(u=!0,i=R(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),N(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),N(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),vt("avgPool3d",r,s);const l={x:i},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:a};let h=_.runKernel(cl,l,c);return h=be(h,i.dtype),u?R(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const Mf=k({avgPool3d_:Xb});function Yb(t,e=0){N(t.length>=1,()=>"Pass at least one tensor to concat");const n=Or(t,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),n.length===1)return Kt(n[0]);const r=n,s={axis:e};return _.runKernel(wl,r,s)}const qe=k({concat_:Yb});function Zb(t){const n={x:w(t,"x","sigmoid","float32")};return _.runKernel(ah,n)}const Mt=k({sigmoid_:Zb});function Jb(t,e,n){const r=w(t,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:e,size:n};return _.runKernel(th,s,a)}const Ne=k({slice_:Jb});function Qb(t){const n={x:w(t,"x","tanh","float32")};return _.runKernel(Eh,n)}const As=k({tanh_:Qb});function e1(t,e,n,r,s,a){const o=w(t,"forgetBias","basicLSTMCell"),i=w(e,"lstmKernel","basicLSTMCell"),u=w(n,"lstmBias","basicLSTMCell"),l=w(r,"data","basicLSTMCell"),c=w(s,"c","basicLSTMCell"),h=w(a,"h","basicLSTMCell"),p=qe([l,h],1),m=ge(p,i),b=K(m,u),v=b.shape[0],S=b.shape[1]/4,x=[v,S],O=Ne(b,[0,0],x),E=Ne(b,[0,S],x),$=Ne(b,[0,S*2],x),I=Ne(b,[0,S*3],x),F=K(U(Mt(O),As(E)),U(c,Mt(K(o,$)))),L=U(As(F),Mt(I));return[F,L]}const zf=k({basicLSTMCell_:e1});function t1(t,e,n){const r=w(t,"x","batchToSpaceND"),s=e.reduce((i,u)=>i*u);N(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),N(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),N(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const a={x:r},o={blockShape:e,crops:n};return _.runKernel(fl,a,o)}const jo=k({batchToSpaceND_:t1});function n1(t){let e;return t.rank===0||t.rank===1?e=R(t,[1,1,1,t.size]):t.rank===2?e=R(t,[1,1,t.shape[0],t.shape[1]]):t.rank===3?e=R(t,[1,t.shape[0],t.shape[1],t.shape[2]]):e=t,e}function r1(t,e,n,r,s,a){a==null&&(a=.001);const o=w(t,"x","batchNorm"),i=w(e,"mean","batchNorm"),u=w(n,"variance","batchNorm");let l;s!=null&&(l=w(s,"scale","batchNorm"));let c;r!=null&&(c=w(r,"offset","batchNorm")),N(i.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),N(c==null||i.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),N(l==null||i.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const p={x:n1(o),scale:l,offset:c,mean:i,variance:u},m={varianceEpsilon:a},b=_.runKernel(Yl,p,m);return R(b,o.shape)}const Hr=k({batchNorm_:r1});function s1(t,e,n,r,s,a){const o=w(t,"x","batchNorm"),i=w(e,"mean","batchNorm"),u=w(n,"variance","batchNorm");let l;s!=null&&(l=w(s,"scale","batchNorm"));let c;return r!=null&&(c=w(r,"offset","batchNorm")),N(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),N(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),N(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&N(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&N(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Hr(o,i,u,c,l,a)}const Vf=k({batchNorm2d_:s1});function a1(t,e,n,r,s,a){const o=w(t,"x","batchNorm"),i=w(e,"mean","batchNorm"),u=w(n,"variance","batchNorm");let l;s!=null&&(l=w(s,"scale","batchNorm"));let c;return r!=null&&(c=w(r,"offset","batchNorm")),N(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),N(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),N(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&N(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&N(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Hr(o,i,u,c,l,a)}const jf=k({batchNorm3d_:a1});function o1(t,e,n,r,s,a){const o=w(t,"x","batchNorm"),i=w(e,"mean","batchNorm"),u=w(n,"variance","batchNorm");let l;s!=null&&(l=w(s,"scale","batchNorm"));let c;return r!=null&&(c=w(r,"offset","batchNorm")),N(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),N(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),N(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&N(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&N(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Hr(o,i,u,c,l,a)}const Uf=k({batchNorm4d_:o1});function i1(t,e,n){const r=w(t,"x","bincount"),s=w(e,"weights","bincount");N(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),N(n>=0,()=>`size must be non-negative, but got ${n}.`),N(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const a={x:r,weights:s},o={size:n};return _.runKernel(pl,a,o)}const Uo=k({bincount_:i1});function u1(t,e){const n=w(t,"s0","broadcastArgs","int32"),r=w(e,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:n,s1:r};return _.runKernel(dl,s)}const qf=k({broadcastArgs_:u1});function l1(t,e){let n=w(t,"broadcastTo","x");const r=n.shape;if(e.some(l=>!(l>0)||l%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const l=n.shape.slice();for(;l.length<e.length;)l.unshift(1);n=R(n,l)}const s=n.shape,a=Array.from(e);for(let l=e.length-1;l>=0;l--)if(s[l]===e[l])a[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(a.map((l,c)=>l>1?c:-1).filter(l=>l>=0).length===0)return Kt(n);const i={x:n},u={reps:a};return _.runKernel(wo,i,u)}const _r=k({broadcastTo_:l1});function c1(t){const n={x:w(t,"x","ceil","float32")};return _.runKernel(ml,n)}const Wf=k({ceil_:c1});function h1(t,e,n){const r=w(t,"x","clipByValue");N(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`);const s={x:r},a={clipValueMin:e,clipValueMax:n};return _.runKernel(gl,s,a)}const Hf=k({clipByValue_:h1});function f1(t){return qe(t,0)}const Gf=k({concat1d_:f1});function p1(t,e){return qe(t,e)}const Kf=k({concat2d_:p1});function d1(t,e){return qe(t,e)}const Xf=k({concat3d_:d1});function m1(t,e){return qe(t,e)}const Yf=k({concat4d_:m1});function g1(t,e,n,r,s="NHWC",a=[1,1],o){const i=w(t,"x","conv2d","float32"),u=w(e,"filter","conv2d","float32");let l=i,c=!1;i.rank===3&&(c=!0,l=R(i,[1,i.shape[0],i.shape[1],i.shape[2]])),N(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),N(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),vt("conv2d",r,o);const h=s==="NHWC"?l.shape[3]:l.shape[1];N(h===u.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${u.shape[2]}.`),N(Yt(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const p={x:l,filter:u},m={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o},b=_.runKernel(vl,p,m);return c?R(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Gr=k({conv2d_:g1});function y1(t,e,n,r,s="NWC",a=1,o){const i=w(t,"x","conv1d"),u=w(e,"filter","conv1d");let l=i,c=!1;i.rank===2&&(c=!0,l=R(i,[1,i.shape[0],i.shape[1]])),N(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),N(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),vt("conv1d",r,o),N(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),N(Yt(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),N(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=R(u,[1,u.shape[0],u.shape[1],u.shape[2]]),p=R(l,[l.shape[0],1,l.shape[1],l.shape[2]]),S=Gr(p,h,[1,n],r,"NHWC",[1,a],o);return c?R(S,[S.shape[2],S.shape[3]]):R(S,[S.shape[0],S.shape[2],S.shape[3]])}const Zf=k({conv1d_:y1});function b1(t,e,n,r,s,a="NHWC",o){N(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let i=t,u=e,l=!1;e.rank===3&&(l=!0,u=R(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,t[0],t[1],t[2]]),N(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),N(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),N(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c=a==="NHWC"?i[3]:i[1],h=a==="NHWC"?u.shape[3]:u.shape[1];N(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),N(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),vt("conv2dDerInput",s,o);const p={dy:u,filter:n},m={strides:r,pad:s,dataFormat:a,dimRoundingMode:o,inputShape:i},b=_.runKernel(Nl,p,m);return l?R(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Jf=k({conv2DBackpropInput_:b1});function w1(t,e,n,r,s,a){const o=w(t,"x","conv2dTranspose"),i=w(e,"filter","conv2dTranspose");return Jf(n,o,i,r,s,"NHWC",a)}const Qf=k({conv2dTranspose_:w1});function v1(t,e,n,r,s="NDHWC",a=[1,1,1]){const o=w(t,"x","conv3d"),i=w(e,"filter","conv3d");let u=o,l=!1;o.rank===4&&(l=!0,u=R(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),N(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),N(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),N(u.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`),N(Yt(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),N(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const c={x:u,filter:i},h={strides:n,pad:r,dataFormat:s,dilations:a},p=_.runKernel(Tl,c,h);return l?R(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const ep=k({conv3d_:v1});function S1(t,e,n,r,s){N(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let a=t,o=e,i=!1;e.rank===4&&(i=!0,o=R(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),a=[1,t[0],t[1],t[2],t[3]]);const u=a[4],l=o.shape[4];N(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),N(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),N(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),N(u===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`),N(l===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`);const c={dy:o,filter:n},h={pad:s,strides:r,inputShape:a},p=_.runKernel(El,c,h);return i?R(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const N1=k({conv3DBackpropInput_:S1});function T1(t,e,n,r,s){const a=w(t,"x","conv3dTranspose"),o=w(e,"filter","conv3dTranspose");return N1(n,a,o,r,s)}const tp=k({conv3dTranspose_:T1});function E1(t){const n={x:w(t,"x","cos","float32")};return _.runKernel(kl,n)}const np=k({cos_:E1});function k1(t){const n={x:w(t,"x","cosh","float32")};return _.runKernel(_l,n)}const rp=k({cosh_:k1});function _1(t,e=0,n=!1,r=!1){const a={x:w(t,"x","cumprod")},o={axis:e,exclusive:n,reverse:r};return _.runKernel(xl,a,o)}const sp=k({cumprod_:_1});function x1(t,e=0,n=!1,r=!1){const a={x:w(t,"x","cumsum")},o={axis:e,exclusive:n,reverse:r};return _.runKernel($l,a,o)}const ap=k({cumsum_:x1});function $1(t,e,n,r=!1){const s=w(t,"x","denseBincount"),a=w(e,"weights","denseBincount");N(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),N(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),N(n>=0,()=>`size must be non-negative, but got ${n}.`),N(a.size===s.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`);const o={x:s,weights:a},i={size:n,binaryOutput:r};return _.runKernel(Il,o,i)}const op=k({denseBincount_:$1});function A1(t,e,n="NHWC"){const r=w(t,"x","depthToSpace","float32"),s=n==="NHWC"?r.shape[1]:r.shape[2],a=n==="NHWC"?r.shape[2]:r.shape[3],o=n==="NHWC"?r.shape[3]:r.shape[1];N(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),N(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),N(a*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${e} for depthToSpace with input shape
        ${r.shape}`),N(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${r.shape}`);const i={x:r},u={blockSize:e,dataFormat:n};return _.runKernel(Ol,i,u)}const ip=k({depthToSpace_:A1});function I1(t,e,n,r,s="NHWC",a=[1,1],o){const i=w(t,"x","depthwiseConv2d","float32"),u=w(e,"filter","depthwiseConv2d","float32");let l=i,c=!1;i.rank===3&&(c=!0,l=R(i,[1,i.shape[0],i.shape[1],i.shape[2]])),N(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),N(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const h=s==="NHWC"?l.shape[3]:l.shape[1];N(h===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${u.shape[2]}.`),vt("depthwiseConv2d",r,o);const p={x:l,filter:u},m={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o},b=_.runKernel(Dl,p,m);return c?R(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const zs=k({depthwiseConv2d_:I1});function O1(t){const n={x:w(t,"x","diag")};return _.runKernel(Rl,n)}const up=k({diag_:O1});function D1(t,e,n,r,s=[1,1],a="NHWC"){const o=w(t,"x","dilation2d"),i=w(e,"filter","dilation2d");N(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),N(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),N(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let u=o,l=!1;o.rank===3&&(u=R(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=!0);const c={x:u,filter:i},h={strides:n,pad:r,dilations:s},p=_.runKernel(Cl,c,h);return l?R(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const lp=k({dilation2d_:D1});function F1(t,e){let n=w(t,"a","equal","string_or_numeric"),r=w(e,"b","equal","string_or_numeric");[n,r]=Pe(n,r),Be(n.shape,r.shape);const s={a:n,b:r};return _.runKernel(Vl,s)}const Kr=k({equal_:F1});function P1(t,e,n){const r=w(e,"a","where"),s=w(n,"b","where"),a=w(t,"condition","where","bool"),o=Be(Be(a.shape,r.shape),s.shape),i=_r(a,o),u=_r(r,o),l=_r(s,o),c={condition:i,t:u,e:l};return _.runKernel(Qc,c)}const Fn=k({where_:P1});function R1(t){const n={x:w(t,"x","zerosLike")};return _.runKernel(Ih,n)}const ot=k({zerosLike_:R1});function C1(t,e){let n=w(t,"a","div"),r=w(e,"b","div");[n,r]=Pe(n,r);const s=ke(n,r),a=ot(s),o=Kr(r,a);return Fn(o,a,s)}const cp=k({divNoNan_:C1});function B1(t,e){const n=w(t,"t1","dot"),r=w(e,"t2","dot");N((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const s=n.rank===1?n.size:n.shape[1],a=r.rank===1?r.size:r.shape[0];if(N(s===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`),n.rank===1&&r.rank===1){const o=R(n,[1,-1]),i=R(r,[-1,1]),u=ge(o,i);return R(u,[])}else if(n.rank===1&&r.rank===2){const o=R(n,[1,-1]),i=R(r,[r.shape[0],r.shape[1]]),u=ge(o,i);return R(u,[u.size])}else if(n.rank===2&&r.rank===1){const o=R(r,[-1,1]),i=ge(n,o);return R(i,[i.size])}else{const o=R(r,[r.shape[0],r.shape[1]]);return ge(n,o)}}const hp=k({dot_:B1});function L1(t,...e){const n=e.map((s,a)=>w(s,`tensors${a}`,"einsum")),r={equation:t};return _.runKernel(Ll,n,r)}const fp=k({einsum_:L1});function M1(t){const n={x:w(t,"x","elu","float32")};return _.runKernel(Ml,n)}const qo=k({elu_:M1});function z1(t){let e=w(t,"x","erf");N(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=be(e,"float32"));const n={x:e};return _.runKernel(zl,n)}const pp=k({erf_:z1});function Wo(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function dp(t,e,n){const r=t.length+e.length,s=[];let a=0,o=0;for(let i=0;i<r;i++)n.indexOf(i)===-1?s.push(t[a++]):s.push(e[o++]);return s}function V1(t,e){const n=[],r=t.length;for(let a=0;a<r;a++)e.indexOf(a)===-1&&n.push(t[a]);const s=e.map(a=>t[a]);return[n,s]}function Xr(t,e){const n=e.map(r=>1);return dp(t,n,e)}function j1(t,e,n){N(Wo(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function U1(t,e){if(Wo(t,e))return null;const n=[];for(let r=0;r<e;++r)t.indexOf(r)===-1&&n.push(r);return t.forEach(r=>n.push(r)),n}function q1(t){return t.map((e,n)=>[n,e]).sort((e,n)=>e[1]-n[1]).map(e=>e[0])}function W1(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}function H1(t,e=null,n=!1){const s={x:w(t,"x","max")},a={reductionIndices:e,keepDims:n};return _.runKernel(gc,s,a)}const _n=k({max_:H1});function G1(t,e=null,n=!1){const s={x:w(t,"x","min")},a={axis:e,keepDims:n};return _.runKernel(Nc,s,a)}const Is=k({min_:G1});function K1(t,e){let n=w(t,"base","pow"),r=w(e,"exp","pow");[n,r]=Pe(n,r);const s={a:n,b:r};return _.runKernel(Bc,s)}const ir=k({pow_:K1});function se(t,e){if((Ue(t)&&e!=="string"||Array.isArray(t))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Ue(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return dn(t,[],[],e)}function X1(t){const n={x:w(t,"x","sqrt","float32")};return _.runKernel(ih,n)}const Ut=k({sqrt_:X1});function Y1(t){const e=w(t,"x","square"),n={};return _.runKernel("Square",{x:e},n)}const bt=k({square_:Y1});function Z1(t,e=null,n=!1){let r=w(t,"x","sum");r.dtype==="bool"&&(r=be(r,"int32"));const s={x:r},a={axis:e,keepDims:n};return _.runKernel(uh,s,a)}const xe=k({sum_:Z1});function J1(t,e="euclidean",n=null,r=!1){t=w(t,"x","norm");const s=mp(t,e,n);let a=s.shape;if(r){const o=Mr(n,t.shape);a=Xr(s.shape,o)}return R(s,a)}function mp(t,e,n=null){if(t.rank===0)return rt(t);if(t.rank!==1&&n===null)return mp(R(t,[-1]),e,n);if(t.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(e===1)return xe(rt(t),n);if(e===1/0)return _n(rt(t),n);if(e===-1/0)return Is(rt(t),n);if(e==="euclidean"||e===2)return Ut(xe(ir(rt(t),se(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&n.length===2){if(e===1)return _n(xe(rt(t),n[0]),n[1]-1);if(e===1/0)return _n(xe(rt(t),n[1]),n[0]);if(e===-1/0)return Is(xe(rt(t),n[1]),n[0]);if(e==="fro"||e==="euclidean")return Ut(xe(bt(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Yr=k({norm_:J1});function Q1(t,e=null,n=!1){return Yr(t,"euclidean",e,n)}const gp=k({euclideanNorm_:Q1});function ew(t){const n={x:w(t,"x","exp")};return _.runKernel(jl,n)}const hn=k({exp_:ew});function tw(t,e=0){const n=w(t,"x","expandDims","string_or_numeric");N(e<=n.rank,()=>"Axis must be <= rank of the tensor");const r={input:n},s={dim:e};return _.runKernel(Ul,r,s)}const st=k({expandDims_:tw});function nw(t){const n={x:w(t,"x","expm1")};return _.runKernel(ql,n)}const yp=k({expm1_:nw});function rw(t,e){const n=w(t,"x","tile","string_or_numeric");N(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);const r={x:n},s={reps:e};return _.runKernel(wo,r,s)}const tr=k({tile_:rw});function sw(t,e,n,r="float32"){e==null&&(e=t);const s=jt([t,e],r),a=t<=e?t:e;for(let i=0;i<a;++i)s.set(1,i,i);const o=R(s.toTensor(),[t,e]);if(n==null)return o;if(n.length===1)return tr(st(o,0),[n[0],1,1]);if(n.length===2)return tr(st(st(o,0),0),[n[0],n[1],1,1]);if(n.length===3)return tr(st(st(st(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const Ho=k({eye_:sw});function Zr(t,e,n){const r={shape:t,value:e,dtype:n};return _.runKernel(Hl,{},r)}function aw(t){const n={x:w(t,"x","floor","float32")};return _.runKernel(Kl,n)}const Go=k({floor_:aw});function ow(t,e,n=0,r=0){const s=w(t,"x","gather"),a=w(e,"indices","gather","int32"),o={x:s,indices:a},i={axis:n,batchDims:r};return _.runKernel(Zl,o,i)}const Ko=k({gather_:ow});function iw(t,e){let n=w(t,"a","greater","string_or_numeric"),r=w(e,"b","greater","string_or_numeric");[n,r]=Pe(n,r),Be(n.shape,r.shape);const s={a:n,b:r};return _.runKernel(Ql,s)}const hr=k({greater_:iw});function uw(t,e){let n=w(t,"a","greaterEqual","string_or_numeric"),r=w(e,"b","greaterEqual","string_or_numeric");[n,r]=Pe(n,r),Be(n.shape,r.shape);const s={a:n,b:r};return _.runKernel(ec,s)}const Xo=k({greaterEqual_:uw});function lw(t){const n={x:w(t,"x","isFinite")};return _.runKernel(rc,n)}const bp=k({isFinite_:lw});function cw(t){const n={x:w(t,"x","isInf")};return _.runKernel(sc,n)}const wp=k({isInf_:cw});function hw(t){const n={x:w(t,"x","isNaN")};return _.runKernel(ac,n)}const vp=k({isNaN_:hw});function fw(t,e=.2){const r={x:w(t,"x","leakyRelu")},s={alpha:e};return _.runKernel(oc,r,s)}const Yo=k({leakyRelu_:fw});function pw(t,e){let n=w(t,"a","less","string_or_numeric"),r=w(e,"b","less","string_or_numeric");[n,r]=Pe(n,r),Be(n.shape,r.shape);const s={a:n,b:r};return _.runKernel(ic,s)}const Sp=k({less_:pw});function dw(t,e){let n=w(t,"a","lessEqual","string_or_numeric"),r=w(e,"b","lessEqual","string_or_numeric");[n,r]=Pe(n,r),Be(n.shape,r.shape);const s={a:n,b:r};return _.runKernel(uc,s)}const Vs=k({lessEqual_:dw});function Np(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:t,stop:e,num:n};return _.runKernel(lc,{},r)}function mw(t,e=5,n=1,r=1,s=.5){const a=w(t,"x","localResponseNormalization");N(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),N(nr(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=a,i=!1;a.rank===3&&(i=!0,o=R(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const u={x:o},l={depthRadius:e,bias:n,alpha:r,beta:s},c=_.runKernel(mc,u,l);return i?R(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Tp=k({localResponseNormalization_:mw});function gw(t){const n={x:w(t,"x","log","float32")};return _.runKernel(cc,n)}const ur=k({log_:gw});function yw(t){const n={x:w(t,"x","log1p")};return _.runKernel(hc,n)}const Zo=k({log1p_:yw});function bw(t){return N(cn(t),()=>"The f passed in grad(f) must be a function"),(e,n)=>{const r=w(e,"x","tf.grad","string_or_numeric"),s=n!=null?w(n,"dy","tf.grad"):null;return _.tidy(()=>{const{value:a,grads:o}=_.gradients(()=>t(r),[r],s);return s!=null&&Je(a.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),js(o),o[0]})}}function ww(t){return N(cn(t),()=>"The f passed in grads(f) must be a function"),(e,n)=>{N(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const r=Or(e,"args","tf.grads","string_or_numeric"),s=n!=null?w(n,"dy","tf.grads"):null;return _.tidy(()=>{const{value:a,grads:o}=_.gradients(()=>t(...r),r,s);return s!=null&&Je(a.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),js(o),o})}}function vw(t){return N(cn(t),()=>"The f passed in valueAndGrad(f) must be a function"),(e,n)=>{N(e instanceof ye,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),N(n==null||n instanceof ye,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:r,value:s}=_.gradients(()=>t(e),[e],n);return js(r),{grad:r[0],value:s}}}function Sw(t){return N(cn(t),()=>"The f passed in valueAndGrads(f) must be a function"),(e,n)=>{N(Array.isArray(e)&&e.every(s=>s instanceof ye),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),N(n==null||n instanceof ye,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const r=_.gradients(()=>t(...e),e,n);return n!=null&&Je(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),js(r.grads),r}}function Ep(t,e){N(cn(t),()=>"The f passed in variableGrads(f) must be a function"),N(e==null||Array.isArray(e)&&e.every(l=>l instanceof Ir),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=e!=null;if(!n){e=[];for(const l in _.registeredVariables)e.push(_.registeredVariables[l])}const r=n?e.filter(l=>!l.trainable):null,s=e.length;e=e.filter(l=>l.trainable),N(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const a=!0,{value:o,grads:i}=_.gradients(t,e,null,a);N(i.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),N(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const u={};return e.forEach((l,c)=>{i[c]!=null&&(u[l.name]=i[c])}),r?.forEach(l=>u[l.name]=null),{value:o,grads:u}}function qt(t){return _.customGrad(t)}function js(t){if(t.filter(n=>n==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function Nw(t){const n={x:w(t,"x","softplus")};return _.runKernel(oh,n)}const Jo=k({softplus_:Nw});function Tw(t){const e=w(t,"x","logSigmoid");return qt(r=>({value:Lt(Jo(Lt(r))),gradFunc:o=>U(o,Mt(Lt(r)))}))(e)}const kp=k({logSigmoid_:Tw});function Ew(t,e){let n=w(t,"a","sub"),r=w(e,"b","sub");[n,r]=Pe(n,r);const s={a:n,b:r};return _.runKernel(Nh,s)}const ne=k({sub_:Ew});function kw(t,e=-1){const n=w(t,"logits","logSoftmax");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return qt((s,a)=>{const i=_n(s,e,!0),u=ne(s,i),l=ne(be(u,"float32"),ur(xe(hn(u),e,!0)));return a([l]),{value:l,gradFunc:(h,p)=>{const[m]=p,b=!0,v=hn(m);return ne(h,U(xe(h,e,b),v))}}})(n)}const _p=k({logSoftmax_:kw});function _w(t,e=null,n=!1){const r=w(t,"x","logSumExp"),s=Mr(e,r.shape),a=_n(r,s,!0),o=ne(r,a),i=hn(o),u=xe(i,s),l=ur(u),c=K(R(a,l.shape),l);if(n){const h=Xr(c.shape,s);return R(c,h)}return c}const Qo=k({logSumExp_:_w});function xw(t,e){const n=w(t,"a","logicalAnd","bool"),r=w(e,"b","logicalAnd","bool");Be(n.shape,r.shape);const s={a:n,b:r};return _.runKernel(fc,s)}const Rr=k({logicalAnd_:xw});function $w(t){const n={x:w(t,"x","logicalNot","bool")};return _.runKernel(pc,n)}const ei=k({logicalNot_:$w});function Aw(t,e){const n=w(t,"a","logicalOr","bool"),r=w(e,"b","logicalOr","bool");Be(n.shape,r.shape);const s={a:n,b:r};return _.runKernel(dc,s)}const ti=k({logicalOr_:Aw});function Iw(t,e){const n=w(t,"a","logicalXor","bool"),r=w(e,"b","logicalXor","bool");return Be(n.shape,r.shape),Rr(ti(t,e),ei(Rr(t,e)))}const xp=k({logicalXor_:Iw});const is=2147483648;function Ow(t,e,n="left"){const r=w(t,"sortedSequence","searchSorted"),s=w(e,"values","searchSorted"),a=r.shape[r.shape.length-1],o=s.shape[s.shape.length-1],i=R(r,[-1,a]),u=R(s,[-1,o]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if($e(u.shape)>=is)throw new Error(`values tensor size must less than ${is}`);if(i.shape[1]>=is)throw new Error(`trailing dim_size must less than ${is} for int32 output type, was ${i.shape[1]}`);const l={sortedSequence:i,values:u},c={side:n};return _.runKernel(Jc,l,c)}const Us=k({searchSorted_:Ow});function $p(t,e){return Us(t,e,"left")}function Dw(t,e,n,r,s){const a=w(t,"x","maxPool"),o=1;let i=a,u=!1;a.rank===3&&(u=!0,i=R(a,[1,a.shape[0],a.shape[1],a.shape[2]])),N(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),N(Yt(n,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),vt("maxPool",r,s);const l={x:i},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s},h=_.runKernel(bc,l,c);return u?R(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const ni=k({maxPool_:Dw});function Fw(t,e=[1,1,1],n,r,s,a="NDHWC"){const o=w(t,"x","maxPool3d");let i=o,u=!1;o.rank===4&&(u=!0,i=R(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),N(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),N(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),vt("maxPool3d",r,s);const l={x:i},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},h=_.runKernel(wc,l,c);return u?R(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const Ap=k({maxPool3d_:Fw});function Pw(t,e,n,r,s=!1){const o={x:w(t,"x","maxPoolWithArgmax")},i={filterSize:e,strides:n,pad:r,includeBatchInIndex:s},u=_.runKernel(vc,o,i);return{result:u[0],indexes:u[1]}}const Ip=k({maxPoolWithArgmax_:Pw});function Rw(t,e){let n=w(t,"a","maximum"),r=w(e,"b","maximum");[n,r]=Pe(n,r),n.dtype==="bool"&&(n=be(n,"int32"),r=be(r,"int32")),Be(n.shape,r.shape);const s={a:n,b:r};return _.runKernel(yc,s)}const ri=k({maximum_:Rw});function Cw(t,e=null,n=!1){const s={x:w(t,"x","mean")},a={axis:e,keepDims:n};return _.runKernel(Sc,s,a)}const Cr=k({mean_:Cw});function Pn(t,e="float32"){if(e==="complex64"){const r=Pn(t,"float32"),s=Pn(t,"float32");return Xt(r,s)}const n=Cs($e(t),e);return _.makeTensor(n,t,e)}function un(t,e="float32"){if(e==="complex64"){const r=un(t,"float32"),s=Pn(t,"float32");return Xt(r,s)}const n=ho($e(t),e);return _.makeTensor(n,t,e)}function Op(t,e,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(t===void 0)return[];let r=w(t,"x","meshgrid",t instanceof ye?t.dtype:"float32");if(e===void 0)return[r];let s=w(e,"y","meshgrid",e instanceof ye?e.dtype:"float32");const a=$e(r.shape),o=$e(s.shape);return n==="xy"?(r=R(r,[1,-1]),s=R(s,[-1,1]),[ge(un([o,1],r.dtype),r),ge(s,un([1,a],s.dtype))]):(r=R(r,[-1,1]),s=R(s,[1,-1]),[ge(r,un([1,o],r.dtype)),ge(un([a,1],s.dtype),s)])}function Bw(t,e){let n=w(t,"a","minimum"),r=w(e,"b","minimum");[n,r]=Pe(n,r),n.dtype==="bool"&&(n=be(n,"int32"),r=be(r,"int32")),Be(n.shape,r.shape);const s={a:n,b:r};return _.runKernel(Tc,s)}const si=k({minimum_:Bw});function Lw(t,e,n){N(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=w(t,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");N(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=n==="reflect"?1:0;for(let i=0;i<r.rank;i++)N(e[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),N(e[i][0]>=0&&e[i][0]<=r.shape[i]-s&&e[i][1]>=0&&e[i][1]<=r.shape[i]-s,()=>`Padding in dimension ${i} cannot be greater than or equal to ${r.shape[i]-s} or less than 0 for input of shape ${r.shape}`);const a={paddings:e,mode:n},o={x:r};return _.runKernel(Ec,o,a)}const ai=k({mirrorPad_:Lw});function Mw(t,e){let n=w(t,"a","mod"),r=w(e,"b","mod");[n,r]=Pe(n,r);const s={a:n,b:r};return _.runKernel(kc,s)}const Dp=k({mod_:Mw});function zw(t,e=null,n=!1){t=w(t,"x","moments");const r=Mr(e,t.shape),s=Cr(t,r,n);let a=s.shape;n||(a=Xr(s.shape,r));const o=bt(ne(be(t,"float32"),R(s,a))),i=Cr(o,r,n);return{mean:s,variance:i}}const Fp=k({moments_:zw});function Vw(t,e,n,r){const s=w(e,"data","multiRNNCell"),a=Or(n,"c","multiRNNCell"),o=Or(r,"h","multiRNNCell");let i=s;const u=[];for(let h=0;h<t.length;h++){const p=t[h](i,a[h],o[h]);u.push(p[0]),u.push(p[1]),i=p[1]}const l=[],c=[];for(let h=0;h<u.length;h+=2)l.push(u[h]),c.push(u[h+1]);return[l,c]}const Pp=k({multiRNNCell_:Vw});function jw(t,e,n,r=!1){const s=w(t,"logits","multinomial"),a=s.size,o=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n=n||Math.random();const u={logits:o===1?R(s,[1,-1]):s},l={numSamples:e,seed:n,normalized:r},c=_.runKernel(_c,u,l);return o===1?R(c,[c.size]):c}const Rp=k({multinomial_:jw});function Uw(t,e){let n=w(t,"a","notEqual","string_or_numeric"),r=w(e,"b","notEqual","string_or_numeric");[n,r]=Pe(n,r),Be(n.shape,r.shape);const s={a:n,b:r};return _.runKernel(Ac,s)}const oi=k({notEqual_:Uw});function qw(t){const n={x:w(t,"x","onesLike")};return _.runKernel(Fc,n)}const Cp=k({onesLike_:qw});function Ww(t,e){const n=w(t,"v1","outerProduct"),r=w(e,"v2","outerProduct");N(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);const s=R(n,[-1,1]),a=R(r,[1,-1]);return ge(s,a)}const Bp=k({outerProduct_:Ww});function Hw(t,e,n=0){const r=w(t,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:n},a={x:r};return _.runKernel(Cc,a,s)}const Mn=k({pad_:Hw});function Gw(t,e,n=0){return N(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Mn(t,[e],n)}const Lp=k({pad1d_:Gw});function Kw(t,e,n=0){return N(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Mn(t,e,n)}const Mp=k({pad2d_:Kw});function Xw(t,e,n=0){return N(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Mn(t,e,n)}const ii=k({pad3d_:Xw});function Yw(t,e,n=0){return N(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Mn(t,e,n)}const zp=k({pad4d_:Yw});function Zw(t,e,n){const r=w(t,"x","spaceToBatchND");N(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),N(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),N(r.shape.reduce((o,i,u)=>u>0&&u<=e.length?o&&(i+n[u-1][0]+n[u-1][1])%e[u-1]===0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},a={blockShape:e,paddings:n};return _.runKernel(lh,s,a)}const ui=k({spaceToBatchND_:Zw});function Jw(t,e,n,r,s,a,o){s==null&&(s=[1,1]),a==null&&(a=1),r===0&&(r="valid");const i=w(t,"x","maxPool");let u=i,l=!1;i.rank===3&&(l=!0,u=R(i,[1,i.shape[0],i.shape[1],i.shape[2]])),N(Yt(a,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`);const c=Cf(u.shape,e,a,s,r),h=[c.dilationHeight,c.dilationWidth];let p;r==="same"?p=ev([c.filterHeight,c.filterWidth],h):p=[[0,0],[0,0]];const m=h[0]===1&&h[1]===1,[b,v]=Qw([c.inHeight,c.inWidth],h,p),S=m?r:"valid",x=m?u:ui(u,h,b),E=(n==="avg"?()=>Vo(x,e,a,S,o):()=>ni(x,e,a,S,o))(),$=m?E:jo(E,h,v);return l?R($,[$.shape[1],$.shape[2],$.shape[3]]):$}function Qw(t,e,n){const r=n.map(c=>c[0]),s=n.map(c=>c[1]),a=t.concat(r,s),o=e.map((c,h)=>(c-a[h]%c)%c),i=s.map((c,h)=>c+o[h]),u=e.map((c,h)=>[r[h],i[h]]),l=e.map((c,h)=>[0,o[h]]);return[u,l]}function ev(t,e){const r=t.map((o,i)=>o+(o-1)*(e[i]-1)).map(o=>o-1),s=r.map(o=>Math.floor(o/2)),a=r.map((o,i)=>o-s[i]);return r.map((o,i)=>[s[i],a[i]])}const Vp=k({pool_:Jw});function tv(t,e){const n=w(t,"x","prelu"),r=w(e,"alpha","prelu"),s={x:n,alpha:r};return _.runKernel(Lc,s)}const li=k({prelu_:tv});function nv(t,e=null,n=!1){let r=w(t,"x","prod");r.dtype==="bool"&&(r=be(r,"int32"));const s={x:r},a={axis:e,keepDims:n};return _.runKernel(Mc,s,a)}const jp=k({prod_:nv});function rv(t,e,n){const r=$e(t);let s=null;if(n==null||n==="float32")s=new Float32Array(r);else if(n==="int32")s=new Int32Array(r);else if(n==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let a=0;a<r;a++)s[a]=e();return _.makeTensor(s,t,n)}const Up=k({rand_:rv});var qp={exports:{}};(function(t){(function(e,n,r){function s(u){var l=this,c=i();l.next=function(){var h=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=h-(l.c=h|0)},l.c=1,l.s0=c(" "),l.s1=c(" "),l.s2=c(" "),l.s0-=c(u),l.s0<0&&(l.s0+=1),l.s1-=c(u),l.s1<0&&(l.s1+=1),l.s2-=c(u),l.s2<0&&(l.s2+=1),c=null}function a(u,l){return l.c=u.c,l.s0=u.s0,l.s1=u.s1,l.s2=u.s2,l}function o(u,l){var c=new s(u),h=l&&l.state,p=c.next;return p.int32=function(){return c.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,h&&(typeof h=="object"&&a(h,c),p.state=function(){return a(c,{})}),p}function i(){var u=4022871197,l=function(c){c=String(c);for(var h=0;h<c.length;h++){u+=c.charCodeAt(h);var p=.02519603282416938*u;u=p>>>0,p-=u,p*=u,u=p>>>0,p-=u,u+=p*4294967296}return(u>>>0)*23283064365386963e-26};return l}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.alea=o})(Bt,t,!1)})(qp);var Wp={exports:{}};(function(t){(function(e,n,r){function s(i){var u=this,l="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var h=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^h^h>>>8},i===(i|0)?u.x=i:l+=i;for(var c=0;c<l.length+64;c++)u.x^=l.charCodeAt(c)|0,u.next()}function a(i,u){return u.x=i.x,u.y=i.y,u.z=i.z,u.w=i.w,u}function o(i,u){var l=new s(i),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,m=(l.next()>>>0)/4294967296,b=(p+m)/(1<<21);while(b===0);return b},h.int32=l.next,h.quick=h,c&&(typeof c=="object"&&a(c,l),h.state=function(){return a(l,{})}),h}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xor128=o})(Bt,t,!1)})(Wp);var Hp={exports:{}};(function(t){(function(e,n,r){function s(i){var u=this,l="";u.next=function(){var h=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(h^h<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,i===(i|0)?u.x=i:l+=i;for(var c=0;c<l.length+64;c++)u.x^=l.charCodeAt(c)|0,c==l.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function a(i,u){return u.x=i.x,u.y=i.y,u.z=i.z,u.w=i.w,u.v=i.v,u.d=i.d,u}function o(i,u){var l=new s(i),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,m=(l.next()>>>0)/4294967296,b=(p+m)/(1<<21);while(b===0);return b},h.int32=l.next,h.quick=h,c&&(typeof c=="object"&&a(c,l),h.state=function(){return a(l,{})}),h}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xorwow=o})(Bt,t,!1)})(Hp);var Gp={exports:{}};(function(t){(function(e,n,r){function s(i){var u=this;u.next=function(){var c=u.x,h=u.i,p,m;return p=c[h],p^=p>>>7,m=p^p<<24,p=c[h+1&7],m^=p^p>>>10,p=c[h+3&7],m^=p^p>>>3,p=c[h+4&7],m^=p^p<<7,p=c[h+7&7],p=p^p<<13,m^=p^p<<9,c[h]=m,u.i=h+1&7,m};function l(c,h){var p,m=[];if(h===(h|0))m[0]=h;else for(h=""+h,p=0;p<h.length;++p)m[p&7]=m[p&7]<<15^h.charCodeAt(p)+m[p+1&7]<<13;for(;m.length<8;)m.push(0);for(p=0;p<8&&m[p]===0;++p);for(p==8&&(m[7]=-1),c.x=m,c.i=0,p=256;p>0;--p)c.next()}l(u,i)}function a(i,u){return u.x=i.x.slice(),u.i=i.i,u}function o(i,u){i==null&&(i=+new Date);var l=new s(i),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,m=(l.next()>>>0)/4294967296,b=(p+m)/(1<<21);while(b===0);return b},h.int32=l.next,h.quick=h,c&&(c.x&&a(c,l),h.state=function(){return a(l,{})}),h}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xorshift7=o})(Bt,t,!1)})(Gp);var Kp={exports:{}};(function(t){(function(e,n,r){function s(i){var u=this;u.next=function(){var c=u.w,h=u.X,p=u.i,m,b;return u.w=c=c+1640531527|0,b=h[p+34&127],m=h[p=p+1&127],b^=b<<13,m^=m<<17,b^=b>>>15,m^=m>>>12,b=h[p]=b^m,u.i=p,b+(c^c>>>16)|0};function l(c,h){var p,m,b,v,S,x=[],O=128;for(h===(h|0)?(m=h,h=null):(h=h+"\0",m=0,O=Math.max(O,h.length)),b=0,v=-32;v<O;++v)h&&(m^=h.charCodeAt((v+32)%h.length)),v===0&&(S=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,v>=0&&(S=S+1640531527|0,p=x[v&127]^=m+S,b=p==0?b+1:0);for(b>=128&&(x[(h&&h.length||0)&127]=-1),b=127,v=4*128;v>0;--v)m=x[b+34&127],p=x[b=b+1&127],m^=m<<13,p^=p<<17,m^=m>>>15,p^=p>>>12,x[b]=m^p;c.w=S,c.X=x,c.i=b}l(u,i)}function a(i,u){return u.i=i.i,u.w=i.w,u.X=i.X.slice(),u}function o(i,u){i==null&&(i=+new Date);var l=new s(i),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,m=(l.next()>>>0)/4294967296,b=(p+m)/(1<<21);while(b===0);return b},h.int32=l.next,h.quick=h,c&&(c.X&&a(c,l),h.state=function(){return a(l,{})}),h}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xor4096=o})(Bt,t,!1)})(Kp);var Xp={exports:{}};(function(t){(function(e,n,r){function s(i){var u=this,l="";u.next=function(){var h=u.b,p=u.c,m=u.d,b=u.a;return h=h<<25^h>>>7^p,p=p-m|0,m=m<<24^m>>>8^b,b=b-h|0,u.b=h=h<<20^h>>>12^p,u.c=p=p-m|0,u.d=m<<16^p>>>16^b,u.a=b-h|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,i===Math.floor(i)?(u.a=i/4294967296|0,u.b=i|0):l+=i;for(var c=0;c<l.length+20;c++)u.b^=l.charCodeAt(c)|0,u.next()}function a(i,u){return u.a=i.a,u.b=i.b,u.c=i.c,u.d=i.d,u}function o(i,u){var l=new s(i),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,m=(l.next()>>>0)/4294967296,b=(p+m)/(1<<21);while(b===0);return b},h.int32=l.next,h.quick=h,c&&(typeof c=="object"&&a(c,l),h.state=function(){return a(l,{})}),h}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.tychei=o})(Bt,t,!1)})(Xp);var Yp={exports:{}};(function(t){(function(e,n,r){var s=256,a=6,o=52,i="random",u=r.pow(s,a),l=r.pow(2,o),c=l*2,h=s-1,p;function m($,I,F){var L=[];I=I==!0?{entropy:!0}:I||{};var M=x(S(I.entropy?[$,E(n)]:$??O(),3),L),C=new b(L),j=function(){for(var V=C.g(a),G=u,X=0;V<l;)V=(V+X)*s,G*=s,X=C.g(1);for(;V>=c;)V/=2,G/=2,X>>>=1;return(V+X)/G};return j.int32=function(){return C.g(4)|0},j.quick=function(){return C.g(4)/4294967296},j.double=j,x(E(C.S),n),(I.pass||F||function(V,G,X,ee){return ee&&(ee.S&&v(ee,C),V.state=function(){return v(C,{})}),X?(r[i]=V,G):V})(j,M,"global"in I?I.global:this==r,I.state)}function b($){var I,F=$.length,L=this,M=0,C=L.i=L.j=0,j=L.S=[];for(F||($=[F++]);M<s;)j[M]=M++;for(M=0;M<s;M++)j[M]=j[C=h&C+$[M%F]+(I=j[M])],j[C]=I;(L.g=function(V){for(var G,X=0,ee=L.i,he=L.j,we=L.S;V--;)G=we[ee=h&ee+1],X=X*s+we[h&(we[ee]=we[he=h&he+G])+(we[he]=G)];return L.i=ee,L.j=he,X})(s)}function v($,I){return I.i=$.i,I.j=$.j,I.S=$.S.slice(),I}function S($,I){var F=[],L=typeof $,M;if(I&&L=="object")for(M in $)try{F.push(S($[M],I-1))}catch{}return F.length?F:L=="string"?$:$+"\0"}function x($,I){for(var F=$+"",L,M=0;M<F.length;)I[h&M]=h&(L^=I[h&M]*19)+F.charCodeAt(M++);return E(I)}function O(){try{var $;return p&&($=p.randomBytes)?$=$(s):($=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues($)),E($)}catch{var I=e.navigator,F=I&&I.plugins;return[+new Date,e,F,e.screen,E(n)]}}function E($){return String.fromCharCode.apply(0,$)}if(x(r.random(),n),t.exports){t.exports=m;try{p=require("crypto")}catch{}}else r["seed"+i]=m})(typeof self<"u"?self:Bt,[],Math)})(Yp);var sv=qp.exports,av=Wp.exports,ov=Hp.exports,iv=Gp.exports,uv=Kp.exports,lv=Xp.exports,zn=Yp.exports;zn.alea=sv;zn.xor128=av;zn.xorwow=ov;zn.xorshift7=iv;zn.xor4096=uv;zn.tychei=lv;var ci=zn;class hi{constructor(e,n,r,s,a){this.mean=e,this.stdDev=n,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=a||Math.random();this.random=ci.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,n,r=!1;for(;!r;){let s,a,o;do s=2*this.random()-1,a=2*this.random()-1,o=s*s+a*a;while(o>=1||o===0);const i=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*s*i,n=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class cv{constructor(e,n,r,s){this.alpha=e,this.beta=1/n,this.dtype=r;const a=s||Math.random();this.randu=ci.alea(a.toString()),this.randn=new hi(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,n,r,s,a,o;for(;;){do s=this.randn.nextValue(),o=1+this.c*s;while(o<=0);if(o*=o*o,e=s*s,n=1-.331*e*e,r=.5*e+this.d*(1-o+Math.log(o)),a=this.randu(),a<n||Math.log(a)<r)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class hv{constructor(e=0,n=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=n-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);this.random=ci.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function fv(t,e,n=1,r="float32",s){if(n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const a=new cv(e,n,r,s),o=jt(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const Zp=k({randomGamma_:fv});function pv(t,e=0,n=1,r,s){if(r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const a=new hi(e,n,r,!1,s),o=jt(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const fi=k({randomNormal_:pv});function dv(t,e,n){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return fi(t,0,1,e,n)}const Jp=k({randomStandardNormal_:dv});function mv(t,e=0,n=1,r="float32",s){const a=jt(t,r),o=new hv(e,n,null,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const pi=k({randomUniform_:mv});function fn(t,e,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");const s={start:t,stop:e,step:n,dtype:r};return _.runKernel(zc,{},s)}function gv(t){const n={x:w(t,"x","reciprocal")};return _.runKernel(jc,n)}const Qp=k({reciprocal_:gv});function yv(t){const n={x:w(t,"x","relu")};return _.runKernel(Uc,n)}const Jr=k({relu_:yv});function bv(t){const n={x:w(t,"x","relu6")};return _.runKernel(Gc,n)}const di=k({relu6_:bv});function wv(t,e){const r={x:w(t,"x","reverse")},s={dims:e};return _.runKernel(Kc,r,s)}const pn=k({reverse_:wv});function vv(t){const e=w(t,"x","reverse");return N(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),pn(e,0)}const ed=k({reverse1d_:vv});function Sv(t,e){const n=w(t,"x","reverse");return N(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),pn(n,e)}const td=k({reverse2d_:Sv});function Nv(t,e){const n=w(t,"x","reverse");return N(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),pn(n,e)}const nd=k({reverse3d_:Nv});function Tv(t,e){const n=w(t,"x","reverse");return N(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),pn(n,e)}const rd=k({reverse4d_:Tv});function Ev(t){const n={x:w(t,"x","round")};return _.runKernel(Xc,n)}const mi=k({round_:Ev});function kv(t){const n={x:w(t,"x","rsqrt","float32")};return _.runKernel(Yc,n)}const sd=k({rsqrt_:kv});function _v(t){const n={x:w(t,"x","selu")};return _.runKernel(eh,n)}const ad=k({selu_:_v});function xv(t,e,n,r,s,a=[1,1],o="NHWC"){const i=w(t,"x","separableConv2d"),u=w(e,"depthwiseFilter","separableConv2d"),l=w(n,"pointwiseFilter","separableConv2d");let c=i,h=!1;if(i.rank===3&&(h=!0,c=R(i,[1,i.shape[0],i.shape[1],i.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");N(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),N(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),N(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),N(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),N(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);const p=u.shape[2],m=u.shape[3];N(l.shape[2]===p*m,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*m}, but got ${l.shape[2]}.`);const b=zs(c,u,r,s,o,a),S=Gr(b,l,1,"valid",o);return h?R(S,[S.shape[1],S.shape[2],S.shape[3]]):S}const od=k({separableConv2d_:xv});async function $v(t,e){const n=w(t,"x","setdiff1d"),r=w(e,"y","setdiff1d");N(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),N(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),N(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await n.data(),a=await r.data(),o=new Set(a);let i=0;for(let c=0;c<s.length;c++)o.has(s[c])||i++;const u=new _s([i],n.dtype),l=new _s([i],"int32");for(let c=0,h=0;c<s.length;c++)o.has(s[c])||(u.values[h]=s[c],l.values[h]=c,h++);return[u.toTensor(),l.toTensor()]}const id=$v;function Av(t){const n={x:w(t,"x","sign")};return _.runKernel(sh,n)}const ud=k({sign_:Av});function Iv(t){const n={x:w(t,"x","sin","float32")};return _.runKernel(nh,n)}const ld=k({sin_:Iv});function Ov(t){const n={x:w(t,"x","sinh")};return _.runKernel(rh,n)}const cd=k({sinh_:Ov});function Dv(t,e,n){const r=w(t,"x","slice1d");return N(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Ne(r,[e],[n])}const hd=k({slice1d_:Dv});function Fv(t,e,n){const r=w(t,"x","slice2d");return N(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Ne(r,e,n)}const fd=k({slice2d_:Fv});function Pv(t,e,n){const r=w(t,"x","slice3d");return N(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Ne(r,e,n)}const pd=k({slice3d_:Pv});function Rv(t,e,n){const r=w(t,"x","slice4d");return N(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Ne(r,e,n)}const dd=k({slice4d_:Rv});function Cv(t,e=-1){const n=w(t,"logits","softmax","float32");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const r={logits:n},s={dim:e};return _.runKernel(hh,r,s)}const md=k({softmax_:Cv});function Bv(t){N(t.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);const e={input:t};return _.runKernel(Wl,e)}const qs=k({fft_:Bv});function Lv(t){N(t.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);const e={input:t};return _.runKernel(tc,e)}const Br=k({ifft_:Lv});function Mv(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const s=R(t,[n,e]);r=Br(s)}else{const s=[n,2*(e-1)],a=R(or(t),[n,e]),o=R(Ur(t),[n,e]),i=pn(Ne(a,[0,1],[n,e-2]),1),u=U(pn(Ne(o,[0,1],[n,e-2]),1),se(-1)),l=qe([a,i],1),c=qe([o,u],1),h=R(Xt(l,c),[s[0],s[1]]);r=Br(h)}if(r=or(r),t.rank===3&&t.shape[0]!==0){const s=r,a=t.shape[0];r=R(r,[a,r.shape[0]/a,r.shape[1]]),s.dispose()}return r}const gi=k({irfft_:Mv});function zv(t,e,n=0){const s={x:w(t,"x","split")},a={numOrSizeSplits:e,axis:n};return _.runKernel(ch,s,a)}const lr=k({split_:zv});function Vv(t,e){N(t.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const r=t.size/n;let s;if(e!=null&&e<n){const b=t.shape.map(S=>0),v=t.shape.map(S=>S);v[t.shape.length-1]=e,s=Ne(t,b,v),n=e}else if(e!=null&&e>n){const b=t.shape.map(v=>v);b[t.shape.length-1]=e-n,s=qe([t,Pn(b)],t.shape.length-1),n=e}else s=t;const a=ot(s),o=R(Xt(s,a),[r,n]),i=qs(o),u=Math.floor(n/2)+1,l=or(i),c=Ur(i),h=lr(l,[u,n-u],l.shape.length-1),p=lr(c,[u,n-u],c.shape.length-1),m=s.shape.slice();return m[s.shape.length-1]=u,R(Xt(h[0],p[0]),m)}const Ws=k({rfft_:Vv});function jv(t,e){let n=w(t,"a","squaredDifference"),r=w(e,"b","squaredDifference");[n,r]=Pe(n,r),Be(n.shape,r.shape);const s={a:n,b:r},a={};return _.runKernel(yh,s,a)}const yi=k({squaredDifference_:jv});function Uv(t,e){const n=w(t,"x","squeeze","string_or_numeric");return R(n,Mu(n.shape,e).newShape)}const mt=k({squeeze_:Uv});function qv(t,e=0){const n=Or(t,"tensors","stack","string_or_numeric");N(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&N(e<=n[0].rank,()=>"Axis must be <= rank of the tensor");const r=n,s={axis:e};return _.runKernel(Rc,r,s)}const Wt=k({stack_:qv});function Wv(t,e=0){const r={x:w(t,"x","step")},s={alpha:e};return _.runKernel(Oh,r,s)}const bi=k({step_:Wv});function Hv(t,e,n,r,s=0,a=0,o=0,i=0,u=0){const c={x:w(t,"x","stridedSlice","string_or_numeric")},h={begin:e,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};return _.runKernel(bh,c,h)}const gd=k({stridedSlice_:Hv});function Gv(t){const n={x:w(t,"x","tan","float32")};return _.runKernel(Th,n)}const yd=k({tan_:Gv});function gt(t,e){Bn(t);const n=Vt(t,e);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return dn(t,null,n,e)}function xn(t,e,n){if(Bn(t),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=Vt(t,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return dn(t,e,r,n)}function bd(t,e,n){if(Bn(t),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=Vt(t,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return dn(t,e,r,n)}function wd(t,e,n){if(Bn(t),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=Vt(t,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return dn(t,e,r,n)}function vd(t,e,n){if(Bn(t),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=Vt(t,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,dn(t,e,r,n)}function Kv(t,e=1,n=!0){const r=w(t,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const a={x:r},o={k:e,sorted:n},[i,u]=_.runKernel(kh,a,o);return{values:i,indices:u}}const Sd=k({topk_:Kv});function Xv(t,e=0,n=1,r,s){if(r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new hi(e,n,r,!0,s),o=jt(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const Nd=k({truncatedNormal_:Xv});function Yv(t,e=0){const n=w(t,"x","unique","string_or_numeric");N(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},s={axis:e},[a,o]=_.runKernel(xh,r,s);return{values:a,indices:o}}const Td=k({unique_:Yv});function Zv(t,e,n){const r=w(t,"x","unsortedSegmentSum"),s=w(e,"segmentIds","unsortedSegmentSum","int32");N(nr(n),()=>"numSegments must be of dtype int");const a={x:r,segmentIds:s},o={numSegments:n};return _.runKernel(Ah,a,o)}const Ed=k({unsortedSegmentSum_:Zv});function Jv(t,e=0){const n=w(t,"x","unstack","string_or_numeric");N(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);const r={value:n},s={axis:e};return _.runKernel($h,r,s)}const gn=k({unstack_:Jv});function kd(t,e){return Us(t,e,"right")}function _d(t,e=!0,n,r){return _.makeVariable(t,e,n,r)}function xd(t,e){const n=[];for(let a=0;a<e.length;a++)e[a]&&n.push(a);const r=jt(t,"int32"),s=jt([n.length,t.length],"int32");for(let a=0;a<n.length;a++){const o=r.indexToLoc(n[a]),i=a*t.length;s.values.set(o,i)}return s.toTensor()}async function Qv(t){const e=w(t,"condition","whereAsync","bool"),n=await e.data(),r=xd(e.shape,n);return t!==e&&e.dispose(),r}const wi=Qv;async function e2(t,e,n){const r=w(t,"tensor","boolMask"),s=w(e,"mask","boolMask","bool"),a=n??0,o=s.rank,i=r.shape;N(o>0,()=>"mask cannot be scalar"),Je(i.slice(a,a+o),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let v=a;v<a+o;v++)u*=i[v];const l=i.slice(0,a).concat([u],i.slice(a+o)),c=R(r,l),h=R(s,[-1]),p=await wi(h),m=mt(p,[1]),b=Ko(c,m,a);return t!==r&&r.dispose(),e!==s&&s.dispose(),m.dispose(),c.dispose(),h.dispose(),p.dispose(),b}const $d=e2;function t2(t,e,n,r,s=!0){const a=w(t,"v","movingAverage"),o=w(e,"x","movingAverage"),i=w(n,"decay","movingAverage");Vh(a,o),N(zt(a.shape,o.shape),()=>"Shape mismatch in v and x");const u=se(1),l=ne(u,i);let c=U(ne(o,a),l);if(s){N(r!=null,()=>"When using zeroDebias: true, step is required.");const h=w(r,"step","movingAverage");c=ke(c,ne(u,ir(i,h)))}return K(a,c)}const Ad=k({movingAverage_:t2});function n2(t,e,n){const r=w(t,"indices","scatterND","int32"),s=w(e,"updates","scatterND");Ro(s,r,n);const a={indices:r,updates:s},o={shape:n};return _.runKernel(Zc,a,o)}const Id=k({scatterND_:n2});function r2(t,e,n,r){if(t.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const s=t.rank>0?t.shape[0]:1,a=t.rank>1?t.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function s2(t,e,n,r=0){const s=w(t,"sparseIndices","sparseToDense","int32"),a=w(e,"sparseValues","sparseToDense","string_or_numeric"),o=w(r,"defaultValue","sparseToDense",a.dtype);r2(s,a,n,o);const i={sparseIndices:s,sparseValues:a,defaultValue:o},u={outputShape:n};return _.runKernel(gh,i,u)}const Od=k({sparseToDense_:s2});function a2(t,e){const n=w(e,"indices","gatherND","int32"),s={params:w(t,"x","gatherND","string_or_numeric"),indices:n};return _.runKernel(Jl,s)}const Dd=k({gatherND_:a2});function o2(t,e){if(e==null)return t.shape.slice();if(zt(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)e[r]==null&&t.shape[r]!=null?n.push(t.shape[r]):n.push(e[r]);return n}return e}function i2(t,e,n,r){const s=w(t,"x","dropout");if(N(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),N(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return t instanceof ye?s.clone():s;const a=o2(s,n),o=1-e,i=ke(Go(K(pi(a,0,1,"float32",r),o)),o);return U(s,i)}const Fd=k({dropout_:i2});function vi(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function Hs(t,e,n){const r=1-t%2,s=new Float32Array(t);for(let a=0;a<t;++a){const o=2*Math.PI*a/(t+r-1);s[a]=e-n*Math.cos(o)}return gt(s,"float32")}async function u2(t,e,n=1){const r=w(t,"predictions","inTopK"),s=w(e,"targets","inTopK");N(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),N(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),Je(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=r.shape[r.shape.length-1];N(n>0&&n<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`);const o=await r.data(),i=await s.data(),[u,l]=[o.length/a,a],c=zu("bool",u);for(let h=0;h<u;h++){const p=h*l,m=o.subarray(p,p+l),b=[];for(let v=0;v<m.length;v++)b.push({value:m[v],index:v});b.sort((v,S)=>S.value-v.value),c[h]=0;for(let v=0;v<n;v++)if(b[v].index===i[h]){c[h]=1;break}}return t!==r&&r.dispose(),e!==s&&s.dispose(),yt(c,s.shape,"bool")}const Pd=u2;function l2(t,e,n,r,s,a="NHWC",o){let i=t;t.rank===3&&(i=R(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u=e;u.rank===3&&(u=R(e,[1,e.shape[0],e.shape[1],e.shape[2]])),N(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),N(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),N(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const l=a==="NHWC"?i.shape[3]:i.shape[1],c=a==="NHWC"?u.shape[3]:u.shape[1];N(l===n[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`),N(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),vt("conv2dDerFilter",s,o);const h={x:i,dy:u},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:o,filterShape:n};return _.runKernel(Sl,h,p)}const c2=k({conv2DBackpropFilter_:l2});function Gs(t,e,n){if(n==null||n==="linear")return t;if(n==="relu")return U(t,bi(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Ks(t,e){let n=e;const r=Do(t.shape,e.shape);return r.length>0&&(n=xe(n,r)),R(n,t.shape)}function Xs(t,e,n,r){if(e==="linear")return t;if(e==="relu")return Jr(t);if(e==="elu")return qo(t);if(e==="relu6")return di(t);if(e==="prelu")return li(t,n);if(e==="leakyrelu")return Yo(t,r);if(e==="sigmoid")return Mt(t);throw new Error(`Unknown fused activation ${e}.`)}const Ys=(t,e)=>!(t>0)||e==="linear";function h2({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(u=u||"linear",Ys(_.state.gradientDepth,u)===!1){N(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let F=Gr(t,e,n,r,s,a,o);return i!=null&&(F=K(F,i)),Xs(F,u,l,c)}const h=w(t,"x","conv2d","float32"),p=w(e,"filter","conv2d","float32");let m=h,b=!1;h.rank===3&&(b=!0,m=R(h,[1,h.shape[0],h.shape[1],h.shape[2]])),N(m.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${m.rank}.`),N(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),vt("fused conv2d",r,o);const v=s==="NHWC"?m.shape[3]:m.shape[1];N(p.shape[2]===v,()=>`Error in conv2d: depth of input (${v}) must match input depth for filter ${p.shape[2]}.`),N(Yt(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const S=Wr(m.shape,p.shape,n,a,r,o);let x;i!=null&&(x=w(i,"bias","fused conv2d"),[x]=Pe(x,h),s==="NHWC"?Be(S.outShape,x.shape):(N(x.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${x.shape.length}.`),N(x.shape.length===0||x.shape[0]===S.outChannels||x.shape[0]===1,()=>`Error in fused conv2d: bias shape (${x.shape}) is not compatible with the number of output channels (${S.outChannels})`)));let O;if(l!=null){const F=l.shape;if(N(F.length<=1||F.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${F.length}.`),F.length===1)N(F[0]===1||F[0]===S.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${F}) is not compatible with the number of output channels (${S.outChannels}).`);else if(F.length===3)try{Be(F,S.outShape)}catch{const M=`Error in fused conv2d: PReLU activation weights (${F}) is not compatible with the output shape of the conv2d (${S.outShape}).`;throw Error(M)}O=w(l,"prelu weights","fused conv2d")}const E=(F,L)=>{N(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[M,C,j,V]=L,G=Gs(F,j,u);N(Pr(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const X=Jf(C.shape,G,M,n,r),ee=c2(C,G,M.shape,n,r),he=[X,ee];if(V!=null){const we=Ks(V,G);he.push(we)}return he},$={x:m,filter:p,bias:x,preluActivationWeights:O},I={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:c};return i==null?qt((L,M,C)=>{let j=_.runKernel(Da,$,I);return C([M,L,j]),b&&(j=R(j,[j.shape[1],j.shape[2],j.shape[3]])),{value:j,gradFunc:E}})(m,p):qt((L,M,C,j)=>{let V=_.runKernel(Da,$,I);return j([M,L,V,C]),b&&(V=R(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:E}})(m,p,x)}const f2=k({fusedConv2d_:h2});function p2(t,e,n,r,s,a=[1,1],o){let i=t;t.rank===3&&(i=R(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u=e;u.rank===3&&(u=R(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={x:i,dy:u},c={strides:r,pad:s,dimRoundingMode:o,dilations:a,filterShape:n};return _.runKernel(Fl,l,c)}const d2=k({depthwiseConv2dNativeBackpropFilter_:p2});function m2(t,e,n,r,s,a=[1,1],o){let i=e,u=!1;e.rank===3&&(u=!0,i=R(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={dy:i,filter:n},c={strides:r,pad:s,dimRoundingMode:o,dilations:a,inputShape:t},h=_.runKernel(Pl,l,c);return u?R(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const g2=k({depthwiseConv2dNativeBackpropInput_:m2});function y2({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(Ys(_.state.gradientDepth,u)===!1){let I=zs(t,e,n,r,s,a,o);return i!=null&&(I=K(I,i)),Xs(I,u,l,c)}const h=w(t,"x","depthwiseConv2d","float32"),p=w(e,"filter","depthwiseConv2d","float32");let m=h,b=!1;h.rank===3&&(b=!0,m=R(h,[1,h.shape[0],h.shape[1],h.shape[2]])),N(m.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${m.rank}.`),N(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),N(m.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${m.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),a==null&&(a=[1,1]),N(Yt(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),vt("fused depthwiseConv2d",r,o);const v=Wr(m.shape,p.shape,n,a,r,o,!0);let S;i!=null&&(S=w(i,"bias","fused conv2d"),[S]=Pe(S,h),Be(v.outShape,S.shape));let x;l!=null&&(x=w(l,"prelu weights","fused depthwiseConv2d"));const O=(I,F)=>{N(Pr(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[L,M,C,j]=F,V=Gs(I,C,u),G=g2(M.shape,V,L,n,r,a,o),X=d2(M,V,L.shape,n,r,a,o);if(j!=null){const ee=Ks(S,V);return[G,X,ee]}return[G,X]},E={x:m,filter:p,bias:S,preluActivationWeights:x},$={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:c};return i==null?qt((F,L,M)=>{let C=_.runKernel(Fa,E,$);return M([L,F,C]),b&&(C=R(C,[C.shape[1],C.shape[2],C.shape[3]])),{value:C,gradFunc:O}})(m,p):qt((F,L,M,C)=>{let j=_.runKernel(Fa,E,$);return C([L,F,j,M]),b&&(j=R(j,[j.shape[1],j.shape[2],j.shape[3]])),{value:j,gradFunc:O}})(m,p,S)}const b2=k({fusedDepthwiseConv2d_:y2});function w2({a:t,b:e,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:o,leakyreluAlpha:i=.2}){if(Ys(_.state.gradientDepth,a)===!1){let V=ge(t,e,n,r);return s!=null&&(V=K(V,s)),Xs(V,a,o,i)}let u=w(t,"a","fused matMul"),l=w(e,"b","fused matMul");[u,l]=Pe(u,l);const c=n?u.shape[u.rank-2]:u.shape[u.rank-1],h=r?l.shape[l.rank-1]:l.shape[l.rank-2],p=n?u.shape[u.rank-1]:u.shape[u.rank-2],m=r?l.shape[l.rank-2]:l.shape[l.rank-1],b=u.shape.slice(0,-2),v=l.shape.slice(0,-2),S=$e(b),x=$e(v);N(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${n} and transposeB=${r} must match.`);const E=Be(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([p,m]),$=n?R(u,[S,c,p]):R(u,[S,p,c]),I=r?R(l,[x,m,h]):R(l,[x,h,m]);let F;s!=null&&(F=w(s,"bias","fused matMul"),[F]=Pe(F,u),Be(E,F.shape));let L;o!=null&&(L=w(o,"prelu weights","fused matMul"));const M=(V,G)=>{const[X,ee,he,we]=G,Oe=Gs(R(V,he.shape),he,a);let Ve,je;if(!n&&!r?(Ve=ge(Oe,ee,!1,!0),je=ge(X,Oe,!0,!1)):!n&&r?(Ve=ge(Oe,ee,!1,!1),je=ge(Oe,X,!0,!1)):n&&!r?(Ve=ge(ee,Oe,!1,!0),je=ge(X,Oe,!1,!1)):(Ve=ge(ee,Oe,!0,!0),je=ge(Oe,X,!0,!0)),s!=null){const Ot=Ks(we,Oe);return[Ve,je,Ot]}else return[Ve,je]},C={a:$,b:I,bias:F,preluActivationWeights:L},j={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:i};return s==null?qt((G,X,ee)=>{const he=_.runKernel(Oa,C,j);return ee([G,X,he]),{value:R(he,E),gradFunc:M}})($,I):qt((G,X,ee,he)=>{const we=_.runKernel(Oa,C,j);return he([G,X,we,ee]),{value:R(we,E),gradFunc:M}})($,I,F)}const v2=k({fusedMatMul_:w2});var Rd=Object.freeze(Object.defineProperty({__proto__:null,conv2d:f2,depthwiseConv2d:b2,matMul:v2},Symbol.toStringTag,{value:"Module"}));function S2(t){return Hs(t,.54,.46)}const N2=k({hammingWindow_:S2});function T2(t){return Hs(t,.5,.5)}const Cd=k({hannWindow_:T2});function E2(t,e,n,r=!1,s=0){let a=0;const o=[];for(;a+e<=t.size;)o.push(Ne(t,a,e)),a+=n;if(r)for(;a<t.size;){const i=a+e-t.size,u=qe([Ne(t,a,e-i),Zr([i],s)]);o.push(u),a+=n}return o.length===0?xn([],[0,e]):R(qe(o),[o.length,e])}const Bd=k({frame_:E2});function k2(t,e,n,r,s=Cd){r==null&&(r=vi(e));const a=Bd(t,e,n),o=U(a,s(e));return Ws(o,r)}const _2=k({stft_:k2});function x2(t,e,n,r,s="bilinear",a=0){const o=w(t,"image","cropAndResize"),i=w(e,"boxes","cropAndResize","float32"),u=w(n,"boxInd","cropAndResize","int32"),l=i.shape[0];N(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),N(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${i.shape}.`),N(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${i.shape}.`),N(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),N(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),N(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const c={image:o,boxes:i,boxInd:u},h={method:s,extrapolationValue:a,cropSize:r};return _.runKernel(Al,c,h)}const $2=k({cropAndResize_:x2});function A2(t){const e=w(t,"image","flipLeftRight","float32");N(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const n={image:e};return _.runKernel(Gl,n,{})}const I2=k({flipLeftRight_:A2});function O2(t){const e=w(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];N(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),N(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,n),s[n]=3,tr(e,s)}const D2=k({grayscaleToRGB_:O2});function F2(t,e,n=0,r=.5){const s=w(t,"image","rotateWithOffset","float32");N(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const a={image:s},o={radians:e,fillValue:n,center:r};return _.runKernel(Dh,a,o)}const P2=k({rotateWithOffset_:F2});function fr(t,e,n,r,s,a){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),a==null&&(a=0);const o=t.shape[0];return n=Math.min(n,o),N(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),N(t.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),N(t.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),N(e.rank===1,()=>"scores must be a 1D tensor"),N(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),N(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}function R2(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=w(t,"boxes","nonMaxSuppression","float32"),o=w(e,"scores","nonMaxSuppression","float32"),i=fr(a,o,n,r,s);n=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;const u={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return _.runKernel(Ic,{boxes:a,scores:o},u)}const C2=k({nonMaxSuppression_:R2});function B2(t,e,n){const r=L2(t,e,n),s=r<0?-(r+1):r;t.splice(s,0,e)}function L2(t,e,n){return z2(t,e,n||M2)}function M2(t,e){return t>e?1:t<e?-1:0}function z2(t,e,n){let r=0,s=t.length,a=0,o=!1;for(;r<s;){a=r+(s-r>>>1);const i=n(e,t[a]);i>0?r=a+1:(s=a,o=!i)}return o?r:-r-1}function Ld(t,e,n,r,s){return Si(t,e,n,r,s,0)}function Md(t,e,n,r,s,a){return Si(t,e,n,r,s,0,!1,a,!0)}function zd(t,e,n,r,s,a){return Si(t,e,n,r,s,a,!0)}function Si(t,e,n,r,s,a,o=!1,i=!1,u=!1){const l=[];for(let S=0;S<e.length;S++)e[S]>s&&l.push({score:e[S],boxIndex:S,suppressBeginIndex:0});l.sort(ou);const c=a>0?-.5/a:0,h=[],p=[];for(;h.length<n&&l.length>0;){const S=l.pop(),{score:x,boxIndex:O,suppressBeginIndex:E}=S;if(x<s)break;let $=!1;for(let I=h.length-1;I>=E;--I){const F=V2(t,O,h[I]);if(F>=r){$=!0;break}if(S.score=S.score*j2(r,c,F),S.score<=s)break}S.suppressBeginIndex=h.length,$||(S.score===x?(h.push(O),p.push(S.score)):S.score>s&&B2(l,S,ou))}const m=h.length,b=n-m;i&&b>0&&(h.push(...new Array(b).fill(0)),p.push(...new Array(b).fill(0)));const v={selectedIndices:h};return o&&(v.selectedScores=p),u&&(v.validOutputs=m),v}function V2(t,e,n){const r=t.subarray(e*4,e*4+4),s=t.subarray(n*4,n*4+4),a=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),p=Math.max(s[1],s[3]),m=(i-a)*(u-o),b=(h-l)*(p-c);if(m<=0||b<=0)return 0;const v=Math.max(a,l),S=Math.max(o,c),x=Math.min(i,h),O=Math.min(u,p),E=Math.max(x-v,0)*Math.max(O-S,0);return E/(m+b-E)}function j2(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function ou(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}async function U2(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=w(t,"boxes","nonMaxSuppressionAsync"),o=w(e,"scores","nonMaxSuppressionAsync"),i=fr(a,o,n,r,s);n=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;const u=await Promise.all([a.data(),o.data()]),l=u[0],c=u[1],{selectedIndices:h}=Ld(l,c,n,r,s);return a!==t&&a.dispose(),o!==e&&o.dispose(),gt(h,"int32")}const q2=U2;function W2(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const o=w(t,"boxes","nonMaxSuppression"),i=w(e,"scores","nonMaxSuppression"),u=fr(o,i,n,r,s,a);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;const l={boxes:o,scores:i},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},h=_.runKernel(Dc,l,c);return{selectedIndices:h[0],selectedScores:h[1]}}const H2=k({nonMaxSuppressionWithScore_:W2});async function G2(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const o=w(t,"boxes","nonMaxSuppressionAsync"),i=w(e,"scores","nonMaxSuppressionAsync"),u=fr(o,i,n,r,s,a);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;const l=await Promise.all([o.data(),i.data()]),c=l[0],h=l[1],{selectedIndices:p,selectedScores:m}=zd(c,h,n,r,s,a);return o!==t&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:gt(p,"int32"),selectedScores:gt(m)}}const K2=G2;function X2(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const o=w(t,"boxes","nonMaxSuppression"),i=w(e,"scores","nonMaxSuppression"),u=fr(o,i,n,r,s,null),l=u.maxOutputSize,c=u.iouThreshold,h=u.scoreThreshold,p={boxes:o,scores:i},m={maxOutputSize:l,iouThreshold:c,scoreThreshold:h,padToMaxOutputSize:a},b=_.runKernel(Oc,p,m);return{selectedIndices:b[0],validOutputs:b[1]}}const Y2=k({nonMaxSuppressionPadded_:X2});async function Z2(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const o=w(t,"boxes","nonMaxSuppressionAsync"),i=w(e,"scores","nonMaxSuppressionAsync"),u=fr(o,i,n,r,s,null),l=u.maxOutputSize,c=u.iouThreshold,h=u.scoreThreshold,[p,m]=await Promise.all([o.data(),i.data()]),{selectedIndices:b,validOutputs:v}=Md(p,m,l,c,h,a);return o!==t&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:gt(b,"int32"),validOutputs:se(v,"int32")}}const J2=Z2;function Q2(t,e,n=!1,r=!1){const s=w(t,"images","resizeBilinear");N(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),N(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),N(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=s,o=!1;s.rank===3&&(o=!0,a=R(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const i={images:a},u={alignCorners:n,halfPixelCenters:r,size:e},l=_.runKernel(Hc,i,u);return o?R(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const eS=k({resizeBilinear_:Q2});function tS(t,e,n=!1,r=!1){const s=w(t,"images","resizeNearestNeighbor");N(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),N(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),N(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),N(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=s,o=!1;s.rank===3&&(o=!0,a=R(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const i={images:a},u={alignCorners:n,halfPixelCenters:r,size:e},l=_.runKernel(Wc,i,u);return o?R(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const nS=k({resizeNearestNeighbor_:tS});function rS(t,e="binary",n=!1,r=.5){const s=w(t,"image","threshold"),a=.2989,o=.587,i=.114,u=s.shape[0]*s.shape[1];let l=U(gt([r]),255),c,h,p,m;if(N(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),N(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),N(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),N(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[c,h,p]=lr(s,[1,1,1],-1);const S=U(c,a),x=U(h,o),O=U(p,i);m=K(K(S,x),O)}else m=t;if(e==="otsu"){const S=Uo(be(mi(m),"int32"),yt([]),256);l=sS(S,u)}const b=n?Vs(m,l):hr(m,l);return be(U(b,255),"int32")}function sS(t,e){let n=gt([-1]),r=gt([0]),s=gt([0]),a,o,i,u,l,c;for(let h=0;h<t.size-1;h++){a=Ne(t,0,h+1),o=Ne(t,h+1),l=ke(xe(a),e),c=ke(xe(o),e);const p=xe(U(a,fn(0,a.size)));i=ke(p,xe(a));const m=Zr(o.shape,a.size),b=K(fn(0,o.size),m),v=U(o,b);u=ke(xe(v),xe(o));const S=ne(i,u),x=ne(i,u),O=U(l,c);s=U(U(O,S),x);const E=hr(s,r);r=Fn(E,s,r),n=Fn(E,gt([h]),n)}return n}const aS=k({threshold_:rS});function oS(t,e,n="nearest",r="constant",s=0,a){const o=w(t,"image","transform","float32"),i=w(e,"transforms","transform","float32");N(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),N(i.rank===2&&(i.shape[0]===o.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),N(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const u={image:o,transforms:i},l={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return _.runKernel(_h,u,l)}const iS=k({transform_:oS});function uS(t,e,n){N(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),N(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const r=w(t,"a","bandPart");N(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[a,o]=r.shape.slice(-2);if(!(e<=a))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${a}).`);if(!(n<=o))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`);e<0&&(e=a),n<0&&(n=o);const i=R(fn(0,a,1,"int32"),[-1,1]),u=fn(0,o,1,"int32"),l=ne(i,u),c=Rr(Vs(l,se(+e,"int32")),Xo(l,se(-n,"int32"))),h=Pn([a,o],r.dtype);return R(Wt(gn(R(r,[-1,a,o])).map(p=>Fn(c,p,h))),s)}const lS=k({bandPart_:uS});function cS(t){let e;if(Array.isArray(t)){e=!1,N(t!=null&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=t[0].shape[0];for(let a=1;a<t.length;++a)N(t[a].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[a].shape[0]} vs. ${s})`)}else e=!0,t=lr(t,t.shape[0],0).map(s=>mt(s,[0]));N(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],r=t;for(let s=0;s<t.length;++s)n.push(_.tidy(()=>{let a=r[s];if(s>0)for(let o=0;o<s;++o){const i=U(xe(U(n[o],a)),n[o]);a=ne(a,i)}return ke(a,Yr(a,"euclidean"))}));return e?Wt(n,0):n}const hS=k({gramSchmidt_:cS});function fS(t,e=!1){if(N(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),t.rank===2)return iu(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((u,l)=>u*l),r=gn(R(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),s=[],a=[];r.forEach(u=>{const[l,c]=iu(u,e);s.push(l),a.push(c)});const o=R(Wt(s,0),t.shape),i=R(Wt(a,0),t.shape);return[o,i]}}function iu(t,e=!1){return _.tidy(()=>{N(t.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],r=t.shape[1];let s=Ho(n),a=Kt(t);const o=xn([[1]],[1,1]);let i=Kt(o);const u=n>=r?r:n;for(let l=0;l<u;++l){const c=a,h=i,p=s;[i,a,s]=_.tidy(()=>{const m=Ne(a,[l,l],[n-l,1]),b=Yr(m),v=Ne(a,[l,l],[1,1]),S=Fn(hr(v,0),xn([[-1]]),xn([[1]])),x=ne(v,U(S,b)),O=ke(m,x);O.shape[0]===1?i=Kt(o):i=qe([o,Ne(O,[1,0],[O.shape[0]-1,O.shape[1]])],0);const E=Lt(ke(ge(S,x),b)),$=Ne(a,[l,0],[n-l,r]),I=U(E,i),F=Fr(i);if(l===0)a=ne($,ge(I,ge(F,$)));else{const C=ne($,ge(I,ge(F,$)));a=qe([Ne(a,[0,0],[l,r]),C],0)}const L=Fr(I),M=Ne(s,[0,l],[n,s.shape[1]-l]);if(l===0)s=ne(M,ge(ge(M,i),L));else{const C=ne(M,ge(ge(M,i),L));s=qe([Ne(s,[0,0],[n,l]),C],1)}return[i,a,s]}),et([c,h,p])}return!e&&n>r&&(s=Ne(s,[0,0],[n,r]),a=Ne(a,[0,0],[r,r])),[s,a]})}const pS=k({qr_:fS});var Ye;(function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Ye||(Ye={}));function dS(t,e,n=Ye.SUM_BY_NONZERO_WEIGHTS){const r=w(t,"losses","computeWeightedLoss");let s=null;e!=null&&(s=w(e,"weights","computeWeightedLoss"));const a=s==null?r:U(r,s);if(n===Ye.NONE)return a;if(n===Ye.SUM)return xe(a);if(n===Ye.MEAN){if(s==null)return Cr(a);{const o=r.size/s.size,i=ke(xe(a),xe(s));return o>1?ke(i,se(o)):i}}if(n===Ye.SUM_BY_NONZERO_WEIGHTS){if(s==null)return ke(xe(a),se(r.size));{const o=U(s,un(r.shape)),i=be(xe(oi(o,se(0))),"float32");return ke(xe(a),i)}}throw Error(`Unknown reduction: ${n}`)}const Zt=k({computeWeightedLoss_:dS});function mS(t,e,n,r=Ye.SUM_BY_NONZERO_WEIGHTS){const s=w(t,"labels","absoluteDifference"),a=w(e,"predictions","absoluteDifference");let o=null;n!=null&&(o=w(n,"weights","absoluteDifference")),Je(s.shape,a.shape,"Error in absoluteDifference: ");const i=rt(ne(s,a));return Zt(i,o,r)}const gS=k({absoluteDifference_:mS});function yS(t,e,n,r,s=Ye.SUM_BY_NONZERO_WEIGHTS){const a=w(t,"labels","cosineDistance"),o=w(e,"predictions","cosineDistance");let i=null;r!=null&&(i=w(r,"weights","cosineDistance")),Je(a.shape,o.shape,"Error in cosineDistance: ");const u=se(1),l=ne(u,xe(U(a,o),n,!0));return Zt(l,i,s)}const bS=k({cosineDistance_:yS});function wS(t,e,n,r=Ye.SUM_BY_NONZERO_WEIGHTS){let s=w(t,"labels","hingeLoss");const a=w(e,"predictions","hingeLoss");let o=null;n!=null&&(o=w(n,"weights","hingeLoss")),Je(s.shape,a.shape,"Error in hingeLoss: ");const i=se(1);s=ne(U(se(2),s),i);const u=Jr(ne(i,U(s,a)));return Zt(u,o,r)}const vS=k({hingeLoss_:wS});function SS(t,e,n,r=1,s=Ye.SUM_BY_NONZERO_WEIGHTS){const a=w(t,"labels","huberLoss"),o=w(e,"predictions","huberLoss");let i=null;n!=null&&(i=w(n,"weights","huberLoss")),Je(a.shape,o.shape,"Error in huberLoss: ");const u=se(r),l=rt(ne(o,a)),c=si(l,u),h=ne(l,c),p=K(U(se(.5),bt(c)),U(u,h));return Zt(p,i,s)}const NS=k({huberLoss_:SS});function TS(t,e,n,r=1e-7,s=Ye.SUM_BY_NONZERO_WEIGHTS){const a=w(t,"labels","logLoss"),o=w(e,"predictions","logLoss");let i=null;n!=null&&(i=w(n,"weights","logLoss")),Je(a.shape,o.shape,"Error in logLoss: ");const u=se(1),l=se(r),c=Lt(U(a,ur(K(o,l)))),h=U(ne(u,a),ur(K(ne(u,o),l))),p=ne(c,h);return Zt(p,i,s)}const ES=k({logLoss_:TS});function kS(t,e,n,r=Ye.SUM_BY_NONZERO_WEIGHTS){const s=w(t,"labels","meanSquaredError"),a=w(e,"predictions","meanSquaredError");let o=null;n!=null&&(o=w(n,"weights","meanSquaredError")),Je(s.shape,a.shape,"Error in meanSquaredError: ");const i=yi(s,a);return Zt(i,o,r)}const _S=k({meanSquaredError_:kS});function xS(t,e){const n=w(t,"labels","sigmoidCrossEntropyWithLogits"),r=w(e,"logits","sigmoidCrossEntropyWithLogits");Je(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Jr(r),a=U(r,n),o=Zo(hn(Lt(rt(r))));return K(ne(s,a),o)}function $S(t,e,n,r=0,s=Ye.SUM_BY_NONZERO_WEIGHTS){let a=w(t,"multiClassLabels","sigmoidCrossEntropy");const o=w(e,"logits","sigmoidCrossEntropy");let i=null;if(n!=null&&(i=w(n,"weights","sigmoidCrossEntropy")),Je(a.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const l=se(r),c=se(1),h=se(.5);a=K(U(a,ne(c,l)),U(h,l))}const u=xS(a,o);return Zt(u,i,s)}const AS=k({sigmoidCrossEntropy_:$S});function IS(t,e,n=-1){if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return qt((s,a,o)=>{const u=Qo(a,[n],!0),l=ne(be(a,"float32"),u);o([s,l]);const c=Lt(U(l,s));return{value:xe(c,[n]),gradFunc:(m,b)=>{const[v,S]=b,x=Xr(m.shape,[n]);return[U(R(m,x),ne(be(v,"float32"),hn(S))),U(R(m,x),ne(hn(S),be(v,"float32")))]}}})(t,e)}function OS(t,e,n,r=0,s=Ye.SUM_BY_NONZERO_WEIGHTS){let a=w(t,"onehotLabels","softmaxCrossEntropy");const o=w(e,"logits","softmaxCrossEntropy");let i=null;if(n!=null&&(i=w(n,"weights","softmaxCrossEntropy")),Je(a.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const l=se(r),c=se(1),h=se(a.shape[1]);a=K(U(a,ne(c,l)),ke(l,h))}const u=IS(a,o);return Zt(u,i,s)}const DS=k({softmaxCrossEntropy_:OS});function FS(t,e,n,r){const s=w(t,"indices","sparseFillEmptyRows","int32"),a=w(e,"values","sparseFillEmptyRows"),o=w(n,"denseShape","sparseFillEmptyRows","int32"),i=w(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const u={indices:s,values:a,denseShape:o,defaultValue:i},l=_.runKernel(fh,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}const PS=k({sparseFillEmptyRows_:FS});function RS(t,e,n){const r=w(t,"inputIndices","sparseReshape","int32"),s=w(e,"inputShape","sparseReshape","int32"),a=w(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const o={inputIndices:r,inputShape:s,newShape:a},i=_.runKernel(ph,o);return{outputIndices:i[0],outputShape:i[1]}}const CS=k({sparseReshape_:RS});function BS(t,e,n){const r=w(t,"data","sparseSegmentMean"),s=w(e,"indices","sparseSegmentMean","int32"),a=w(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);const o={data:r,indices:s,segmentIds:a};return _.runKernel(dh,o)}const LS=k({sparseSegmentMean_:BS});function MS(t,e,n){const r=w(t,"data","sparseSegmentSum"),s=w(e,"indices","sparseSegmentSum","int32"),a=w(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);const o={data:r,indices:s,segmentIds:a};return _.runKernel(mh,o)}const zS=k({sparseSegmentSum_:MS});function VS(t,e,n,r,s,a,o,i){const u=w(t,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const l=w(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:o,preserveShortSequences:i},h={data:u,dataSplits:l},p=_.runKernel(wh,h,c);return{nGrams:p[0],nGramsSplits:p[1]}}const jS=k({stringNGrams_:VS});function US(t,e,n=!0){const r=w(t,"input","stringSplit","string"),s=w(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a={skipEmpty:n},o={input:r,delimiter:s},i=_.runKernel(vh,o,a);return{indices:i[0],values:i[1],shape:i[2]}}const qS=k({stringSplit_:US});function WS(t,e){const n=w(t,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return _.runKernel(Sh,s,r)}const HS=k({stringToHashBucketFast_:WS});const Vd={fft:qs,ifft:Br,rfft:Ws,irfft:gi},jd={hammingWindow:N2,hannWindow:Cd,frame:Bd,stft:_2},Rn={flipLeftRight:I2,grayscaleToRGB:D2,resizeNearestNeighbor:nS,resizeBilinear:eS,rotateWithOffset:P2,cropAndResize:$2,nonMaxSuppression:C2,nonMaxSuppressionAsync:q2,nonMaxSuppressionWithScore:H2,nonMaxSuppressionWithScoreAsync:K2,nonMaxSuppressionPadded:Y2,nonMaxSuppressionPaddedAsync:J2,threshold:aS,transform:iS},Ud={bandPart:lS,gramSchmidt:hS,qr:pS},qd={absoluteDifference:gS,computeWeightedLoss:Zt,cosineDistance:bS,hingeLoss:vS,huberLoss:NS,logLoss:ES,meanSquaredError:_S,sigmoidCrossEntropy:AS,softmaxCrossEntropy:DS},Wd={sparseFillEmptyRows:PS,sparseReshape:CS,sparseSegmentMean:LS,sparseSegmentSum:zS},Hd={stringNGrams:jS,stringSplit:qS,stringToHashBucketFast:HS};class yn extends Nf{minimize(e,n=!1,r){const{value:s,grads:a}=this.computeGradients(e,r);if(r!=null){const o=r.map(i=>({name:i.name,tensor:a[i.name]}));this.applyGradients(o)}else this.applyGradients(a);return et(a),n?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,n){return Ep(e,n)}dispose(){this.iterations_!=null&&et(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:se(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(yn,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});class Zs extends yn{constructor(e,n,r=null){super(),this.learningRate=e,this.rho=n,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=_.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const a=_.registeredVariables[r],o=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:Y(()=>ot(a).variable(o))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:Y(()=>ot(a).variable(o))});const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const u=this.accumulatedGrads[s].variable,l=this.accumulatedUpdates[s].variable;Y(()=>{const c=K(U(u,this.rho),U(bt(i),1-this.rho)),h=U(ke(Ut(K(l,this.epsilon)),Ut(K(u,this.epsilon))),i),p=K(U(l,this.rho),U(bt(h),1-this.rho));u.assign(c),l.assign(p);const m=K(U(h,-this.learningRate),a);a.assign(m)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(et(this.accumulatedGrads.map(e=>e.variable)),et(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.rho,n.epsilon)}}Zs.className="Adadelta";mn(Zs);class Js extends yn{constructor(e,n=.1){super(),this.learningRate=e,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const a=_.registeredVariables[r];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:Y(()=>Zr(a.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[s].tensor:e[r];if(o==null)return;const i=this.accumulatedGrads[s].variable;Y(()=>{const u=K(i,bt(o));i.assign(u);const l=K(U(ke(o,Ut(K(u,_.backend.epsilon()))),-this.learningRate),a);a.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&et(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,n){return new e(n.learningRate,n.initialAccumulatorValue)}}Js.className="Adagrad";mn(Js);class Qs extends yn{constructor(e,n,r,s=null){super(),this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Y(()=>{this.accBeta1=se(n).variable(),this.accBeta2=se(r).variable()}),s==null&&(this.epsilon=_.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Y(()=>{const r=ne(1,this.accBeta1),s=ne(1,this.accBeta2);n.forEach((a,o)=>{const i=_.registeredVariables[a],u=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${a}/m`,variable:Y(()=>ot(i).variable(u))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${a}/v`,variable:Y(()=>ot(i).variable(u))});const l=Array.isArray(e)?e[o].tensor:e[a];if(l==null)return;const c=this.accumulatedFirstMoment[o].variable,h=this.accumulatedSecondMoment[o].variable,p=K(U(c,this.beta1),U(l,1-this.beta1)),m=K(U(h,this.beta2),U(bt(l),1-this.beta2)),b=ke(p,r),v=ke(m,s);c.assign(p),h.assign(m);const S=K(U(ke(b,K(Ut(v),this.epsilon)),-this.learningRate),i);i.assign(S)}),this.accBeta1.assign(U(this.accBeta1,this.beta1)),this.accBeta2.assign(U(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&et(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&et(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e),Y(()=>{this.accBeta1.assign(ir(this.beta1,this.iterations_+1)),this.accBeta2.assign(ir(this.beta2,this.iterations_+1))});const n=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon)}}Qs.className="Adam";mn(Qs);class ea extends yn{constructor(e,n,r,s=null,a=0){super(),this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=s,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Y(()=>{this.iteration=se(0).variable(),this.accBeta1=se(n).variable()}),s==null&&(this.epsilon=_.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Y(()=>{const r=ne(1,this.accBeta1),s=ke(-this.learningRate,K(U(this.iteration,this.decay),1));n.forEach((a,o)=>{const i=_.registeredVariables[a],u=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${a}/m`,variable:ot(i).variable(u)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${a}/v`,variable:ot(i).variable(u)});const l=Array.isArray(e)?e[o].tensor:e[a];if(l==null)return;const c=this.accumulatedFirstMoment[o].variable,h=this.accumulatedWeightedInfNorm[o].variable,p=K(U(c,this.beta1),U(l,1-this.beta1)),m=U(h,this.beta2),b=rt(l),v=ri(m,b);c.assign(p),h.assign(v);const S=K(U(ke(s,r),ke(p,K(v,this.epsilon))),i);i.assign(S)}),this.iteration.assign(K(this.iteration,1)),this.accBeta1.assign(U(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&et(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&et(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}ea.className="Adamax";mn(ea);class Qr extends yn{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const o=_.registeredVariables[r];Y(()=>{const i=K(U(this.c,a),o);o.assign(i)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Ct(se(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,n){return new e(n.learningRate)}}Qr.className="SGD";mn(Qr);class ta extends Qr{constructor(e,n,r=!1){super(e),this.learningRate=e,this.momentum=n,this.useNesterov=r,this.accumulations=[],this.m=se(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const a=_.registeredVariables[r];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:Y(()=>ot(a).variable(!1))});const o=this.accumulations[s].variable,i=Array.isArray(e)?e[s].tensor:e[r];i!=null&&Y(()=>{let u;const l=K(U(this.m,o),i);this.useNesterov?u=K(U(this.c,K(i,U(l,this.m))),a):u=K(U(this.c,l),a),o.assign(l),a.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&et(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,n){return new e(n.learningRate,n.momentum,n.useNesterov)}}ta.className="Momentum";mn(ta);class na extends yn{constructor(e,n=.9,r=0,s=null,a=!1){if(super(),this.learningRate=e,this.decay=n,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,s==null&&(this.epsilon=_.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const a=_.registeredVariables[r],o=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:Y(()=>ot(a).variable(o))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:Y(()=>ot(a).variable(o))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:Y(()=>ot(a).variable(o))});const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const u=this.accumulatedMeanSquares[s].variable,l=this.accumulatedMoments[s].variable;Y(()=>{const c=K(U(u,this.decay),U(bt(i),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[s].variable,p=K(U(h,this.decay),U(i,1-this.decay)),m=ke(U(i,this.learningRate),Ut(ne(c,K(bt(p),this.epsilon)))),b=K(U(l,this.momentum),m);u.assign(c),h.assign(p),l.assign(b);const v=ne(a,b);a.assign(v)}else{const h=K(U(u,this.decay),U(bt(i),1-this.decay)),p=K(U(l,this.momentum),ke(U(i,this.learningRate),Ut(K(h,this.epsilon))));u.assign(h),l.assign(p);const m=ne(a,p);a.assign(m)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&et(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&et(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&et(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(n*2,n*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,n){return new e(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}na.className="RMSProp";mn(na);class nn{static sgd(e){return new Qr(e)}static momentum(e,n,r=!1){return new ta(e,n,r)}static rmsprop(e,n=.9,r=0,s=null,a=!1){return new na(e,n,r,s,a)}static adam(e=.001,n=.9,r=.999,s=null){return new Qs(e,n,r,s)}static adadelta(e=.001,n=.95,r=null){return new Zs(e,n,r)}static adamax(e=.002,n=.9,r=.999,s=null,a=0){return new ea(e,n,r,s,a)}static adagrad(e,n=.1){return new Js(e,n)}}const GS={sgd:nn.sgd,momentum:nn.momentum,adadelta:nn.adadelta,adagrad:nn.adagrad,rmsprop:nn.rmsprop,adamax:nn.adamax,adam:nn.adam};const KS=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t())();function XS(){return new Promise(t=>KS(()=>t()))}function YS(t,e){const n=t[0].length;t.forEach((s,a)=>{N(s.length===n,()=>`Error in concat${n}D: rank of tensors[${a}] must be the same as the rank of the rest (${n})`)}),N(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=t[0];t.forEach((s,a)=>{for(let o=0;o<n;o++)N(o===e||s[o]===r[o],()=>`Error in concat${n}D: Shape of tensors[${a}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`)})}function ZS(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}const Ni=30;function JS(t){return t<=Ni?t:Ss(t,Math.floor(Math.sqrt(t)))}function QS(t,e,n){const r=n*(typeof t=="number"?t:t[0]),s=e*(typeof t=="number"?t:t[1]);return[r,s]}function eN(t,e,n,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(t[0]/n),s=s.concat(t.slice(1));else{s=s.concat(t[0]);const a=e.length;for(let o=0;o<a;++o)s=s.concat([t[o+1]/e[o],e[o]]);s=s.concat(t.slice(a+1))}return s}function tN(t,e,n=!0){const r=[];if(n){r.push(e);for(let s=e+1;s<t;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],a=[];for(let o=1;o<t;++o)o>=e*2+1||o%2===1?a.push(o):s.push(o);r.push(...s),r.push(0),r.push(...a)}return r}function nN(t,e,n,r=!0){const s=[];r?s.push(t[0]/n):s.push(t[0]*n);for(let a=1;a<t.length;++a)a<=e.length?r?s.push(e[a-1]*t[a]):s.push(t[a]/e[a-1]):s.push(t[a]);return s}function rN(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function sN(t,e,n){const r=t.slice(0,1);for(let s=0;s<n;++s)r.push(t[s+1]-e[s][0]-e[s][1]);return r}const aN=1.7580993408473768,oN=1.0507009873554805;const iN=.3275911,uN=.254829592,lN=-.284496736,cN=1.421413741,hN=-1.453152027,fN=1.061405429;function pN(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(t.length*2);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function dN(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function mN(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function gN(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function yN(t,e){const n=t[e*2],r=t[e*2+1];return{real:n,imag:r}}function bN(t,e,n,r){t[r*2]=e,t[r*2+1]=n}function wN(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let s=0;s<Math.ceil(t/2);s++){const a=(e?2:-2)*Math.PI*(s/t);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function vN(t,e,n){const r=(n?2:-2)*Math.PI*(t/e),s=Math.cos(r),a=Math.sin(r);return{real:s,imag:a}}const Na="->",SN=/->/g,uu=",",lu="...";function NN(t,e){t=t.replace(/\s/g,"");const n=(t.length-t.replace(SN,"").length)/Na.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Na}").`);const[r,s]=t.split(Na);N(r.indexOf(lu)===-1,()=>`The ellipsis notation ("${lu}") is not supported yet.`);const a=r.split(uu),o=a.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let p=0;p<s.length;++p){const m=s[p];if(!a.some(b=>b.indexOf(m)!==-1))throw new Error(`Output subscripts contain the label ${m} not present in the input subscripts.`);i.indexOf(m)===-1&&i.push(m)}for(let p=0;p<r.length;++p){const m=r[p];i.indexOf(m)===-1&&m!==uu&&i.push(m)}const u=new Array(a.length);for(let p=0;p<o;++p){if(new Set(a[p].split("")).size!==a[p].length)throw new Error(`Found duplicate axes in input component ${a[p]}. Support for duplicate axes in input is not implemented yet.`);u[p]=[];for(let m=0;m<a[p].length;++m)u[p].push(i.indexOf(a[p][m]))}const l=i.length,c=s.length,h=[];for(let p=c;p<l;++p)h.push(p);return{allDims:i,summedDims:h,idDims:u}}function TN(t,e){let n=new Array(t);n.fill(-1);for(let s=0;s<e.length;++s)n[e[s]]=s;const r=[];for(let s=0;s<t;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function EN(t,e,n){const r=new Array(t);for(let s=0;s<n.length;++s){const a=n[s].shape;for(let o=0;o<e[s].length;++o)r[e[s][o]]===void 0?r[e[s][o]]=a[o]:N(r[e[s][o]]===a[o],()=>`Expected dimension ${r[e[s][o]]} at axis ${o} of input shaped ${JSON.stringify(a)}, but got dimension ${a[o]}`)}}function kN(t,e){const n=t,r=[];let s=0;t.length===0&&n.push(-1),s=t.length+1;for(let o=0;o<s;++o)r.push([]);const a=[];for(let o=0;o<n.length;++o){const i=n[o],u=xN(e,i);for(const l of u)a.indexOf(l)===-1&&(r[o].push(l),a.push(l))}return{path:n,steps:r}}function _N(t){return t.every((e,n)=>e===n)}function xN(t,e){const n=[];for(let r=0;r<t.length;++r)(t[r].length===0||t[r].indexOf(e)!==-1||e===-1)&&n.push(r);return n}function $N(t,e,n=0){let r=[];if(typeof e=="number")N(t.shape[n]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(t.shape[n]/e);else{const s=e.reduce((o,i)=>(i===-1&&(o+=1),o),0);N(s<=1,()=>"There should be only one negative value in split array.");const a=e.indexOf(-1);if(a!==-1){const o=e.reduce((i,u)=>u>0?i+u:i);e[a]=t.shape[n]-o}N(t.shape[n]===e.reduce((o,i)=>o+i),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}function AN(t){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`}function IN(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function ON(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}function DN(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function FN(t,e){return`size ${t} must be non-negative, not ${e}`}function PN(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function RN(t,e){const n=$e(t),r=$e(e);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${t} outputShape= ${e}`}function CN(t,e){const n=$e(t),r=$e(e);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${t} outputShape=${e}`}function BN(){return"segment ids must be >= 0"}function LN(){return"segment ids are not increasing"}function MN(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function zN(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}function VN(t,e){let n=!1,r;for(t<=Ni?(r=t,n=!0):r=Ss(t,Math.floor(Math.sqrt(t)));!n;)r>e||r===t?n=!0:r=Ss(t,r+1);return r}function jN(t,e,n){const r=[],s=t.length;for(let a=0;a<s;a++)a!==e?r.push(t[a]):r.push(n);return r}function UN(t,e,n,r){const s=e.shape.length,a=t.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let h=0;h<r;++h)if(t.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${t.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const o=t.shape[n],i=[];let u=1,l=1,c=1;for(let h=0;h<r;++h)i.push(t.shape[h]),u*=t.shape[h];for(let h=r;h<n;h++)i.push(t.shape[h]),l*=t.shape[h];for(let h=r;h<s;h++)i.push(e.shape[h]);for(let h=n+1;h<a;h++)i.push(t.shape[h]),c*=t.shape[h];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:o,outputShape:i}}var qN=Object.freeze(Object.defineProperty({__proto__:null,segOpComputeOptimalWindowSize:VN,computeOutShape:jN,collectGatherOpShapeInfo:UN},Symbol.toStringTag,{value:"Module"}));function WN(t){try{return t.map(e=>ks(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function HN(t){return t.map(e=>Vr(e))}var GN=Object.freeze(Object.defineProperty({__proto__:null,slice_util:Sf,segment_util:qN,fromUint8ToStringArray:WN,fromStringArrayToUint8:HN,upcastType:Ls,axesAreInnerMostDims:Wo,combineLocations:dp,computeOutAndReduceShapes:V1,expandShapeToKeepDim:Xr,assertAxesAreInnerMostDims:j1,getAxesPermutation:U1,getUndoAxesPermutation:q1,getInnerMostAxes:W1,getBroadcastDims:lf,getReductionAxes:Do,assertAndGetBroadcastShape:Be,assertParamsConsistent:YS,computeOutShape:ZS,computeDilation2DInfo:Vb,computePool2DInfo:Cf,computePool3DInfo:jb,computeConv2DInfo:Wr,computeConv3DInfo:Bf,computeDefaultPad:zo,tupleValuesAreOne:Pr,eitherStridesOrDilationsAreOne:Yt,convertConv2DDataFormat:Lf,checkPadOnDimRoundingMode:vt,getFusedDyActivation:Gs,getFusedBiasGradient:Ks,applyActivation:Xs,shouldFuse:Ys,PARALLELIZE_THRESHOLD:Ni,computeOptimalWindowSize:JS,getImageCenter:QS,getReshaped:eN,getPermuted:tN,getReshapedPermuted:nN,getSliceBeginCoords:rN,getSliceSize:sN,prepareAndValidate:hf,validateUpdateShape:Po,validateInput:Ro,calculateShapes:ff,SELU_SCALEALPHA:aN,SELU_SCALE:oN,ERF_P:iN,ERF_A1:uN,ERF_A2:lN,ERF_A3:cN,ERF_A4:hN,ERF_A5:fN,warn:rn,log:Hg,mergeRealAndImagArrays:pN,splitRealAndImagArrays:dN,complexWithEvenIndex:mN,complexWithOddIndex:gN,getComplexWithIndex:yN,assignToTypedArray:bN,exponents:wN,exponent:vN,decodeEinsumEquation:NN,getEinsumPermutation:TN,checkEinsumDimSizes:EN,getEinsumComputePath:kN,isIdentityPermutation:_N,prepareSplitSize:$N,getSparseFillEmptyRowsIndicesDenseShapeMismatch:AN,getSparseFillEmptyRowsNegativeIndexErrorMessage:IN,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:ON,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:DN,getSparseReshapeNegativeOutputDimErrorMessage:FN,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:PN,getSparseReshapeInputOutputMultipleErrorMessage:RN,getSparseReshapeInputOutputMismatchErrorMessage:CN,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:BN,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:LN,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:MN,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:zN},Symbol.toStringTag,{value:"Module"}));var KN=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:Ld,nonMaxSuppressionV4Impl:Md,nonMaxSuppressionV5Impl:zd,whereImpl:xd},Symbol.toStringTag,{value:"Module"}));var Gd=Object.freeze(Object.defineProperty({__proto__:null,AdadeltaOptimizer:Zs,AdagradOptimizer:Js,AdamOptimizer:Qs,AdamaxOptimizer:ea,MomentumOptimizer:ta,Optimizer:yn,OptimizerConstructors:nn,RMSPropOptimizer:na,SGDOptimizer:Qr,Tensor:ye,TensorBuffer:_s,Variable:Ir,get Rank(){return La},sumOutType:wy,upcastType:Ls,get Reduction(){return Ye},customGrad:qt,grad:bw,grads:ww,valueAndGrad:vw,valueAndGrads:Sw,variableGrads:Ep,Environment:Ku,env:re,get ENV(){return po},nextFrame:XS,KernelBackend:Bu,DataStorage:ig,abs:rt,acos:kf,acosh:_f,add:K,addN:xf,all:$f,any:Af,argMax:Mo,argMin:If,asin:Of,asinh:Df,atan:Ff,atan2:Pf,atanh:Rf,avgPool:Vo,avgPool3d:Mf,basicLSTMCell:zf,batchToSpaceND:jo,batchNorm:Hr,batchNorm2d:Vf,batchNorm3d:jf,batchNorm4d:Uf,bincount:Uo,broadcastArgs:qf,broadcastTo:_r,buffer:jt,cast:be,ceil:Wf,clipByValue:Hf,clone:Kt,complex:Xt,concat:qe,concat1d:Gf,concat2d:Kf,concat3d:Xf,concat4d:Yf,conv1d:Zf,conv2d:Gr,conv2dTranspose:Qf,conv3d:ep,conv3dTranspose:tp,cos:np,cosh:rp,cumprod:sp,cumsum:ap,denseBincount:op,depthToSpace:ip,depthwiseConv2d:zs,diag:up,dilation2d:lp,div:ke,divNoNan:cp,dot:hp,einsum:fp,elu:qo,equal:Kr,erf:pp,euclideanNorm:gp,exp:hn,expandDims:st,expm1:yp,eye:Ho,fill:Zr,floor:Go,floorDiv:Lo,gather:Ko,greater:hr,greaterEqual:Xo,imag:Ur,isFinite:bp,isInf:wp,isNaN:vp,leakyRelu:Yo,less:Sp,lessEqual:Vs,linspace:Np,localResponseNormalization:Tp,log:ur,log1p:Zo,logSigmoid:kp,logSoftmax:_p,logSumExp:Qo,logicalAnd:Rr,logicalNot:ei,logicalOr:ti,logicalXor:xp,lowerBound:$p,matMul:ge,max:_n,maxPool:ni,maxPool3d:Ap,maxPoolWithArgmax:Ip,maximum:ri,mean:Cr,meshgrid:Op,min:Is,minimum:si,mirrorPad:ai,mod:Dp,moments:Fp,mul:U,multiRNNCell:Pp,multinomial:Rp,neg:Lt,notEqual:oi,oneHot:Dr,ones:un,onesLike:Cp,outerProduct:Bp,pad:Mn,pad1d:Lp,pad2d:Mp,pad3d:ii,pad4d:zp,pool:Vp,pow:ir,prelu:li,print:xo,prod:jp,rand:Up,randomGamma:Zp,randomNormal:fi,randomStandardNormal:Jp,randomUniform:pi,range:fn,real:or,reciprocal:Qp,relu:Jr,relu6:di,reshape:R,reverse:pn,reverse1d:ed,reverse2d:td,reverse3d:nd,reverse4d:rd,round:mi,rsqrt:sd,scalar:se,selu:ad,separableConv2d:od,setdiff1dAsync:id,sigmoid:Mt,sign:ud,sin:ld,sinh:cd,slice:Ne,slice1d:hd,slice2d:fd,slice3d:pd,slice4d:dd,softmax:md,softplus:Jo,spaceToBatchND:ui,fft:qs,ifft:Br,irfft:gi,rfft:Ws,split:lr,sqrt:Ut,square:bt,squaredDifference:yi,squeeze:mt,stack:Wt,step:bi,stridedSlice:gd,sub:ne,sum:xe,tan:yd,tanh:As,tensor:yt,tensor1d:gt,tensor2d:xn,tensor3d:Fo,tensor4d:bd,tensor5d:wd,tensor6d:vd,tile:tr,topk:Sd,truncatedNormal:Nd,unique:Td,unsortedSegmentSum:Ed,unstack:gn,upperBound:kd,variable:_d,where:Fn,whereAsync:wi,zeros:Pn,zerosLike:ot,op:k,OP_SCOPE_SUFFIX:To,booleanMaskAsync:$d,transpose:Fr,norm:Yr,movingAverage:Ad,scatterND:Id,searchSorted:Us,sparseToDense:Od,gatherND:Dd,dropout:Fd,enclosingPowerOfTwo:vi,cosineWindow:Hs,inTopKAsync:Pd,image:Rn,linalg:Ud,losses:qd,spectral:Vd,fused:Rd,signal:jd,sparse:Wd,string:Hd,train:GS,enableProdMode:x0,enableDebugMode:$0,disableDeprecationWarnings:A0,deprecationWarn:I0,disposeVariables:O0,engine:Oo,memory:D0,profile:F0,tidy:Y,dispose:et,keep:Ct,time:P0,setBackend:R0,ready:C0,getBackend:of,removeBackend:B0,findBackend:L0,findBackendFactory:M0,registerBackend:z0,backend:uf,setPlatform:V0,getKernel:Ns,getGradient:Pa,getKernelsForBackend:Ts,registerKernel:Fh,registerGradient:Gg,unregisterKernel:Kg,unregisterGradient:Xg,copyRegisteredKernels:Yg,Abs:Yu,Acos:Zu,Acosh:Ju,Add:go,AddN:Qu,All:el,Any:tl,ArgMax:nl,ArgMin:rl,Asin:sl,Asinh:al,Atan:ol,Atanh:il,Atan2:ul,AvgPool:ll,AvgPoolGrad:$g,AvgPool3D:cl,AvgPool3DGrad:Ag,BatchMatMul:hl,BatchToSpaceND:fl,Bincount:pl,BroadcastTo:Ig,BroadcastArgs:dl,Cast:yo,Ceil:ml,ClipByValue:gl,Complex:yl,ComplexAbs:bl,Concat:wl,Conv2D:vl,Conv2DBackpropFilter:Sl,Conv2DBackpropInput:Nl,Conv3D:Tl,Conv3DBackpropFilterV2:Og,Conv3DBackpropInputV2:El,Cos:kl,Cosh:_l,Cumprod:xl,Cumsum:$l,CropAndResize:Al,DenseBincount:Il,DepthToSpace:Ol,DepthwiseConv2dNative:Dl,DepthwiseConv2dNativeBackpropFilter:Fl,DepthwiseConv2dNativeBackpropInput:Pl,Diag:Rl,Dilation2D:Cl,Dilation2DBackpropInput:Dg,Dilation2DBackpropFilter:Fg,RealDiv:Bl,Einsum:Ll,Elu:Ml,EluGrad:Pg,Erf:zl,Equal:Vl,Exp:jl,ExpandDims:Ul,Expm1:ql,FFT:Wl,Fill:Hl,FlipLeftRight:Gl,Floor:Kl,FloorDiv:Xl,FusedBatchNorm:Yl,GatherV2:Zl,GatherNd:Jl,Greater:Ql,GreaterEqual:ec,Identity:bo,IFFT:tc,Imag:nc,IsFinite:rc,IsInf:sc,IsNan:ac,LeakyRelu:oc,Less:ic,LessEqual:uc,LinSpace:lc,Log:cc,Log1p:hc,LogicalAnd:fc,LogicalNot:pc,LogicalOr:dc,LogicalXor:Rg,LogSoftmax:Cg,LowerBound:Bg,LRN:mc,LRNGrad:Lg,Max:gc,Maximum:yc,MaxPool:bc,MaxPoolGrad:Mg,MaxPool3D:wc,MaxPool3DGrad:zg,MaxPoolWithArgmax:vc,Mean:Sc,Min:Nc,Minimum:Tc,MirrorPad:Ec,Mod:kc,Multinomial:_c,Multiply:xc,Neg:$c,NotEqual:Ac,NonMaxSuppressionV3:Ic,NonMaxSuppressionV4:Oc,NonMaxSuppressionV5:Dc,OnesLike:Fc,OneHot:Pc,Pack:Rc,PadV2:Cc,Pool:Vg,Pow:Bc,Prelu:Lc,Prod:Mc,Range:zc,Real:Vc,Reciprocal:jc,Relu:Uc,Reshape:qc,ResizeNearestNeighbor:Wc,ResizeNearestNeighborGrad:jg,ResizeBilinear:Hc,ResizeBilinearGrad:Ug,Relu6:Gc,Reverse:Kc,Round:Xc,Rsqrt:Yc,ScatterNd:Zc,SearchSorted:Jc,Select:Qc,Selu:eh,Slice:th,Sin:nh,Sinh:rh,Sign:sh,Sigmoid:ah,Softplus:oh,Sqrt:ih,Sum:uh,SpaceToBatchND:lh,SplitV:ch,Softmax:hh,SparseFillEmptyRows:fh,SparseReshape:ph,SparseSegmentMean:dh,SparseSegmentSum:mh,SparseToDense:gh,SquaredDifference:yh,Square:qg,StridedSlice:bh,StringNGrams:wh,StringSplit:vh,StringToHashBucketFast:Sh,Sub:Nh,Tan:Th,Tanh:Eh,Tile:wo,TopK:kh,Transform:_h,Transpose:gs,Unique:xh,Unpack:$h,UnsortedSegmentSum:Ah,UpperBound:Wg,ZerosLike:Ih,Step:Oh,FromPixels:Ia,RotateWithOffset:Dh,_FusedMatMul:Oa,FusedConv2D:Da,FusedDepthwiseConv2D:Fa,version_core:Tb,browser:tb,io:Io,math:K0,serialization:db,test_util:Nb,util:iy,backend_util:GN,broadcast_util:X0,tensor_util:Ny,slice_util:Sf,gather_util:nb,scatter_util:rb,device_util:$y,kernel_impls:KN},Symbol.toStringTag,{value:"Module"}));const XN=re();XN.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var ct;(function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"})(ct||(ct={}));var cu;(function(t){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(cu||(cu={}));const YN={};function Kd(t){return YN[t]}function d(t,e,n,r,s){const a=e.inputParams[t];if(a&&a.inputIndexStart!==void 0){const i=a.inputIndexStart,u=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?i+1:a.inputIndexEnd;if(a.type==="tensor")return Ze(e.inputNames[a.inputIndexStart],n,r,s);if(a.type==="tensors")return e.inputNames.slice(i,u).map(p=>Ze(p,n,r,s));const l=Ze(e.inputNames.slice(i)[0],n,r,s),c=l.dataSync();return a.type==="number"?c[0]:En(l.shape,c)}const o=e.attrParams[t];return o&&o.value}function Ze(t,e,n,r){const[s,a]=nt(t);if(r!=null){const i=r.getHashTableHandleByName(s);if(i!=null)return i}const o=n.currentContextIds.find(i=>!!e[Os(s,i)]);return o!==void 0?e[Os(s,o)][a]:void 0}function ZN(t,e,n){return e[Os(t,n.currentContextId)]}function Rt(t,e){const[n,r,s]=nt(t);return[Os(n,e&&e.currentContextId),r,s]}function Os(t,e){return e?`${t}-${e}`:t}function nt(t){const e=t.split(":");if(e.length===1)return[t,0,void 0];const n=e[0],r=e.length===3?e[1]:void 0,s=Number(e[e.length-1]);return[n,s,r]}function ws(t,e,n){let r=d("pad",t,e,n);if(r==="explicit"){r=d("explicitPaddings",t,e,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)s[a][0]=r[a*2],s[a][1]=r[a*2+1];return s}return r}function Ht(t){return t.kept?t:Kt(t)}const JN=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var QN=Object.freeze(Object.defineProperty({__proto__:null,json:JN},Symbol.toStringTag,{value:"Module"}));const eT=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var tT=Object.freeze(Object.defineProperty({__proto__:null,json:eT},Symbol.toStringTag,{value:"Module"}));const nT=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var rT=Object.freeze(Object.defineProperty({__proto__:null,json:nT},Symbol.toStringTag,{value:"Module"}));const sT=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var aT=Object.freeze(Object.defineProperty({__proto__:null,json:sT},Symbol.toStringTag,{value:"Module"}));const oT=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var iT=Object.freeze(Object.defineProperty({__proto__:null,json:oT},Symbol.toStringTag,{value:"Module"}));const uT=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var lT=Object.freeze(Object.defineProperty({__proto__:null,json:uT},Symbol.toStringTag,{value:"Module"}));const cT=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var hT=Object.freeze(Object.defineProperty({__proto__:null,json:cT},Symbol.toStringTag,{value:"Module"}));const fT=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var pT=Object.freeze(Object.defineProperty({__proto__:null,json:fT},Symbol.toStringTag,{value:"Module"}));const dT=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var mT=Object.freeze(Object.defineProperty({__proto__:null,json:dT},Symbol.toStringTag,{value:"Module"}));const gT=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var yT=Object.freeze(Object.defineProperty({__proto__:null,json:gT},Symbol.toStringTag,{value:"Module"}));const bT=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var wT=Object.freeze(Object.defineProperty({__proto__:null,json:bT},Symbol.toStringTag,{value:"Module"}));const vT=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var ST=Object.freeze(Object.defineProperty({__proto__:null,json:vT},Symbol.toStringTag,{value:"Module"}));const NT=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var TT=Object.freeze(Object.defineProperty({__proto__:null,json:NT},Symbol.toStringTag,{value:"Module"}));const ET=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var kT=Object.freeze(Object.defineProperty({__proto__:null,json:ET},Symbol.toStringTag,{value:"Module"}));const _T=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var xT=Object.freeze(Object.defineProperty({__proto__:null,json:_T},Symbol.toStringTag,{value:"Module"}));const $T=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var AT=Object.freeze(Object.defineProperty({__proto__:null,json:$T},Symbol.toStringTag,{value:"Module"}));const IT=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var OT=Object.freeze(Object.defineProperty({__proto__:null,json:IT},Symbol.toStringTag,{value:"Module"}));const DT=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var FT=Object.freeze(Object.defineProperty({__proto__:null,json:DT},Symbol.toStringTag,{value:"Module"}));const PT=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var RT=Object.freeze(Object.defineProperty({__proto__:null,json:PT},Symbol.toStringTag,{value:"Module"}));class hu{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[QN,tT,rT,aT,iT,lT,hT,pT,mT,yT,wT,ST,TT,kT,xT,AT,OT,FT,RT],n=[].concat(...e.map(r=>r.json));this.opMappers=n.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(e,n={}){const r=e.node,s=[],a=[],o=[],i=r.reduce((v,S)=>(v[S.name]=this.mapNode(S),S.op.startsWith("Placeholder")?s.push(v[S.name]):S.op==="Const"?a.push(v[S.name]):(S.input==null||S.input.length===0)&&o.push(v[S.name]),v),{});let u=[];const l=[];let c={},h={};n!=null&&(c=this.mapSignatureEntries(n.inputs),h=this.mapSignatureEntries(n.outputs));const p=Object.keys(i);p.forEach(v=>{const S=i[v];S.inputNames.forEach((x,O)=>{const[E,,$]=Rt(x),I=i[E];if(I.outputs!=null){const F=I.outputs.indexOf($);if(F!==-1){const L=`${E}:${F}`;S.inputNames[O]=L}}S.inputs.push(I),I.children.push(S)})}),Object.keys(h).length===0?p.forEach(v=>{const S=i[v];S.children.length===0&&l.push(S)}):Object.keys(h).forEach(v=>{const[S]=Rt(v),x=i[S];x!=null&&(x.signatureKey=h[v],l.push(x))}),Object.keys(c).length>0?Object.keys(c).forEach(v=>{const[S]=Rt(v),x=i[S];x&&(x.signatureKey=c[v],u.push(x))}):u=s;let m={};e.library!=null&&e.library.function!=null&&(m=e.library.function.reduce((v,S)=>(v[S.signature.name]=this.mapFunction(S),v),{}));const b={nodes:i,inputs:u,outputs:l,weights:a,placeholders:s,signature:n,functions:m};return o.length>0&&(b.initNodes=o),b}mapSignatureEntries(e){return Object.keys(e||{}).reduce((n,r)=>(n[e[r].name]=r,n),{})}mapNode(e){const n=Kd(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:n.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:n.outputs};return n.inputs!=null&&(r.inputParams=n.inputs.reduce((s,a)=>(s[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},s),{})),n.attrs!=null&&(r.attrParams=n.attrs.reduce((s,a)=>{const o=a.type;let i;switch(a.type){case"string":i=Ja(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=Ja(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":i=ao(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=ao(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":i=eo(e.attr,a.tfName,a.defaultValue||0),i===void 0&&!!a.tfDeprecatedName&&(i=eo(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":i=so(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=so(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":i=Qa(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=Qa(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":i=io(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=io(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":i=ro(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=ro(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":i=oo(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=oo(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":i=to(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=to(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":i=no(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=no(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":i=fu(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=fu(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return s[a.name]={value:i,type:o},s},{})),r}mapFunction(e){const n=e.nodeDef,r=[],s=[];let a={};n!=null&&(a=n.reduce((h,p)=>(h[p.name]=this.mapNode(p),p.op==="Const"&&s.push(h[p.name]),h),{}));const o=[],i=[];e.signature.inputArg.forEach(h=>{const[p]=Rt(h.name),m={name:p,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Ti(h.type),type:"dtype"}},children:[]};m.signatureKey=h.name,o.push(m),a[p]=m}),Object.keys(a).forEach(h=>{const p=a[h];p.inputNames.forEach((m,b)=>{const[v,,S]=Rt(m),x=a[v];if(x.outputs!=null){const O=x.outputs.indexOf(S);if(O!==-1){const E=`${v}:${O}`;p.inputNames[b]=E}}p.inputs.push(x),x.children.push(p)})});const l=e.ret;e.signature.outputArg.forEach(h=>{const[p,m]=Rt(l[h.name]),b=a[p];b!=null&&(b.defaultOutput=m,i.push(b))});const c=this.mapArgsToSignature(e);return{nodes:a,inputs:o,outputs:i,weights:s,placeholders:r,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r),n),{}),outputs:e.signature.outputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r,e.ret),n),{})}}mapArgToTensorInfo(e,n){let r=e.name;return n!=null&&(r=n[r]),{name:r,dtype:e.type}}}function CT(t){const e=re().global;if(typeof e.atob<"u")return e.atob(t);if(typeof Buffer<"u")return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function Xd(t,e){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):CT(t);return e?n:n.toLowerCase()}function Ja(t,e,n,r=!1){const s=t[e];return s!=null?Xd(s.s,r):n}function Qa(t,e,n){const r=t[e];return r?r.b:n}function eo(t,e,n){const r=t[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:n;return typeof s=="number"?s:parseInt(s,10)}function Ti(t){switch(typeof t=="string"&&(t=ct[t]),t){case ct.DT_FLOAT:case ct.DT_HALF:return"float32";case ct.DT_INT32:case ct.DT_INT64:case ct.DT_INT8:case ct.DT_UINT8:return"int32";case ct.DT_BOOL:return"bool";case ct.DT_DOUBLE:return"float32";case ct.DT_STRING:return"string";default:return null}}function fu(t,e,n){const r=t[e];return r&&r.func?r.func.name:n}function to(t,e,n){const r=t[e];return r&&r.type?Ti(r.type):n}function no(t,e,n){const r=t[e];return r&&r.list&&r.list.type?r.list.type.map(s=>Ti(s)):n}function Yd(t){if(!t.unknownRank)return t.dim!=null?t.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function ro(t,e,n){const r=t[e];return r&&r.shape?Yd(r.shape):n}function so(t,e,n){const r=t[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):n}function ao(t,e,n,r=!1){const s=t[e];return s&&s.list&&s.list.s?s.list.s.map(a=>Xd(a,r)):n}function oo(t,e,n){const r=t[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>Yd(s)):n}function io(t,e,n){const r=t[e];return r&&r.list&&r.list.b?r.list.b:n}class BT{constructor(e,n,r){this.node=e,this.tensorMap=n,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,a)=>(s[a]=this.getAttr(a),s),{}))}getInput(e){return Ze(e,this.tensorMap,this.context)}getAttr(e,n){const r=this.node.rawAttrs[e];if(r.tensor!=null)return Ze(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return eo(this.node.rawAttrs,e,n);if(r.s!=null)return Ja(this.node.rawAttrs,e,n);if(r.b!=null)return Qa(this.node.rawAttrs,e,n);if(r.shape!=null)return ro(this.node.rawAttrs,e,n);if(r.type!=null)return to(this.node.rawAttrs,e,n);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return so(this.node.rawAttrs,e,n);if(r.list.s!=null)return ao(this.node.rawAttrs,e,n);if(r.list.shape!=null)return oo(this.node.rawAttrs,e,n);if(r.list.b!=null)return io(this.node.rawAttrs,e,n);if(r.list.type!=null)return no(this.node.rawAttrs,e,n)}return n}}var We=Object.freeze(Object.defineProperty({__proto__:null,abs:rt,acos:kf,acosh:_f,add:K,addN:xf,all:$f,any:Af,argMax:Mo,argMin:If,asin:Of,asinh:Df,atan:Ff,atan2:Pf,atanh:Rf,avgPool:Vo,avgPool3d:Mf,basicLSTMCell:zf,batchToSpaceND:jo,batchNorm:Hr,batchNorm2d:Vf,batchNorm3d:jf,batchNorm4d:Uf,bincount:Uo,broadcastArgs:qf,broadcastTo:_r,buffer:jt,cast:be,ceil:Wf,clipByValue:Hf,clone:Kt,complex:Xt,concat:qe,concat1d:Gf,concat2d:Kf,concat3d:Xf,concat4d:Yf,conv1d:Zf,conv2d:Gr,conv2dTranspose:Qf,conv3d:ep,conv3dTranspose:tp,cos:np,cosh:rp,cumprod:sp,cumsum:ap,denseBincount:op,depthToSpace:ip,depthwiseConv2d:zs,diag:up,dilation2d:lp,div:ke,divNoNan:cp,dot:hp,einsum:fp,elu:qo,equal:Kr,erf:pp,euclideanNorm:gp,exp:hn,expandDims:st,expm1:yp,eye:Ho,fill:Zr,floor:Go,floorDiv:Lo,gather:Ko,greater:hr,greaterEqual:Xo,imag:Ur,isFinite:bp,isInf:wp,isNaN:vp,leakyRelu:Yo,less:Sp,lessEqual:Vs,linspace:Np,localResponseNormalization:Tp,log:ur,log1p:Zo,logSigmoid:kp,logSoftmax:_p,logSumExp:Qo,logicalAnd:Rr,logicalNot:ei,logicalOr:ti,logicalXor:xp,lowerBound:$p,matMul:ge,max:_n,maxPool:ni,maxPool3d:Ap,maxPoolWithArgmax:Ip,maximum:ri,mean:Cr,meshgrid:Op,min:Is,minimum:si,mirrorPad:ai,mod:Dp,moments:Fp,mul:U,multiRNNCell:Pp,multinomial:Rp,neg:Lt,notEqual:oi,oneHot:Dr,ones:un,onesLike:Cp,outerProduct:Bp,pad:Mn,pad1d:Lp,pad2d:Mp,pad3d:ii,pad4d:zp,pool:Vp,pow:ir,prelu:li,print:xo,prod:jp,rand:Up,randomGamma:Zp,randomNormal:fi,randomStandardNormal:Jp,randomUniform:pi,range:fn,real:or,reciprocal:Qp,relu:Jr,relu6:di,reshape:R,reverse:pn,reverse1d:ed,reverse2d:td,reverse3d:nd,reverse4d:rd,round:mi,rsqrt:sd,scalar:se,selu:ad,separableConv2d:od,setdiff1dAsync:id,sigmoid:Mt,sign:ud,sin:ld,sinh:cd,slice:Ne,slice1d:hd,slice2d:fd,slice3d:pd,slice4d:dd,softmax:md,softplus:Jo,spaceToBatchND:ui,fft:qs,ifft:Br,irfft:gi,rfft:Ws,split:lr,sqrt:Ut,square:bt,squaredDifference:yi,squeeze:mt,stack:Wt,step:bi,stridedSlice:gd,sub:ne,sum:xe,tan:yd,tanh:As,tensor:yt,tensor1d:gt,tensor2d:xn,tensor3d:Fo,tensor4d:bd,tensor5d:wd,tensor6d:vd,tile:tr,topk:Sd,truncatedNormal:Nd,unique:Td,unsortedSegmentSum:Ed,unstack:gn,upperBound:kd,variable:_d,where:Fn,whereAsync:wi,zeros:Pn,zerosLike:ot,op:k,OP_SCOPE_SUFFIX:To,booleanMaskAsync:$d,transpose:Fr,norm:Yr,movingAverage:Ad,scatterND:Id,searchSorted:Us,sparseToDense:Od,gatherND:Dd,dropout:Fd,enclosingPowerOfTwo:vi,cosineWindow:Hs,inTopKAsync:Pd,image:Rn,linalg:Ud,losses:qd,spectral:Vd,fused:Rd,signal:jd,sparse:Wd,string:Hd},Symbol.toStringTag,{value:"Module"}));const LT=(t,e,n,r=We)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(d("a",t,e,n),d("b",t,e,n))];case"AddN":return[r.addN(d("tensors",t,e,n))];case"FloorMod":case"Mod":return[r.mod(d("a",t,e,n),d("b",t,e,n))];case"Mul":return[r.mul(d("a",t,e,n),d("b",t,e,n))];case"RealDiv":case"Div":return[r.div(d("a",t,e,n),d("b",t,e,n))];case"DivNoNan":return[r.divNoNan(d("a",t,e,n),d("b",t,e,n))];case"FloorDiv":return[r.floorDiv(d("a",t,e,n),d("b",t,e,n))];case"Sub":return[r.sub(d("a",t,e,n),d("b",t,e,n))];case"Minimum":return[r.minimum(d("a",t,e,n),d("b",t,e,n))];case"Maximum":return[r.maximum(d("a",t,e,n),d("b",t,e,n))];case"Pow":return[r.pow(d("a",t,e,n),d("b",t,e,n))];case"SquaredDifference":return[r.squaredDifference(d("a",t,e,n),d("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const MT=(t,e,n,r=We)=>{switch(t.op){case"Abs":case"ComplexAbs":return[r.abs(d("x",t,e,n))];case"Acos":return[r.acos(d("x",t,e,n))];case"Acosh":return[r.acosh(d("x",t,e,n))];case"Asin":return[r.asin(d("x",t,e,n))];case"Asinh":return[r.asinh(d("x",t,e,n))];case"Atan":return[r.atan(d("x",t,e,n))];case"Atan2":return[r.atan2(d("x",t,e,n),d("y",t,e,n))];case"Atanh":return[r.atanh(d("x",t,e,n))];case"Ceil":return[r.ceil(d("x",t,e,n))];case"Complex":return[r.complex(d("real",t,e,n),d("imag",t,e,n))];case"Cos":return[r.cos(d("x",t,e,n))];case"Cosh":return[r.cosh(d("x",t,e,n))];case"Elu":return[r.elu(d("x",t,e,n))];case"Erf":return[r.erf(d("x",t,e,n))];case"Exp":return[r.exp(d("x",t,e,n))];case"Expm1":return[r.expm1(d("x",t,e,n))];case"Floor":return[r.floor(d("x",t,e,n))];case"Log":return[r.log(d("x",t,e,n))];case"Log1p":return[r.log1p(d("x",t,e,n))];case"Imag":return[r.imag(d("x",t,e,n))];case"Neg":return[r.neg(d("x",t,e,n))];case"Reciprocal":return[r.reciprocal(d("x",t,e,n))];case"Real":return[r.real(d("x",t,e,n))];case"Relu":return[r.relu(d("x",t,e,n))];case"Round":return[r.round(d("x",t,e,n))];case"Selu":return[r.selu(d("x",t,e,n))];case"Sigmoid":return[r.sigmoid(d("x",t,e,n))];case"Sin":return[r.sin(d("x",t,e,n))];case"Sign":return[r.sign(d("x",t,e,n))];case"Sinh":return[r.sinh(d("x",t,e,n))];case"Softplus":return[r.softplus(d("x",t,e,n))];case"Sqrt":return[r.sqrt(d("x",t,e,n))];case"Square":return[r.square(d("x",t,e,n))];case"Tanh":return[r.tanh(d("x",t,e,n))];case"Tan":return[r.tan(d("x",t,e,n))];case"ClipByValue":return[r.clipByValue(d("x",t,e,n),d("clipValueMin",t,e,n),d("clipValueMax",t,e,n))];case"Relu6":return[r.relu6(d("x",t,e,n))];case"Rsqrt":return[r.rsqrt(Ze(t.inputNames[0],e,n))];case"Prod":return[r.prod(d("x",t,e,n),d("axes",t,e,n))];case"LeakyRelu":return[r.leakyRelu(d("x",t,e,n),d("alpha",t,e,n))];case"Prelu":return[r.prelu(d("x",t,e,n),d("alpha",t,e,n))];case"IsNan":return[r.isNaN(Ze(t.inputNames[0],e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function ht(t,e,n=""){if(!(typeof t=="number"||typeof e=="number")){N(t.length===e.length,()=>n+` Shapes ${t} and ${e} must match`);for(let r=0;r<t.length;r++){const s=t[r],a=e[r];N(s<0||a<0||s===a,()=>n+` Shapes ${t} and ${e} must match`)}}}function pu(t){return!(typeof t=="number"||t.some(e=>e<0))}function wr(t,e,n){let r=uo(t,n);const s=!pu(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(a=>{r=uo(a.shape,r)}),!pu(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function uo(t,e){if(typeof t=="number")return e;if(typeof e=="number")return t;if(t.length!==e.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);const n=[];for(let r=0;r<t.length;++r){const s=t[r],a=e[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);n[r]=s>=0?s:a}return n}class zT{constructor(e,n,r,s,a,o,i){this.name=e,this.dtype=n,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=a,this.dynamicSize=o,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=se(0),Ct(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const n=this.tensors[e];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(e){return e.map(n=>this.read(n))}write(e,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),ht(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=n,Ct(n),r.written=!0,this.tensors[e]=r}writeMany(e,n){if(e.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${n.length}.`);e.forEach((r,s)=>this.write(r,n[s]))}gather(e,n){if(!!n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return yt([],[0].concat(this.elementShape));const r=this.readMany(e);return ht(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Wt(r,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return yt([],[0].concat(this.elementShape));const n=[];for(let s=0;s<this.size();s++)n.push(s);const r=this.readMany(n);return ht(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),qe(r,0)}scatter(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,gn(n,0))}split(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let r=0;const s=e.map(u=>(r+=u,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const a=r===0?0:n.size/r,o=[];Y(()=>{n=R(n,[1,r,a]);for(let u=0;u<e.length;++u){const l=u===0?0:s[u-1],c=[0,l,0],h=[1,e[u],a];o[u]=R(Ne(n,c,h),this.elementShape)}return o});const i=[];for(let u=0;u<e.length;u++)i[u]=u;this.writeMany(i,o)}}class Cn{constructor(e,n,r,s=-1){this.tensors=e,this.elementShape=n,this.elementDtype=r,e?.forEach(a=>{if(r!==a.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${a.dtype}`);ht(n,a.shape,"TensorList shape mismatch: "),Ct(a)}),this.idTensor=se(0),this.maxNumElements=s,Ct(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Cn([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);ht(e,this.elementShape,"TensorList shape mismatch: ");const s=wr(this.elementShape,this.tensors,e);return Y(()=>{const a=this.tensors.map(o=>R(o,s));return Wt(a,0)})}popBack(e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=wr(this.elementShape,this.tensors,e),s=this.tensors.pop();return ht(s.shape,e,"TensorList shape mismatch: "),R(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(ht(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Ct(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const n=new Cn([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)n.tensors[r]=this.tensors[r];return n}getItem(e,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);ht(this.tensors[e].shape,n,"TensorList shape mismatch: ");const s=wr(this.elementShape,this.tensors,n);return R(this.tensors[e],s)}setItem(e,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);ht(this.elementShape,n.shape,"TensorList shape mismatch: "),Ct(n),this.tensors[e]=n}gather(e,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);ht(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=wr(this.elementShape,this.tensors,r);return e.length===0?yt([],[0].concat(s)):Y(()=>{const a=e.map(o=>R(this.tensors[o],s));return Wt(a,0)})}concat(e,n){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);ht(this.elementShape,n,"TensorList shape mismatch: ");const r=wr(this.elementShape,this.tensors,n);return this.size()===0?yt([],[0].concat(r)):Y(()=>{const s=this.tensors.map(a=>R(a,r));return qe(s,0)})}}function VT(t,e,n){const r=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);const s=t.shape.slice(1);ht(s,e,"TensorList shape mismatch: ");const a=gn(t);return new Cn(a,e,r)}function jT(t,e,n,r){return new Cn([],t,e,r)}function UT(t,e,n,r){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const a=new Cn([],n,t.dtype,r),o=gn(t,0);return e.forEach((i,u)=>{a.setItem(i,o[u])}),a}function qT(t,e,n){let r=0;const s=e.map(c=>(r+=c,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);const a=t.shape.slice(1),o=uo(a,n),i=r===0?0:t.size/r,u=Y(()=>{const c=[];t=R(t,[1,r,i]);for(let h=0;h<e.length;++h){const p=h===0?0:s[h-1],m=[0,p,0],b=[1,e[h],i];c[h]=R(Ne(t,m,b),o)}return t.dispose(),c}),l=new Cn([],n,t.dtype,e.length);for(let c=0;c<u.length;c++)l.setItem(c,u[c]);return l}const WT=async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{const r=d("thenBranch",t,e,n),s=d("elseBranch",t,e,n),a=d("cond",t,e,n),o=d("args",t,e,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=d("body",t,e,n),s=d("cond",t,e,n),a=d("args",t,e,n),o=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),i=a.map(c=>c.id);let u=await o[0].data();o.forEach(c=>{!c.kept&&i.indexOf(c.id)===-1&&c.dispose()});let l=a;for(;u[0];){const c=l;l=await n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const h=l.map(m=>m.id);c.forEach(m=>{!m.kept&&i.indexOf(m.id)===-1&&h.indexOf(m.id)===-1&&m.dispose()});const p=await n.functionMap[s].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);u=await p[0].data(),p.forEach(m=>{!m.kept&&i.indexOf(m.id)===-1&&h.indexOf(m.id)===-1&&m.dispose()})}return l}case"LoopCond":{const r=d("pred",t,e,n);return[Ht(r)]}case"Switch":{const r=d("pred",t,e,n);let s=d("data",t,e,n);return s.kept||(s=Ht(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=t.inputNames.find(s=>Ze(s,e,n)!==void 0);if(r){const s=Ze(r,e,n);return[Ht(s)]}return}case"Enter":{const r=d("frameName",t,e,n),s=d("tensor",t,e,n);return n.enterFrame(r),[Ht(s)]}case"Exit":{const r=d("tensor",t,e,n);return n.exitFrame(),[Ht(r)]}case"NextIteration":{const r=d("tensor",t,e,n);return n.nextIteration(),[Ht(r)]}case"TensorArrayV3":{const r=d("size",t,e,n),s=d("dtype",t,e,n),a=d("elementShape",t,e,n),o=d("dynamicSize",t,e,n),i=d("clearAfterRead",t,e,n),u=d("identicalElementShapes",t,e,n),l=d("name",t,e,n),c=new zT(l,s,r,a,u,o,i);return n.addTensorArray(c),[c.idTensor,se(1)]}case"TensorArrayWriteV3":{const r=d("tensorArrayId",t,e,n),s=d("index",t,e,n),a=d("tensor",t,e,n),o=n.getTensorArray(r.id);return o.write(s,a),[o.idTensor]}case"TensorArrayReadV3":{const r=d("tensorArrayId",t,e,n),s=d("index",t,e,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=d("tensorArrayId",t,e,n),s=d("indices",t,e,n),a=d("dtype",t,e,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{const r=d("tensorArrayId",t,e,n),s=d("indices",t,e,n),a=d("tensor",t,e,n),o=n.getTensorArray(r.id);return o.scatter(s,a),[o.idTensor]}case"TensorArrayConcatV3":{const r=d("tensorArrayId",t,e,n),s=n.getTensorArray(r.id),a=d("dtype",t,e,n);return[s.concat(a)]}case"TensorArraySplitV3":{const r=d("tensorArrayId",t,e,n),s=d("tensor",t,e,n),a=d("lengths",t,e,n),o=n.getTensorArray(r.id);return o.split(a,s),[o.idTensor]}case"TensorArraySizeV3":{const r=d("tensorArrayId",t,e,n),s=n.getTensorArray(r.id);return[se(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=d("tensorArrayId",t,e,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=d("tensorListId",t,e,n),s=d("index",t,e,n),a=d("tensor",t,e,n),o=n.getTensorList(r.id);return o.setItem(s,a),[o.idTensor]}case"TensorListGetItem":{const r=d("tensorListId",t,e,n),s=d("index",t,e,n),a=d("elementShape",t,e,n),o=d("elementDType",t,e,n);return[n.getTensorList(r.id).getItem(s,a,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=d("indices",t,e,n),s=d("tensor",t,e,n),a=d("elementShape",t,e,n),o=d("numElements",t,e,n),i=UT(s,r,a,o);return n.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=d("elementShape",t,e,n),s=d("elementDType",t,e,n);let a;t.op==="TensorListReserve"?a="numElements":a="maxNumElements";const o=d(a,t,e,n),i=t.op==="TensorListReserve"?-1:o,u=jT(r,s,o,i);return n.addTensorList(u),[u.idTensor]}case"TensorListGather":{const r=d("tensorListId",t,e,n),s=d("indices",t,e,n),a=d("elementShape",t,e,n),o=d("elementDType",t,e,n);return[n.getTensorList(r.id).gather(s,o,a)]}case"TensorListStack":{const r=d("tensorListId",t,e,n),s=d("elementShape",t,e,n),a=d("elementDType",t,e,n),o=d("numElements",t,e,n);return[n.getTensorList(r.id).stack(s,a,o)]}case"TensorListFromTensor":{const r=d("tensor",t,e,n),s=d("elementShape",t,e,n),a=d("elementDType",t,e,n),o=VT(r,s,a);return n.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=d("tensorListId",t,e,n),s=n.getTensorList(r.id),a=d("dtype",t,e,n),o=d("elementShape",t,e,n);return[s.concat(a,o)]}case"TensorListPushBack":{const r=d("tensorListId",t,e,n),s=d("tensor",t,e,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{const r=d("tensorListId",t,e,n),s=d("elementShape",t,e,n),a=d("elementDType",t,e,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{const r=d("tensor",t,e,n),s=d("elementShape",t,e,n),a=d("lengths",t,e,n),o=qT(r,a,s);return n.addTensorList(o),[o.idTensor]}case"TensorListLength":{const r=d("tensorListId",t,e,n),s=n.getTensorList(r.id);return[se(s.size(),"int32")]}case"TensorListResize":{const r=d("tensorListId",t,e,n),s=d("size",t,e,n),o=n.getTensorList(r.id).resize(s);return n.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};function du(t,e,n){const[r,s]=d("fusedOps",t,e,n),a=r==="biasadd",o=!a,i=s==="prelu",u=r==="fusedbatchnorm",l=d("numArgs",t,e,n);if(a){if(i&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&a&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=d("strides",t,e,n),h=ws(t,e,n),p=d("dataFormat",t,e,n).toUpperCase(),m=d("dilations",t,e,n);let[b,v]=d("args",t,e,n);o&&(v=b,b=void 0);const S=d("leakyreluAlpha",t,e,n);return{stride:c,pad:h,dataFormat:p,dilations:m,biasArg:b,preluArg:v,activationFunc:s,leakyreluAlpha:S}}const HT=(t,e,n,r=We)=>{switch(t.op){case"Conv1D":{const s=d("stride",t,e,n),a=d("pad",t,e,n),o=d("dataFormat",t,e,n).toUpperCase(),i=d("dilation",t,e,n);return[r.conv1d(d("x",t,e,n),d("filter",t,e,n),s,a,o,i)]}case"Conv2D":{const s=d("strides",t,e,n),a=ws(t,e,n),o=d("dataFormat",t,e,n).toUpperCase(),i=d("dilations",t,e,n);return[r.conv2d(d("x",t,e,n),d("filter",t,e,n),[s[1],s[2]],a,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:s,pad:a,dataFormat:o,dilations:i,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:h}=du(t,e,n);return[r.fused.conv2d({x:d("x",t,e,n),filter:d("filter",t,e,n),strides:[s[1],s[2]],pad:a,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:a,dataFormat:o,dilations:i,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:h}=du(t,e,n);return[r.fused.depthwiseConv2d({x:d("x",t,e,n),filter:d("filter",t,e,n),strides:[s[1],s[2]],pad:a,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=d("outputShape",t,e,n),a=d("strides",t,e,n),o=ws(t,e,n);return[r.conv2dTranspose(d("x",t,e,n),d("filter",t,e,n),s,[a[1],a[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=d("strides",t,e,n),a=ws(t,e,n),o=d("dilations",t,e,n),i=d("dataFormat",t,e,n).toUpperCase();return[r.depthwiseConv2d(d("input",t,e,n),d("filter",t,e,n),[s[1],s[2]],a,i,[o[1],o[2]])]}case"Conv3D":{const s=d("strides",t,e,n),a=d("pad",t,e,n),o=d("dataFormat",t,e,n).toUpperCase(),i=d("dilations",t,e,n);return[r.conv3d(d("x",t,e,n),d("filter",t,e,n),[s[1],s[2],s[3]],a,o,[i[1],i[2],i[3]])]}case"AvgPool":{const s=d("strides",t,e,n),a=d("pad",t,e,n),o=d("kernelSize",t,e,n);return[r.avgPool(d("x",t,e,n),[o[1],o[2]],[s[1],s[2]],a)]}case"MaxPool":{const s=d("strides",t,e,n),a=d("pad",t,e,n),o=d("kernelSize",t,e,n);return[r.maxPool(d("x",t,e,n),[o[1],o[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{const s=d("strides",t,e,n),a=d("pad",t,e,n),o=d("kernelSize",t,e,n),i=d("includeBatchInIndex",t,e,n),{result:u,indexes:l}=r.maxPoolWithArgmax(d("x",t,e,n),[o[1],o[2]],[s[1],s[2]],a,i);return[u,l]}case"AvgPool3D":{const s=d("strides",t,e,n),a=d("pad",t,e,n),o=d("kernelSize",t,e,n);return[r.avgPool3d(d("x",t,e,n),[o[1],o[2],o[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{const s=d("strides",t,e,n),a=d("pad",t,e,n),o=d("kernelSize",t,e,n);return[r.maxPool3d(d("x",t,e,n),[o[1],o[2],o[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{const s=d("strides",t,e,n),a=d("pad",t,e,n),o=d("dilations",t,e,n),i=s[1],u=s[2],l=o[1],c=o[2];return[r.dilation2d(d("x",t,e,n),d("filter",t,e,n),[i,u],a,[l,c],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const GT=(t,e,n,r=We)=>{switch(t.op){case"Fill":{const s=d("shape",t,e,n),a=d("dtype",t,e,n),o=d("value",t,e,n);return[r.fill(s,o,a)]}case"LinSpace":{const s=d("start",t,e,n),a=d("stop",t,e,n),o=d("num",t,e,n);return[r.linspace(s,a,o)]}case"Multinomial":{const s=d("logits",t,e,n),a=d("numSamples",t,e,n),o=d("seed",t,e,n);return[r.multinomial(s,a,o)]}case"OneHot":{const s=d("indices",t,e,n),a=d("depth",t,e,n),o=d("onValue",t,e,n),i=d("offValue",t,e,n);return[r.oneHot(s,a,o,i)]}case"Ones":return[r.ones(d("shape",t,e,n),d("dtype",t,e,n))];case"OnesLike":return[r.onesLike(d("x",t,e,n))];case"RandomStandardNormal":return[r.randomStandardNormal(d("shape",t,e,n),d("dtype",t,e,n),d("seed",t,e,n))];case"RandomUniform":return[r.randomUniform(d("shape",t,e,n),d("minval",t,e,n),d("maxval",t,e,n),d("dtype",t,e,n))];case"Range":{const s=d("start",t,e,n),a=d("stop",t,e,n),o=d("step",t,e,n);return[r.range(s,a,o,d("dtype",t,e,n))]}case"TruncatedNormal":{const s=d("shape",t,e,n),a=d("mean",t,e,n),o=d("stdDev",t,e,n),i=d("seed",t,e,n);return[r.truncatedNormal(s,a,o,d("dtype",t,e,n),i)]}case"Zeros":return[r.zeros(d("shape",t,e,n),d("dtype",t,e,n))];case"ZerosLike":return[r.zerosLike(d("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function Ta(t,e,n){const r=d("boxes",t,e,n),s=d("scores",t,e,n),a=d("maxOutputSize",t,e,n),o=d("iouThreshold",t,e,n),i=d("scoreThreshold",t,e,n),u=d("softNmsSigma",t,e,n);return{boxes:r,scores:s,maxOutputSize:a,iouThreshold:o,scoreThreshold:i,softNmsSigma:u}}const KT=async(t,e,n,r,s=We)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:l,softNmsSigma:c}=Ta(t,e,n),h=await s.image.nonMaxSuppressionWithScoreAsync(a,o,i,u,l,c);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:l}=Ta(t,e,n),c=d("padToMaxOutputSize",t,e,n),h=await s.image.nonMaxSuppressionPaddedAsync(a,o,i,u,l,c);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:l}=Ta(t,e,n);return[await s.image.nonMaxSuppressionAsync(a,o,i,u,l)]}case"Where":{const a=s.cast(d("condition",t,e,n),"bool"),o=[await s.whereAsync(a)];return a.dispose(),o}case"ListDiff":return s.setdiff1dAsync(d("x",t,e,n),d("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}};const XT=(t,e,n,r=We)=>{switch(t.op){case"LowerBound":{const s=d("sortedSequence",t,e,n),a=d("values",t,e,n);return[r.lowerBound(s,a)]}case"TopKV2":{const s=d("x",t,e,n),a=d("k",t,e,n),o=d("sorted",t,e,n),i=r.topk(s,a,o);return[i.values,i.indices]}case"UpperBound":{const s=d("sortedSequence",t,e,n),a=d("values",t,e,n);return[r.upperBound(s,a)]}case"Unique":{const s=d("x",t,e,n),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{const s=d("x",t,e,n),a=d("axis",t,e,n),o=r.unique(s,a);return[o.values,o.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const YT=(t,e,n,r=We)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const s=d("default",t,e,n);return[Ze(t.name,e,n)||s];case"Placeholder":return[Ze(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=d("x",t,e,n);return[Ht(c)]}case"IdentityN":return d("x",t,e,n).map(c=>Ht(c));case"Snapshot":const a=d("x",t,e,n);return[Ht(a)];case"Shape":return[r.tensor1d(d("x",t,e,n).shape,"int32")];case"ShapeN":return d("x",t,e,n).map(c=>r.tensor1d(c.shape));case"Size":return[r.scalar(d("x",t,e,n).size,"int32")];case"Rank":return[r.scalar(d("x",t,e,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const o=d("x",t,e,n),i=d("data",t,e,n),u=d("message",t,e,n),l=d("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let c=0;c<i.length;c++)console.log(Array.prototype.slice.call(i[c].dataSync()).slice(0,l));return[o];default:throw TypeError(`Node type ${t.op} is not implemented`)}};class ZT{constructor(e,n){this.keyDType=e,this.valueDType=n,this.handle=se(0),this.tensorMap=new Map,Ct(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return se(this.size(),"int32")}async import(e,n){this.checkKeyAndValueTensor(e,n);const r=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),Y(()=>{const s=gn(n),a=r.length,o=s.length;N(a===o,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${o} elements.`);for(let i=0;i<a;i++){const u=r[i],l=s[i];Ct(l),this.tensorMap.set(u,l)}return this.handle})}async find(e,n){this.checkKeyAndValueTensor(e,n);const r=await e.data();return Y(()=>{const s=[];for(let a=0;a<r.length;a++){const o=r[a],i=this.findWithDefault(o,n);s.push(i)}return Wt(s)})}findWithDefault(e,n){const r=this.tensorMap.get(e);return r??n}checkKeyAndValueTensor(e,n){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}const JT=async(t,e,n,r)=>{switch(t.op){case"HashTable":case"HashTableV2":{const s=d("keyDType",t,e,n),a=d("valueDType",t,e,n),o=new ZT(s,a);return r.addHashTable(t.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const s=d("tableHandle",t,e,n,r),a=d("keys",t,e,n),o=d("values",t,e,n);return[await r.getHashTableById(s.id).import(a,o)]}case"LookupTableFind":case"LookupTableFindV2":{const s=d("tableHandle",t,e,n,r),a=d("keys",t,e,n),o=d("defaultValue",t,e,n);return[await r.getHashTableById(s.id).find(a,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=d("tableHandle",t,e,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const QT=(t,e,n,r=We)=>{switch(t.op){case"ResizeBilinear":{const s=d("images",t,e,n),a=d("size",t,e,n),o=d("alignCorners",t,e,n),i=d("halfPixelCenters",t,e,n);return[r.image.resizeBilinear(s,[a[0],a[1]],o,i)]}case"ResizeNearestNeighbor":{const s=d("images",t,e,n),a=d("size",t,e,n),o=d("alignCorners",t,e,n),i=d("halfPixelCenters",t,e,n);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],o,i)]}case"CropAndResize":{const s=d("image",t,e,n),a=d("boxes",t,e,n),o=d("boxInd",t,e,n),i=d("cropSize",t,e,n),u=d("method",t,e,n),l=d("extrapolationValue",t,e,n);return[r.image.cropAndResize(s,a,o,i,u,l)]}case"ImageProjectiveTransformV3":{const s=d("images",t,e,n),a=d("transforms",t,e,n),o=d("outputShape",t,e,n),i=d("fillValue",t,e,n),u=d("interpolation",t,e,n),l=d("fillMode",t,e,n);return[r.image.transform(s,a,u.toLowerCase(),l.toLowerCase(),i,o)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const eE=(t,e,n,r=We)=>{switch(t.op){case"Equal":return[r.equal(d("a",t,e,n),d("b",t,e,n))];case"NotEqual":return[r.notEqual(d("a",t,e,n),d("b",t,e,n))];case"Greater":return[r.greater(d("a",t,e,n),d("b",t,e,n))];case"GreaterEqual":return[r.greaterEqual(d("a",t,e,n),d("b",t,e,n))];case"Less":return[r.less(d("a",t,e,n),d("b",t,e,n))];case"LessEqual":return[r.lessEqual(d("a",t,e,n),d("b",t,e,n))];case"LogicalAnd":return[r.logicalAnd(d("a",t,e,n),d("b",t,e,n))];case"LogicalNot":return[r.logicalNot(d("a",t,e,n))];case"LogicalOr":return[r.logicalOr(d("a",t,e,n),d("b",t,e,n))];case"Select":case"SelectV2":return[r.where(d("condition",t,e,n),d("a",t,e,n),d("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const tE=(t,e,n,r=We)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(d("a",t,e,n),d("b",t,e,n),d("transposeA",t,e,n),d("transposeB",t,e,n))];case"Einsum":return[r.einsum(d("equation",t,e,n),...d("tensors",t,e,n))];case"Transpose":return[r.transpose(d("x",t,e,n),d("perm",t,e,n))];case"_FusedMatMul":const[s,a]=d("fusedOps",t,e,n),o=s==="biasadd",i=a==="prelu",u=d("numArgs",t,e,n),l=d("leakyreluAlpha",t,e,n);if(o){if(i&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,h]=d("args",t,e,n);return[r.fused.matMul({a:d("a",t,e,n),b:d("b",t,e,n),transposeA:d("transposeA",t,e,n),transposeB:d("transposeB",t,e,n),bias:c,activation:a,preluActivationWeights:h,leakyreluAlpha:l})];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const nE=(t,e,n,r=We)=>{switch(t.op){case"EuclideanNorm":return[r.euclideanNorm(d("x",t,e,n),d("axis",t,e,n),d("keepDims",t,e,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(d("x",t,e,n),d("mean",t,e,n),d("variance",t,e,n),d("offset",t,e,n),d("scale",t,e,n),d("epsilon",t,e,n))];case"FusedBatchNormV3":return[r.batchNorm(d("x",t,e,n),d("mean",t,e,n),d("variance",t,e,n),d("offset",t,e,n),d("scale",t,e,n),d("epsilon",t,e,n))];case"LRN":return[r.localResponseNormalization(d("x",t,e,n),d("radius",t,e,n),d("bias",t,e,n),d("alpha",t,e,n),d("beta",t,e,n))];case"Softmax":return[r.softmax(d("x",t,e,n))];case"LogSoftmax":return[r.logSoftmax(d("x",t,e,n))];case"SparseToDense":return[r.sparseToDense(d("sparseIndices",t,e,n),d("outputShape",t,e,n),d("sparseValues",t,e,n),d("defaultValue",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const rE=(t,e,n,r=We)=>{switch(t.op){case"Max":{const i=d("axis",t,e,n),u=d("keepDims",t,e,n);return[r.max(d("x",t,e,n),i,u)]}case"Mean":{const i=d("axis",t,e,n),u=d("keepDims",t,e,n);return[r.mean(d("x",t,e,n),i,u)]}case"Min":{const i=d("axis",t,e,n),u=d("keepDims",t,e,n);return[r.min(d("x",t,e,n),i,u)]}case"Sum":{const i=d("axis",t,e,n),u=d("keepDims",t,e,n);return[r.sum(d("x",t,e,n),i,u)]}case"All":{const i=d("axis",t,e,n),u=d("keepDims",t,e,n);return[r.all(d("x",t,e,n),i,u)]}case"Any":{const i=d("axis",t,e,n),u=d("keepDims",t,e,n);return[r.any(d("x",t,e,n),i,u)]}case"ArgMax":{const i=d("axis",t,e,n);return[r.argMax(d("x",t,e,n),i)]}case"ArgMin":{const i=d("axis",t,e,n);return[r.argMin(d("x",t,e,n),i)]}case"Prod":{const i=d("axis",t,e,n),u=d("keepDims",t,e,n);return[r.prod(d("x",t,e,n),i,u)]}case"Cumprod":{const i=d("axis",t,e,n),u=d("exclusive",t,e,n),l=d("reverse",t,e,n);return[r.cumprod(d("x",t,e,n),i,u,l)]}case"Cumsum":{const i=d("axis",t,e,n),u=d("exclusive",t,e,n),l=d("reverse",t,e,n);return[r.cumsum(d("x",t,e,n),i,u,l)]}case"Bincount":const s=d("x",t,e,n),a=d("weights",t,e,n),o=d("size",t,e,n);return[r.bincount(s,a,o)];case"DenseBincount":{const i=d("x",t,e,n),u=d("weights",t,e,n),l=d("size",t,e,n),c=d("binaryOutput",t,e,n);return[r.denseBincount(i,u,l,c)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const sE=(t,e,n,r=We)=>{switch(t.op){case"ConcatV2":case"Concat":{const s=d("n",t,e,n),a=d("axis",t,e,n);let o=d("tensors",t,e,n);return o=o.slice(0,s),[r.concat(o,a)]}case"Gather":{const s=d("x",t,e,n),a=d("indices",t,e,n);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{const s=d("axis",t,e,n),a=d("batchDims",t,e,n),o=d("x",t,e,n),i=d("indices",t,e,n);return[r.gather(o,r.cast(i,"int32"),s,a)]}case"Reverse":{const s=d("dims",t,e,n),a=[];for(let i=0;i<s.length;i++)s[i]&&a.push(i);const o=d("x",t,e,n);return[r.reverse(o,a)]}case"ReverseV2":{const s=d("axis",t,e,n),a=d("x",t,e,n);return[r.reverse(a,s)]}case"Slice":{const s=d("begin",t,e,n),a=d("size",t,e,n);return[r.slice(d("x",t,e,n),s,a)]}case"StridedSlice":{const s=d("begin",t,e,n),a=d("end",t,e,n),o=d("strides",t,e,n),i=d("beginMask",t,e,n),u=d("endMask",t,e,n),l=d("ellipsisMask",t,e,n),c=d("newAxisMask",t,e,n),h=d("shrinkAxisMask",t,e,n),p=d("x",t,e,n);return[r.stridedSlice(p,s,a,o,i,u,l,c,h)]}case"Pack":return Y(()=>{const s=d("axis",t,e,n),a=d("tensors",t,e,n),o=a[0].shape,i=r.squeeze(a[0]).shape,u=a.map(l=>{const c=zt(l.shape,o);if(!c&&!zt(r.squeeze(l).shape,i))throw new Error("the input tensors shape does not match");return c?l:r.reshape(l,o)});return[r.stack(u,s)]});case"Unpack":{const s=d("axis",t,e,n),a=d("tensor",t,e,n);return r.unstack(a,s)}case"Tile":{const s=d("reps",t,e,n);return[r.tile(d("x",t,e,n),s)]}case"Split":case"SplitV":{const s=d("axis",t,e,n),a=d("numOrSizeSplits",t,e,n),o=d("x",t,e,n);return r.split(o,a,s)}case"ScatterNd":{const s=d("indices",t,e,n),a=d("values",t,e,n),o=d("shape",t,e,n);return[r.scatterND(s,a,o)]}case"GatherNd":{const s=d("x",t,e,n),a=d("indices",t,e,n);return[r.gatherND(s,a)]}case"SparseToDense":{const s=d("sparseIndices",t,e,n),a=d("outputShape",t,e,n),o=d("sparseValues",t,e,n),i=d("defaultValue",t,e,n);return[r.sparseToDense(s,o,a,o.dtype===i.dtype?i:r.cast(i,o.dtype))]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const aE=(t,e,n,r=We)=>{switch(t.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:a,emptyRowIndicator:o,reverseIndexMap:i}=r.sparse.sparseFillEmptyRows(d("indices",t,e,n),d("values",t,e,n),d("denseShape",t,e,n),d("defaultValue",t,e,n));return[s,a,o,i]}case"SparseReshape":{const{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(d("inputIndices",t,e,n),d("inputShape",t,e,n),d("newShape",t,e,n));return[s,a]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(d("data",t,e,n),d("indices",t,e,n),d("segmentIds",t,e,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(d("data",t,e,n),d("indices",t,e,n),d("segmentIds",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const oE=(t,e,n,r=We)=>{switch(t.op){case"FFT":return[r.fft(d("x",t,e,n))];case"IFFT":return[r.ifft(d("x",t,e,n))];case"RFFT":return[r.rfft(d("x",t,e,n))];case"IRFFT":return[r.irfft(d("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const iE=(t,e,n,r=We)=>{switch(t.op){case"StringNGrams":{const{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(d("data",t,e,n),d("dataSplits",t,e,n),d("separator",t,e,n),d("nGramWidths",t,e,n),d("leftPad",t,e,n),d("rightPad",t,e,n),d("padWidth",t,e,n),d("preserveShortSequences",t,e,n));return[s,a]}case"StringSplit":{const{indices:s,values:a,shape:o}=r.string.stringSplit(d("input",t,e,n),d("delimiter",t,e,n),d("skipEmpty",t,e,n));return[s,a,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(d("input",t,e,n),d("numBuckets",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const uE=(t,e,n,r=We)=>{switch(t.op){case"Cast":return[r.cast(d("x",t,e,n),d("dtype",t,e,n))];case"ExpandDims":{const s=d("axis",t,e,n);return[r.expandDims(d("x",t,e,n),s)]}case"Squeeze":{const s=d("axis",t,e,n);return[r.squeeze(d("x",t,e,n),s)]}case"Reshape":return[r.reshape(d("x",t,e,n),d("shape",t,e,n))];case"MirrorPad":return[r.mirrorPad(d("x",t,e,n),d("padding",t,e,n),d("mode",t,e,n))];case"PadV2":case"Pad":return[r.pad(d("x",t,e,n),d("padding",t,e,n),d("constantValue",t,e,n))];case"SpaceToBatchND":{const s=d("blockShape",t,e,n),a=d("paddings",t,e,n);return[r.spaceToBatchND(d("x",t,e,n),s,a)]}case"BatchToSpaceND":{const s=d("blockShape",t,e,n),a=d("crops",t,e,n);return[r.batchToSpaceND(d("x",t,e,n),s,a)]}case"DepthToSpace":{const s=d("blockSize",t,e,n),a=d("dataFormat",t,e,n).toUpperCase();return[r.depthToSpace(d("x",t,e,n),s,a)]}case"BroadcastTo":return[r.broadcastTo(d("x",t,e,n),d("shape",t,e,n))];case"BroadcastArgs":return[r.broadcastArgs(d("s0",t,e,n),d("s1",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function mu(t,e,n,r,s=Y){const a=((o,i,u)=>{switch(o.category){case"arithmetic":return s(()=>LT(o,i,u));case"basic_math":return s(()=>MT(o,i,u));case"control":return WT(o,i,u);case"convolution":return s(()=>HT(o,i,u));case"creation":return s(()=>GT(o,i,u));case"dynamic":return KT(o,i,u);case"evaluation":return s(()=>XT(o,i,u));case"image":return s(()=>QT(o,i,u));case"graph":return s(()=>YT(o,i,u));case"logical":return s(()=>eE(o,i,u));case"matrices":return s(()=>tE(o,i,u));case"normalization":return s(()=>nE(o,i,u));case"reduction":return s(()=>rE(o,i,u));case"slice_join":return s(()=>sE(o,i,u));case"sparse":return s(()=>aE(o,i,u));case"spectral":return s(()=>oE(o,i,u));case"string":return s(()=>iE(o,i,u));case"transformation":return s(()=>uE(o,i,u));case"hash_table":return JT(o,i,u,r);case"custom":const l=Kd(o.op);if(l&&l.customExecutor)return l.customExecutor(new BT(o,i,u));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return An(a)?a.then(o=>[].concat(o)):[].concat(a)}class gu{constructor(e={},n={},r={},s={}){this.weightMap=e,this.tensorArrayMap=n,this.tensorListMap=r,this.functionMap=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,n){return{id:e,frameName:n,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let n=0;n<this.contexts.length-1;n++){const r=this.contexts.slice(0,this.contexts.length-n);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(e);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(e)}}function yu(t,e,n,r){const s=new Set,a=[];let o=null,i=null;const u=new Set,l=Object.keys(t).map(p=>nt(p)[0]);let c=[];r!=null&&(c=r.map(p=>nt(p.name)[0]));const h=[...e];for(;h.length>0;){const p=h.pop();if((Zd(p)||pE(p)||dE(p))&&o==null&&(o=p,i=o.children.map(m=>m.name).filter(m=>s.has(m))),s.add(p.name),n[p.name]==null&&l.indexOf(p.name)===-1&&c.indexOf(p.name)===-1){if(p.inputs.length===0){a.push(p.name);continue}p.inputs.forEach(m=>{u.has(m.name)||(u.add(m.name),h.push(m))})}}return{inputs:t,outputs:e,usedNodes:s,missingInputs:a,dynamicNode:o,syncInputs:i}}function lE(t,e,n){const{usedNodes:r,inputs:s}=n,a=[],o=Object.keys(s).map(c=>nt(c)[0]).map(c=>t.nodes[c]),i=t.initNodes;o.forEach(c=>{r.has(c.name)&&a.push(c)}),t.weights.forEach(c=>{r.has(c.name)&&a.push(c)}),i?.forEach(c=>{r.has(c.name)&&a.push(c)});const u=new Set,l=[];for(;a.length>0;){const c=a.pop();u.add(c.name),e[c.name]||l.push(c),c.children.forEach(h=>{!u.has(h.name)&&r.has(h.name)&&h.inputs.every(p=>u.has(p.name))&&a.push(h)})}return l}const cE=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],hE=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],fE=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Zd(t){return cE.indexOf(t.op)>=0}function pE(t){return hE.indexOf(t.op)>=0}function dE(t){return fE.indexOf(t.op)>=0}class Ds{constructor(e,n){this.graph=e,this.parent=n,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new Ds(e.functions[r],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const n=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...n),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const n=e.signatureKey||e.name;return e.defaultOutput?`${n}:${e.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((e,n)=>(e[n]=this._functions[n].signature,e),{})}getCompilationKey(e,n){const r=e.map(a=>a.name).sort(),s=n.map(a=>a.name).sort();return r.join(this.SEPERATOR)+"--"+s.join(this.SEPERATOR)}compile(e,n){const r=yu(e,n,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:a,syncInputs:o}=r;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(s.length>0){const i=n.map(l=>l.name),u=Object.keys(e);throw new Error(`Cannot compute the outputs [${i}] from the provided inputs [${u}]. Missing the following inputs: [${s}]`)}return lE(this.graph,this.weightMap,r)}execute(e,n){e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n);const s=r.map(h=>this.graph.nodes[nt(h)[0]]),a=n.map(h=>nt(h)[0]);let o=a.map(h=>this.graph.nodes[h]);this.resetIntermediateTensors(),o.length===0&&(o=this._outputs);const i=this.getCompilationKey(s,o);let u=this.compiledMap.get(i);u==null&&(u=this.compile(e,o),this.compiledMap.set(i,u));const l={},c={};return Y(()=>{const h=new gu(this.weightMap,l,c,this.functionExecutorMap),p=Object.assign({},this.weightMap);Object.keys(e).forEach(v=>{const[S,x]=nt(v),O=[];O[x]=e[v],p[S]=O});const m=this.getFrozenTensorIds(p),b={};for(let v=0;v<u.length;v++){const S=u[v];if(!p[S.name]){const x=mu(S,p,h,this._resourceManager);if(An(x))throw new Error(`The execution of the op '${S.op}' returned a promise. Please use model.executeAsync() instead.`);p[S.name]=x,this.checkTensorForDisposal(S.name,S,p,h,m,a,b)}}return this.parent==null&&h.dispose(m),n.map(v=>Ze(v,p,h))})}getFrozenTensorIds(e){const n=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(n)}checkTensorForDisposal(e,n,r,s,a,o,i){n.category==="control"||o.indexOf(e)!==-1||(r[e].forEach(u=>{u!=null&&(i[u.id]=(i[u.id]||0)+n.children.length)}),n.inputs.forEach(u=>{if(u.category!=="control"){const l=ZN(u.name,r,s);l?.forEach(c=>{if(c&&!c.kept&&!a.has(c.id)){const h=i[c.id];if(h===1){if(!this.keepTensorForDebug)c.dispose();else{const[p,m]=Rt(n.name,s);this.intermediateTensors[p]?this.intermediateTensors[p][m]=c:(this.intermediateTensors[p]=[],this.intermediateTensors[p][m]=c)}delete i[c.id]}else h!=null&&i[c.id]--}})}}))}async executeAsync(e,n){return this._executeAsync(e,n)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach(e=>this.intermediateTensors[e].forEach(n=>n.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach(e=>{this.tensorsMap[e].forEach(r=>{r&&!r.kept&&!r.isDisposed&&!this.keepIds.has(r.id)&&r.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors)this.intermediateTensors[e].forEach(n=>n.dispose()),delete this.intermediateTensors[e]}async _executeAsync(e,n,r=!1,s={},a={}){r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepTensorForDebug=re().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){console.warn(c.message)}this.resetIntermediateTensors();const o=new gu(this.weightMap,s,a,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,o,n,r);const i=n.map(c=>Ze(c,this.tensorsMap,o)),u=i.map(c=>c.id),l=Object.keys(e).map(c=>e[c].id);return this.keepIds=new Set([...u,...l,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&o.dispose(this.keepIds),i}async executeFunctionAsync(e,n,r){const s=e.reduce((a,o,i)=>(a[this.inputs[i].name]=o,a),{});return this._executeAsync(s,this.outputNodes,!0,n,r)}async executeWithControlFlow(e,n,r,s){const a=Object.keys(e),o=a.map(E=>this.graph.nodes[nt(E)[0]]),i=r.map(E=>nt(E)[0]);let u=i.map(E=>this.graph.nodes[E]);u.length===0&&(u=this._outputs);const{usedNodes:l,missingInputs:c,dynamicNode:h,syncInputs:p}=yu(e,u,this.weightMap,this._initNodes),m=[...o,...this.graph.weights,...this._initNodes||[]].map(E=>({node:E,contexts:n.currentContext})),b=Object.assign({},this.weightMap);Object.keys(e).forEach(E=>{const[$,I]=nt(E),F=[];F[I]=e[E],b[$]=F});const v={},S=this.getFrozenTensorIds(b),x={};for(;m.length>0;){const E=this.processStack(o,m,n,b,x,S,i,v,l);await Promise.all(E)}h==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const O=u.filter(E=>!Zd(E)&&!Ze(E.name,b,n)).map(E=>E.name);if(O.length>0){let E="";throw h!=null&&(E=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${O}] from the provided inputs [${a}]. Consider providing the following inputs: [${c}]. ${E}`)}return b}processStack(e,n,r,s,a,o,i,u,l){const c=[];for(;n.length>0;){const h=n.pop();r.currentContext=h.contexts;let p="";if(h.node.op==="Enter"&&d("isConstant",h.node,s,r)&&([p]=Rt(h.node.name,r)),s[h.node.name]==null){const m=mu(h.node,s,r,this._resourceManager);p||([p]=Rt(h.node.name,r));const b=r.currentContext;An(m)?c.push(m.then(v=>(s[p]=v,r.currentContext=b,this.checkTensorForDisposal(p,h.node,s,r,o,i,u),this.processChildNodes(h.node,n,r,s,a,l),v))):(s[p]=m,this.checkTensorForDisposal(p,h.node,s,r,o,i,u),this.processChildNodes(h.node,n,r,s,a,l))}else this.processChildNodes(h.node,n,r,s,a,l)}return c}processChildNodes(e,n,r,s,a,o){e.children.forEach(i=>{const[u]=Rt(i.name,r);a[u]||!o.has(i.name)||(i.op==="Merge"?i.inputNames.some(l=>!!Ze(l,s,r))&&(a[u]=!0,n.push({contexts:r.currentContext,node:i})):i.inputNames.every(l=>!!Ze(l,s,r))&&(a[u]=!0,n.push({contexts:r.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(n=>n.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(n=>{const r=e[n],[s]=nt(n),a=this.graph.nodes[s];if(a.attrParams.shape&&a.attrParams.shape.value){const o=a.attrParams.shape.value,i=o.length===r.shape.length&&r.shape.every((u,l)=>o[l]===-1||o[l]===u);N(i,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${o}], but was [${r.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&N(r.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){const n={};for(const r in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[r]!=null){const s=this._signature.inputs[r];n[s.name]=e[r]}else n[r]=e[r];return n}checkInputs(e){const n=Object.keys(e).filter(r=>{const[s]=nt(r);return this.graph.nodes[s]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(e){return e.map(n=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[n]!=null?this._signature.outputs[n].name:n,{})}checkOutputs(e){e.forEach(n=>{const[r]=nt(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}}class mE{constructor(e={},n={}){this.hashTableNameToHandle=e,this.hashTableMap=n}addHashTable(e,n){this.hashTableNameToHandle[e]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const gE="?tfjs-format=file",yE="model.json";class bE{constructor(e,n={},r=Io){this.modelUrl=e,this.loadOptions=n,this.version="n/a",this.io=r,n==null&&(this.loadOptions={}),this.resourceManager=new mE}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const n=this.io.getLoadHandlers(e,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[e]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return An(e)?e.then(n=>this.loadSync(n)):this.loadSync(e)}loadSync(e){this.artifacts=e;const n=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const a=this.artifacts.userDefinedMetadata;a.signature!=null&&(r=a.signature),a.structuredOutputKeys!=null&&(this.structuredOutputKeys=a.structuredOutputKeys)}this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`;const s=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Ds(hu.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const a=hu.Instance.transformGraph(e.modelInitializer);this.initializer=new Ds(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,n){if(typeof e=="string"){const r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,n){const r=this.execute(e,this.outputNodes);if(this.structuredOutputKeys){const s=r instanceof ye?[r]:r,a={};return s.forEach((o,i)=>a[this.structuredOutputKeys[i]]=o),a}return r}normalizeInputs(e){if(!(e instanceof ye)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((n,r,s)=>(n[r]=e[s],n),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,n){e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const r=this.executor.execute(e,n);return r.length>1?r:r[0]}async executeAsync(e,n){e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const r=await this.executor.executeAsync(e,n);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((n,r)=>(n[r]=[e[r]],n),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function Ei(t,e={},n=Io){if(t==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof t=="string"&&(t=wE(t));const r=new bE(t,e,n);return await r.load(),r}function wE(t){return t.endsWith("/")||(t=t+"/"),`${t}${yE}${gE}`}(function(){var t;function e(f){var g=0;return function(){return g<f.length?{done:!1,value:f[g++]}:{done:!0}}}var n=typeof Object.defineProperties=="function"?Object.defineProperty:function(f,g,y){return f==Array.prototype||f==Object.prototype||(f[g]=y.value),f};function r(f){f=[typeof globalThis=="object"&&globalThis,f,typeof window=="object"&&window,typeof self=="object"&&self,typeof Bt=="object"&&Bt];for(var g=0;g<f.length;++g){var y=f[g];if(y&&y.Math==Math)return y}throw Error("Cannot find global object")}var s=r(this);function a(f,g){if(g)e:{var y=s;f=f.split(".");for(var T=0;T<f.length-1;T++){var A=f[T];if(!(A in y))break e;y=y[A]}f=f[f.length-1],T=y[f],g=g(T),g!=T&&g!=null&&n(y,f,{configurable:!0,writable:!0,value:g})}}a("Symbol",function(f){function g(B){if(this instanceof g)throw new TypeError("Symbol is not a constructor");return new y(T+(B||"")+"_"+A++,B)}function y(B,D){this.g=B,n(this,"description",{configurable:!0,writable:!0,value:D})}if(f)return f;y.prototype.toString=function(){return this.g};var T="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",A=0;return g}),a("Symbol.iterator",function(f){if(f)return f;f=Symbol("Symbol.iterator");for(var g="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),y=0;y<g.length;y++){var T=s[g[y]];typeof T=="function"&&typeof T.prototype[f]!="function"&&n(T.prototype,f,{configurable:!0,writable:!0,value:function(){return o(e(this))}})}return f});function o(f){return f={next:f},f[Symbol.iterator]=function(){return this},f}function i(f){var g=typeof Symbol<"u"&&Symbol.iterator&&f[Symbol.iterator];return g?g.call(f):{next:e(f)}}function u(f){if(!(f instanceof Array)){f=i(f);for(var g,y=[];!(g=f.next()).done;)y.push(g.value);f=y}return f}var l=typeof Object.create=="function"?Object.create:function(f){function g(){}return g.prototype=f,new g},c;if(typeof Object.setPrototypeOf=="function")c=Object.setPrototypeOf;else{var h;e:{var p={a:!0},m={};try{m.__proto__=p,h=m.a;break e}catch{}h=!1}c=h?function(f,g){if(f.__proto__=g,f.__proto__!==g)throw new TypeError(f+" is not extensible");return f}:null}var b=c;function v(f,g){if(f.prototype=l(g.prototype),f.prototype.constructor=f,b)b(f,g);else for(var y in g)if(y!="prototype")if(Object.defineProperties){var T=Object.getOwnPropertyDescriptor(g,y);T&&Object.defineProperty(f,y,T)}else f[y]=g[y];f.ea=g.prototype}function S(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.s=this.m=0,this.j=null}function x(f){if(f.l)throw new TypeError("Generator is already running");f.l=!0}S.prototype.o=function(f){this.h=f};function O(f,g){f.j={U:g,V:!0},f.g=f.m||f.s}S.prototype.return=function(f){this.j={return:f},this.g=this.s};function E(f,g,y){return f.g=y,{value:g}}function $(f){this.g=new S,this.h=f}function I(f,g){x(f.g);var y=f.g.i;return y?F(f,"return"in y?y.return:function(T){return{value:T,done:!0}},g,f.g.return):(f.g.return(g),L(f))}function F(f,g,y,T){try{var A=g.call(f.g.i,y);if(!(A instanceof Object))throw new TypeError("Iterator result "+A+" is not an object");if(!A.done)return f.g.l=!1,A;var B=A.value}catch(D){return f.g.i=null,O(f.g,D),L(f)}return f.g.i=null,T.call(f.g,B),L(f)}function L(f){for(;f.g.g;)try{var g=f.h(f.g);if(g)return f.g.l=!1,{value:g.value,done:!1}}catch(y){f.g.h=void 0,O(f.g,y)}if(f.g.l=!1,f.g.j){if(g=f.g.j,f.g.j=null,g.V)throw g.U;return{value:g.return,done:!0}}return{value:void 0,done:!0}}function M(f){this.next=function(g){return x(f.g),f.g.i?g=F(f,f.g.i.next,g,f.g.o):(f.g.o(g),g=L(f)),g},this.throw=function(g){return x(f.g),f.g.i?g=F(f,f.g.i.throw,g,f.g.o):(O(f.g,g),g=L(f)),g},this.return=function(g){return I(f,g)},this[Symbol.iterator]=function(){return this}}function C(f,g){return g=new M(new $(g)),b&&f.prototype&&b(g,f.prototype),g}function j(f,g){f instanceof String&&(f+="");var y=0,T=!1,A={next:function(){if(!T&&y<f.length){var B=y++;return{value:g(B,f[B]),done:!1}}return T=!0,{done:!0,value:void 0}}};return A[Symbol.iterator]=function(){return A},A}var V=typeof Object.assign=="function"?Object.assign:function(f,g){for(var y=1;y<arguments.length;y++){var T=arguments[y];if(T)for(var A in T)Object.prototype.hasOwnProperty.call(T,A)&&(f[A]=T[A])}return f};a("Object.assign",function(f){return f||V}),a("Promise",function(f){function g(D){this.h=0,this.i=void 0,this.g=[],this.o=!1;var P=this.j();try{D(P.resolve,P.reject)}catch(z){P.reject(z)}}function y(){this.g=null}function T(D){return D instanceof g?D:new g(function(P){P(D)})}if(f)return f;y.prototype.h=function(D){if(this.g==null){this.g=[];var P=this;this.i(function(){P.l()})}this.g.push(D)};var A=s.setTimeout;y.prototype.i=function(D){A(D,0)},y.prototype.l=function(){for(;this.g&&this.g.length;){var D=this.g;this.g=[];for(var P=0;P<D.length;++P){var z=D[P];D[P]=null;try{z()}catch(W){this.j(W)}}}this.g=null},y.prototype.j=function(D){this.i(function(){throw D})},g.prototype.j=function(){function D(W){return function(J){z||(z=!0,W.call(P,J))}}var P=this,z=!1;return{resolve:D(this.C),reject:D(this.l)}},g.prototype.C=function(D){if(D===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(D instanceof g)this.F(D);else{e:switch(typeof D){case"object":var P=D!=null;break e;case"function":P=!0;break e;default:P=!1}P?this.u(D):this.m(D)}},g.prototype.u=function(D){var P=void 0;try{P=D.then}catch(z){this.l(z);return}typeof P=="function"?this.G(P,D):this.m(D)},g.prototype.l=function(D){this.s(2,D)},g.prototype.m=function(D){this.s(1,D)},g.prototype.s=function(D,P){if(this.h!=0)throw Error("Cannot settle("+D+", "+P+"): Promise already settled in state"+this.h);this.h=D,this.i=P,this.h===2&&this.D(),this.A()},g.prototype.D=function(){var D=this;A(function(){if(D.B()){var P=s.console;typeof P<"u"&&P.error(D.i)}},1)},g.prototype.B=function(){if(this.o)return!1;var D=s.CustomEvent,P=s.Event,z=s.dispatchEvent;return typeof z>"u"?!0:(typeof D=="function"?D=new D("unhandledrejection",{cancelable:!0}):typeof P=="function"?D=new P("unhandledrejection",{cancelable:!0}):(D=s.document.createEvent("CustomEvent"),D.initCustomEvent("unhandledrejection",!1,!0,D)),D.promise=this,D.reason=this.i,z(D))},g.prototype.A=function(){if(this.g!=null){for(var D=0;D<this.g.length;++D)B.h(this.g[D]);this.g=null}};var B=new y;return g.prototype.F=function(D){var P=this.j();D.J(P.resolve,P.reject)},g.prototype.G=function(D,P){var z=this.j();try{D.call(P,z.resolve,z.reject)}catch(W){z.reject(W)}},g.prototype.then=function(D,P){function z(ue,te){return typeof ue=="function"?function(H){try{W(ue(H))}catch(Q){J(Q)}}:te}var W,J,Se=new g(function(ue,te){W=ue,J=te});return this.J(z(D,W),z(P,J)),Se},g.prototype.catch=function(D){return this.then(void 0,D)},g.prototype.J=function(D,P){function z(){switch(W.h){case 1:D(W.i);break;case 2:P(W.i);break;default:throw Error("Unexpected state: "+W.h)}}var W=this;this.g==null?B.h(z):this.g.push(z),this.o=!0},g.resolve=T,g.reject=function(D){return new g(function(P,z){z(D)})},g.race=function(D){return new g(function(P,z){for(var W=i(D),J=W.next();!J.done;J=W.next())T(J.value).J(P,z)})},g.all=function(D){var P=i(D),z=P.next();return z.done?T([]):new g(function(W,J){function Se(H){return function(Q){ue[H]=Q,te--,te==0&&W(ue)}}var ue=[],te=0;do ue.push(void 0),te++,T(z.value).J(Se(ue.length-1),J),z=P.next();while(!z.done)})},g}),a("Object.is",function(f){return f||function(g,y){return g===y?g!==0||1/g===1/y:g!==g&&y!==y}}),a("Array.prototype.includes",function(f){return f||function(g,y){var T=this;T instanceof String&&(T=String(T));var A=T.length;for(y=y||0,0>y&&(y=Math.max(y+A,0));y<A;y++){var B=T[y];if(B===g||Object.is(B,g))return!0}return!1}}),a("String.prototype.includes",function(f){return f||function(g,y){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(g instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(g,y||0)!==-1}}),a("Array.prototype.keys",function(f){return f||function(){return j(this,function(g){return g})}});var G=this||self;function X(f,g){f=f.split(".");var y=G;f[0]in y||typeof y.execScript>"u"||y.execScript("var "+f[0]);for(var T;f.length&&(T=f.shift());)f.length||g===void 0?y[T]&&y[T]!==Object.prototype[T]?y=y[T]:y=y[T]={}:y[T]=g}function ee(f,g){return g=String.fromCharCode.apply(null,g),f==null?g:f+g}var he,we=typeof TextDecoder<"u",Oe,Ve=typeof TextEncoder<"u";function je(f){if(Ve)f=(Oe||(Oe=new TextEncoder)).encode(f);else{var g=void 0;g=g===void 0?!1:g;for(var y=0,T=new Uint8Array(3*f.length),A=0;A<f.length;A++){var B=f.charCodeAt(A);if(128>B)T[y++]=B;else{if(2048>B)T[y++]=B>>6|192;else{if(55296<=B&&57343>=B){if(56319>=B&&A<f.length){var D=f.charCodeAt(++A);if(56320<=D&&57343>=D){B=1024*(B-55296)+D-56320+65536,T[y++]=B>>18|240,T[y++]=B>>12&63|128,T[y++]=B>>6&63|128,T[y++]=B&63|128;continue}else A--}if(g)throw Error("Found an unpaired surrogate");B=65533}T[y++]=B>>12|224,T[y++]=B>>6&63|128}T[y++]=B&63|128}}f=T.subarray(0,y)}return f}var Ot={},St=null;function Jt(f,g){g===void 0&&(g=0),Tt(),g=Ot[g];for(var y=Array(Math.floor(f.length/3)),T=g[64]||"",A=0,B=0;A<f.length-2;A+=3){var D=f[A],P=f[A+1],z=f[A+2],W=g[D>>2];D=g[(D&3)<<4|P>>4],P=g[(P&15)<<2|z>>6],z=g[z&63],y[B++]=W+D+P+z}switch(W=0,z=T,f.length-A){case 2:W=f[A+1],z=g[(W&15)<<2]||T;case 1:f=f[A],y[B]=g[f>>2]+g[(f&3)<<4|W>>4]+z+T}return y.join("")}function Dt(f){var g=f.length,y=3*g/4;y%3?y=Math.floor(y):"=.".indexOf(f[g-1])!=-1&&(y="=.".indexOf(f[g-2])!=-1?y-2:y-1);var T=new Uint8Array(y),A=0;return Nt(f,function(B){T[A++]=B}),T.subarray(0,A)}function Nt(f,g){function y(z){for(;T<f.length;){var W=f.charAt(T++),J=St[W];if(J!=null)return J;if(!/^[\s\xa0]*$/.test(W))throw Error("Unknown base64 encoding at char: "+W)}return z}Tt();for(var T=0;;){var A=y(-1),B=y(0),D=y(64),P=y(64);if(P===64&&A===-1)break;g(A<<2|B>>4),D!=64&&(g(B<<4&240|D>>2),P!=64&&g(D<<6&192|P))}}function Tt(){if(!St){St={};for(var f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),g=["+/=","+/","-_=","-_.","-_"],y=0;5>y;y++){var T=f.concat(g[y].split(""));Ot[y]=T;for(var A=0;A<T.length;A++){var B=T[A];St[B]===void 0&&(St[B]=A)}}}}var Et=typeof Uint8Array.prototype.slice=="function",Ft;function Qt(f,g,y){return g===y?Ft||(Ft=new Uint8Array(0)):Et?f.slice(g,y):new Uint8Array(f.subarray(g,y))}var tt=0,kt=0;function ts(f,g){g=g===void 0?{}:g,g=g.v===void 0?!1:g.v,this.h=null,this.g=this.i=this.j=0,this.l=!1,this.v=g,f&&xi(this,f)}function xi(f,g){g=g.constructor===Uint8Array?g:g.constructor===ArrayBuffer?new Uint8Array(g):g.constructor===Array?new Uint8Array(g):g.constructor===String?Dt(g):g instanceof Uint8Array?new Uint8Array(g.buffer,g.byteOffset,g.byteLength):new Uint8Array(0),f.h=g,f.j=0,f.i=f.h.length,f.g=f.j}ts.prototype.reset=function(){this.g=this.j};function pr(f){var g=f.h,y=g[f.g],T=y&127;return 128>y?(f.g+=1,T):(y=g[f.g+1],T|=(y&127)<<7,128>y?(f.g+=2,T):(y=g[f.g+2],T|=(y&127)<<14,128>y?(f.g+=3,T):(y=g[f.g+3],T|=(y&127)<<21,128>y?(f.g+=4,T):(y=g[f.g+4],T|=(y&15)<<28,128>y?(f.g+=5,T>>>0):(f.g+=5,128<=g[f.g++]&&128<=g[f.g++]&&128<=g[f.g++]&&128<=g[f.g++]&&f.g++,T)))))}function _t(f){var g=f.h[f.g],y=f.h[f.g+1],T=f.h[f.g+2],A=f.h[f.g+3];return f.g+=4,y=(g<<0|y<<8|T<<16|A<<24)>>>0,f=2*(y>>31)+1,g=y>>>23&255,y&=8388607,g==255?y?NaN:1/0*f:g==0?f*Math.pow(2,-149)*y:f*Math.pow(2,g-150)*(y+Math.pow(2,23))}var $i=[];function ns(){this.g=new Uint8Array(64),this.h=0}ns.prototype.push=function(f){if(!(this.h+1<this.g.length)){var g=this.g;this.g=new Uint8Array(Math.ceil(1+2*this.g.length)),this.g.set(g)}this.g[this.h++]=f},ns.prototype.length=function(){return this.h},ns.prototype.end=function(){var f=this.g,g=this.h;return this.h=0,Qt(f,0,g)};function en(f,g){for(;127<g;)f.push(g&127|128),g>>>=7;f.push(g)}function rs(f){var g={},y=g.N===void 0?!1:g.N;this.o={v:g.v===void 0?!1:g.v},this.N=y,g=this.o,$i.length?(y=$i.pop(),g&&(y.v=g.v),f&&xi(y,f),f=y):f=new ts(f,g),this.g=f,this.m=this.g.g,this.h=this.i=this.l=-1,this.j=!1}rs.prototype.reset=function(){this.g.reset(),this.h=this.l=-1};function jn(f){var g=f.g;if((g=g.g==g.i)||(g=f.j)||(g=f.g,g=g.l||0>g.g||g.g>g.i),g)return!1;f.m=f.g.g,g=pr(f.g);var y=g&7;return y!=0&&y!=5&&y!=1&&y!=2&&y!=3&&y!=4?(f.j=!0,!1):(f.i=g,f.l=g>>>3,f.h=y,!0)}function Un(f){switch(f.h){case 0:if(f.h!=0)Un(f);else{for(f=f.g;f.h[f.g]&128;)f.g++;f.g++}break;case 1:f.h!=1?Un(f):(f=f.g,f.g+=8);break;case 2:if(f.h!=2)Un(f);else{var g=pr(f.g);f=f.g,f.g+=g}break;case 5:f.h!=5?Un(f):(f=f.g,f.g+=4);break;case 3:g=f.l;do{if(!jn(f)){f.j=!0;break}if(f.h==4){f.l!=g&&(f.j=!0);break}Un(f)}while(1);break;default:f.j=!0}}function Ai(f,g,y){var T=f.g.i,A=pr(f.g);return A=f.g.g+A,f.g.i=A,y(g,f),f.g.g=A,f.g.i=T,g}function Ii(f){var g=pr(f.g);f=f.g;var y=f.g;f.g+=g,f=f.h;var T;if(we)(T=he)||(T=he=new TextDecoder("utf-8",{fatal:!1})),T=T.decode(f.subarray(y,y+g));else{g=y+g;for(var A=[],B=null,D,P,z;y<g;)D=f[y++],128>D?A.push(D):224>D?y>=g?A.push(65533):(P=f[y++],194>D||(P&192)!==128?(y--,A.push(65533)):A.push((D&31)<<6|P&63)):240>D?y>=g-1?A.push(65533):(P=f[y++],(P&192)!==128||D===224&&160>P||D===237&&160<=P||((T=f[y++])&192)!==128?(y--,A.push(65533)):A.push((D&15)<<12|(P&63)<<6|T&63)):244>=D?y>=g-2?A.push(65533):(P=f[y++],(P&192)!==128||(D<<28)+(P-144)>>30!==0||((T=f[y++])&192)!==128||((z=f[y++])&192)!==128?(y--,A.push(65533)):(D=(D&7)<<18|(P&63)<<12|(T&63)<<6|z&63,D-=65536,A.push((D>>10&1023)+55296,(D&1023)+56320))):A.push(65533),8192<=A.length&&(B=ee(B,A),A.length=0);T=ee(B,A)}return T}function oa(){this.h=[],this.i=0,this.g=new ns}function qn(f,g){g.length!==0&&(f.h.push(g),f.i+=g.length)}function ia(f){var g=f.i+f.g.length();if(g===0)return new Uint8Array(0);g=new Uint8Array(g);for(var y=f.h,T=y.length,A=0,B=0;B<T;B++){var D=y[B];D.length!==0&&(g.set(D,A),A+=D.length)}return y=f.g,T=y.h,T!==0&&(g.set(y.g.subarray(0,T),A),y.h=0),f.h=[g],g}function xt(f,g,y){if(y!=null){en(f.g,8*g+5),f=f.g;var T=y;T=(y=0>T?1:0)?-T:T,T===0?0<1/T?tt=kt=0:(kt=0,tt=2147483648):isNaN(T)?(kt=0,tt=2147483647):34028234663852886e22<T?(kt=0,tt=(y<<31|2139095040)>>>0):11754943508222875e-54>T?(T=Math.round(T/Math.pow(2,-149)),kt=0,tt=(y<<31|T)>>>0):(g=Math.floor(Math.log(T)/Math.LN2),T*=Math.pow(2,-g),T=Math.round(8388608*T)&8388607,kt=0,tt=(y<<31|g+127<<23|T)>>>0),y=tt,f.push(y>>>0&255),f.push(y>>>8&255),f.push(y>>>16&255),f.push(y>>>24&255)}}var Sm=typeof Uint8Array=="function";function Oi(f,g,y){if(f!=null)return typeof f=="object"?Sm&&f instanceof Uint8Array?y(f):Di(f,g,y):g(f)}function Di(f,g,y){if(Array.isArray(f)){for(var T=Array(f.length),A=0;A<f.length;A++)T[A]=Oi(f[A],g,y);return Array.isArray(f)&&f.W&&dr(T),T}T={};for(A in f)T[A]=Oi(f[A],g,y);return T}function Nm(f){return typeof f=="number"?isFinite(f)?f:String(f):f}var Tm={W:{value:!0,configurable:!0}};function dr(f){return Array.isArray(f)&&!Object.isFrozen(f)&&Object.defineProperties(f,Tm),f}var Fi;function lt(f,g,y){var T=Fi;Fi=null,f||(f=T),T=this.constructor.ca,f||(f=T?[T]:[]),this.j=T?0:-1,this.i=null,this.g=f;e:{if(T=this.g.length,f=T-1,T&&(T=this.g[f],T!==null&&typeof T=="object"&&T.constructor===Object)){this.l=f-this.j,this.h=T;break e}g!==void 0&&-1<g?(this.l=Math.max(g,f+1-this.j),this.h=null):this.l=Number.MAX_VALUE}if(y)for(g=0;g<y.length;g++)f=y[g],f<this.l?(f+=this.j,(T=this.g[f])?dr(T):this.g[f]=ss):(Pi(this),(T=this.h[f])?dr(T):this.h[f]=ss)}var ss=Object.freeze(dr([]));function Pi(f){var g=f.l+f.j;f.g[g]||(f.h=f.g[g]={})}function Re(f,g,y){return g===-1?null:(y===void 0?0:y)||g>=f.l?f.h?f.h[g]:void 0:f.g[g+f.j]}function Ri(f){var g=g===void 0?!1:g,y=Re(f,1,g);return y==null&&(y=ss),y===ss&&(y=dr([]),ve(f,1,y,g)),y}function Pt(f,g,y){return f=Re(f,g),f=f==null?f:+f,f??(y===void 0?0:y)}function ve(f,g,y,T){(T===void 0?0:T)||g>=f.l?(Pi(f),f.h[g]=y):f.g[g+f.j]=y}function ua(f,g){f.i||(f.i={});var y=f.i[1];if(!y){var T=Ri(f);y=[];for(var A=0;A<T.length;A++)y[A]=new g(T[A]);f.i[1]=y}return y}function Ci(f,g,y,T){var A=ua(f,y);g=g||new y,f=Ri(f),T!=null?(A.splice(T,0,g),f.splice(T,0,Wn(g))):(A.push(g),f.push(Wn(g)))}lt.prototype.toJSON=function(){var f=Wn(this);return Di(f,Nm,Jt)};function Wn(f,g){if(f.i)for(var y in f.i){var T=f.i[y];if(Array.isArray(T))for(var A=0;A<T.length;A++)T[A]&&Wn(T[A]);else T&&Wn(T)}return f.g}lt.prototype.toString=function(){return Wn(this).toString()};function Bi(f,g){return f=Re(f,g),f??0}function Li(f,g){return f=Re(f,g),f??""}function la(f,g){if(f=f.m){qn(g,g.g.end());for(var y=0;y<f.length;y++)qn(g,f[y])}}function mr(f,g){if(g.h==4)return!1;var y=g.m;return Un(g),g.N||(g=Qt(g.g.h,y,g.g.g),(y=f.m)?y.push(g):f.m=[g]),!0}function He(f,g){var y=void 0;return new(y||(y=Promise))(function(T,A){function B(z){try{P(g.next(z))}catch(W){A(W)}}function D(z){try{P(g.throw(z))}catch(W){A(W)}}function P(z){z.done?T(z.value):new y(function(W){W(z.value)}).then(B,D)}P((g=g.apply(f,void 0)).next())})}function gr(f){lt.call(this,f)}v(gr,lt);function Em(f,g){for(;jn(g);)switch(g.i){case 8:var y=pr(g.g);ve(f,1,y);break;case 21:y=_t(g.g),ve(f,2,y);break;case 26:y=Ii(g),ve(f,3,y);break;case 34:y=Ii(g),ve(f,4,y);break;default:if(!mr(f,g))return f}return f}function ca(f){lt.call(this,f,-1,km)}v(ca,lt),ca.prototype.addClassification=function(f,g){Ci(this,f,gr,g)};var km=[1];function yr(f){lt.call(this,f)}v(yr,lt);function _m(f,g){for(;jn(g);)switch(g.i){case 13:var y=_t(g.g);ve(f,1,y);break;case 21:y=_t(g.g),ve(f,2,y);break;case 29:y=_t(g.g),ve(f,3,y);break;case 37:y=_t(g.g),ve(f,4,y);break;case 45:y=_t(g.g),ve(f,5,y);break;default:if(!mr(f,g))return f}return f}function Mi(f){lt.call(this,f,-1,xm)}v(Mi,lt);var xm=[1];function ha(f){lt.call(this,f)}v(ha,lt);function zi(f,g,y){if(y=f.createShader(y===0?f.VERTEX_SHADER:f.FRAGMENT_SHADER),f.shaderSource(y,g),f.compileShader(y),!f.getShaderParameter(y,f.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+f.getShaderInfoLog(y));return y}function $m(f){return ua(f,gr).map(function(g){return{index:Bi(g,1),Y:Pt(g,2),label:Re(g,3)!=null?Li(g,3):void 0,displayName:Re(g,4)!=null?Li(g,4):void 0}})}function Am(f){return{x:Pt(f,1),y:Pt(f,2),z:Pt(f,3),visibility:Re(f,4)!=null?Pt(f,4):void 0}}function fa(f,g){this.h=f,this.g=g,this.l=0}function Vi(f,g,y){return Im(f,g),typeof f.g.canvas.transferToImageBitmap=="function"?Promise.resolve(f.g.canvas.transferToImageBitmap()):y?Promise.resolve(f.g.canvas):typeof createImageBitmap=="function"?createImageBitmap(f.g.canvas):(f.i===void 0&&(f.i=document.createElement("canvas")),new Promise(function(T){f.i.height=f.g.canvas.height,f.i.width=f.g.canvas.width,f.i.getContext("2d",{}).drawImage(f.g.canvas,0,0,f.g.canvas.width,f.g.canvas.height),T(f.i)}))}function Im(f,g){var y=f.g;if(f.m===void 0){var T=zi(y,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),A=zi(y,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),B=y.createProgram();if(y.attachShader(B,T),y.attachShader(B,A),y.linkProgram(B),!y.getProgramParameter(B,y.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+y.getProgramInfoLog(B));T=f.m=B,y.useProgram(T),A=y.getUniformLocation(T,"sampler0"),f.j={I:y.getAttribLocation(T,"aVertex"),H:y.getAttribLocation(T,"aTex"),da:A},f.s=y.createBuffer(),y.bindBuffer(y.ARRAY_BUFFER,f.s),y.enableVertexAttribArray(f.j.I),y.vertexAttribPointer(f.j.I,2,y.FLOAT,!1,0,0),y.bufferData(y.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),y.STATIC_DRAW),y.bindBuffer(y.ARRAY_BUFFER,null),f.o=y.createBuffer(),y.bindBuffer(y.ARRAY_BUFFER,f.o),y.enableVertexAttribArray(f.j.H),y.vertexAttribPointer(f.j.H,2,y.FLOAT,!1,0,0),y.bufferData(y.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),y.STATIC_DRAW),y.bindBuffer(y.ARRAY_BUFFER,null),y.uniform1i(A,0)}T=f.j,y.useProgram(f.m),y.canvas.width=g.width,y.canvas.height=g.height,y.viewport(0,0,g.width,g.height),y.activeTexture(y.TEXTURE0),f.h.bindTexture2d(g.glName),y.enableVertexAttribArray(T.I),y.bindBuffer(y.ARRAY_BUFFER,f.s),y.vertexAttribPointer(T.I,2,y.FLOAT,!1,0,0),y.enableVertexAttribArray(T.H),y.bindBuffer(y.ARRAY_BUFFER,f.o),y.vertexAttribPointer(T.H,2,y.FLOAT,!1,0,0),y.bindFramebuffer(y.DRAW_FRAMEBUFFER?y.DRAW_FRAMEBUFFER:y.FRAMEBUFFER,null),y.clearColor(0,0,0,0),y.clear(y.COLOR_BUFFER_BIT),y.colorMask(!0,!0,!0,!0),y.drawArrays(y.TRIANGLE_FAN,0,4),y.disableVertexAttribArray(T.I),y.disableVertexAttribArray(T.H),y.bindBuffer(y.ARRAY_BUFFER,null),f.h.bindTexture2d(0)}function Om(f){this.g=f}var Dm=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function Fm(f,g){return g+f}function ji(f,g){window[f]=g}function Pm(f){var g=document.createElement("script");return g.setAttribute("src",f),g.setAttribute("crossorigin","anonymous"),new Promise(function(y){g.addEventListener("load",function(){y()},!1),g.addEventListener("error",function(){y()},!1),document.body.appendChild(g)})}function Rm(){return He(this,function f(){return C(f,function(g){switch(g.g){case 1:return g.m=2,E(g,WebAssembly.instantiate(Dm),4);case 4:g.g=3,g.m=0;break;case 2:return g.m=0,g.j=null,g.return(!1);case 3:return g.return(!0)}})})}function pa(f){if(this.g=f,this.listeners={},this.j={},this.F={},this.m={},this.s={},this.G=this.o=this.R=!0,this.C=Promise.resolve(),this.P="",this.B={},this.locateFile=f&&f.locateFile||Fm,typeof window=="object")var g=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")g=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.S=g,f.options){g=i(Object.keys(f.options));for(var y=g.next();!y.done;y=g.next()){y=y.value;var T=f.options[y].default;T!==void 0&&(this.j[y]=typeof T=="function"?T():T)}}}t=pa.prototype,t.close=function(){return this.i&&this.i.delete(),Promise.resolve()};function Cm(f,g){return f.g.files===void 0?[]:typeof f.g.files=="function"?f.g.files(g):f.g.files}function Bm(f){return He(f,function g(){var y=this,T,A,B,D,P,z,W,J,Se,ue,te;return C(g,function(H){switch(H.g){case 1:return T=y,y.R?(A=Cm(y,y.j),E(H,Rm(),2)):H.return();case 2:if(B=H.h,typeof window=="object")return ji("createMediapipeSolutionsWasm",{locateFile:y.locateFile}),ji("createMediapipeSolutionsPackedAssets",{locateFile:y.locateFile}),z=A.filter(function(Q){return Q.data!==void 0}),W=A.filter(function(Q){return Q.data===void 0}),J=Promise.all(z.map(function(Q){var ie=as(T,Q.url);if(Q.path!==void 0){var fe=Q.path;ie=ie.then(function(ze){return T.overrideFile(fe,ze),Promise.resolve(ze)})}return ie})),Se=Promise.all(W.map(function(Q){return Q.simd===void 0||Q.simd&&B||!Q.simd&&!B?Pm(T.locateFile(Q.url,T.S)):Promise.resolve()})).then(function(){return He(T,function Q(){var ie,fe,ze=this;return C(Q,function(Te){if(Te.g==1)return ie=window.createMediapipeSolutionsWasm,fe=window.createMediapipeSolutionsPackedAssets,E(Te,ie(fe),2);ze.h=Te.h,Te.g=0})})}),ue=function(){return He(T,function Q(){var ie=this;return C(Q,function(fe){return ie.g.graph&&ie.g.graph.url?fe=E(fe,as(ie,ie.g.graph.url),0):(fe.g=0,fe=void 0),fe})})}(),E(H,Promise.all([Se,J,ue]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return D=A.filter(function(Q){return Q.simd===void 0||Q.simd&&B||!Q.simd&&!B}).map(function(Q){return T.locateFile(Q.url,T.S)}),importScripts.apply(null,u(D)),E(H,createMediapipeSolutionsWasm(Module),6);case 6:y.h=H.h,y.l=new OffscreenCanvas(1,1),y.h.canvas=y.l,P=y.h.GL.createContext(y.l,{antialias:!1,alpha:!1,ba:typeof WebGL2RenderingContext<"u"?2:1}),y.h.GL.makeContextCurrent(P),H.g=4;break;case 7:if(y.l=document.createElement("canvas"),te=y.l.getContext("webgl2",{}),!te&&(te=y.l.getContext("webgl",{}),!te))return alert("Failed to create WebGL canvas context when passing video frame."),H.return();y.D=te,y.h.canvas=y.l,y.h.createContext(y.l,!0,!0,{});case 4:y.i=new y.h.SolutionWasm,y.R=!1,H.g=0}})})}function Lm(f){return He(f,function g(){var y=this,T,A,B,D,P,z,W,J;return C(g,function(Se){if(Se.g==1){if(y.g.graph&&y.g.graph.url&&y.P===y.g.graph.url)return Se.return();if(y.o=!0,!y.g.graph||!y.g.graph.url){Se.g=2;return}return y.P=y.g.graph.url,E(Se,as(y,y.g.graph.url),3)}for(Se.g!=2&&(T=Se.h,y.i.loadGraph(T)),A=i(Object.keys(y.B)),B=A.next();!B.done;B=A.next())D=B.value,y.i.overrideFile(D,y.B[D]);if(y.B={},y.g.listeners)for(P=i(y.g.listeners),z=P.next();!z.done;z=P.next())W=z.value,jm(y,W);J=y.j,y.j={},y.setOptions(J),Se.g=0})})}t.reset=function(){return He(this,function f(){var g=this;return C(f,function(y){g.i&&(g.i.reset(),g.m={},g.s={}),y.g=0})})},t.setOptions=function(f,g){var y=this;if(g=g||this.g.options){for(var T=[],A=[],B={},D=i(Object.keys(f)),P=D.next();!P.done;B={K:B.K,L:B.L},P=D.next()){var z=P.value;z in this.j&&this.j[z]===f[z]||(this.j[z]=f[z],P=g[z],P!==void 0&&(P.onChange&&(B.K=P.onChange,B.L=f[z],T.push(function(W){return function(){return He(y,function J(){var Se,ue=this;return C(J,function(te){if(te.g==1)return E(te,W.K(W.L),2);Se=te.h,Se===!0&&(ue.o=!0),te.g=0})})}}(B))),P.graphOptionXref&&(z={valueNumber:P.type===1?f[z]:0,valueBoolean:P.type===0?f[z]:!1,valueString:P.type===2?f[z]:""},P=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),P.graphOptionXref),z),A.push(P))))}(T.length!==0||A.length!==0)&&(this.o=!0,this.A=(this.A===void 0?[]:this.A).concat(A),this.u=(this.u===void 0?[]:this.u).concat(T))}};function Mm(f){return He(f,function g(){var y=this,T,A,B,D,P,z,W;return C(g,function(J){switch(J.g){case 1:if(!y.o)return J.return();if(!y.u){J.g=2;break}T=i(y.u),A=T.next();case 3:if(A.done){J.g=5;break}return B=A.value,E(J,B(),4);case 4:A=T.next(),J.g=3;break;case 5:y.u=void 0;case 2:if(y.A){for(D=new y.h.GraphOptionChangeRequestList,P=i(y.A),z=P.next();!z.done;z=P.next())W=z.value,D.push_back(W);y.i.changeOptions(D),D.delete(),y.A=void 0}y.o=!1,J.g=0}})})}t.initialize=function(){return He(this,function f(){var g=this;return C(f,function(y){return y.g==1?E(y,Bm(g),2):y.g!=3?E(y,Lm(g),3):E(y,Mm(g),0)})})};function as(f,g){return He(f,function y(){var T=this,A,B;return C(y,function(D){return g in T.F?D.return(T.F[g]):(A=T.locateFile(g,""),B=fetch(A).then(function(P){return P.arrayBuffer()}),T.F[g]=B,D.return(B))})})}t.overrideFile=function(f,g){this.i?this.i.overrideFile(f,g):this.B[f]=g},t.clearOverriddenFiles=function(){this.B={},this.i&&this.i.clearOverriddenFiles()},t.send=function(f,g){return He(this,function y(){var T=this,A,B,D,P,z,W,J,Se,ue;return C(y,function(te){switch(te.g){case 1:return T.g.inputs?(A=1e3*(g??performance.now()),E(te,T.C,2)):te.return();case 2:return E(te,T.initialize(),3);case 3:for(B=new T.h.PacketDataList,D=i(Object.keys(f)),P=D.next();!P.done;P=D.next())if(z=P.value,W=T.g.inputs[z]){e:{var H=T,Q=f[z];switch(W.type){case"video":var ie=H.m[W.stream];if(ie||(ie=new fa(H.h,H.D),H.m[W.stream]=ie),H=ie,H.l===0&&(H.l=H.h.createTexture()),typeof HTMLVideoElement<"u"&&Q instanceof HTMLVideoElement){var fe=Q.videoWidth;ie=Q.videoHeight}else typeof HTMLImageElement<"u"&&Q instanceof HTMLImageElement?(fe=Q.naturalWidth,ie=Q.naturalHeight):(fe=Q.width,ie=Q.height);ie={glName:H.l,width:fe,height:ie},fe=H.g,fe.canvas.width=ie.width,fe.canvas.height=ie.height,fe.activeTexture(fe.TEXTURE0),H.h.bindTexture2d(H.l),fe.texImage2D(fe.TEXTURE_2D,0,fe.RGBA,fe.RGBA,fe.UNSIGNED_BYTE,Q),H.h.bindTexture2d(0),H=ie;break e;case"detections":for(ie=H.m[W.stream],ie||(ie=new Om(H.h),H.m[W.stream]=ie),H=ie,H.data||(H.data=new H.g.DetectionListData),H.data.reset(Q.length),ie=0;ie<Q.length;++ie){fe=Q[ie];var ze=H.data,Te=ze.setBoundingBox,Qe=ie,Ce=fe.T,oe=new ha;ve(oe,1,Ce.Z),ve(oe,2,Ce.$),ve(oe,3,Ce.height),ve(oe,4,Ce.width),ve(oe,5,Ce.rotation),ve(oe,6,Ce.X);var pe=Ce=new oa;xt(pe,1,Re(oe,1)),xt(pe,2,Re(oe,2)),xt(pe,3,Re(oe,3)),xt(pe,4,Re(oe,4)),xt(pe,5,Re(oe,5));var me=Re(oe,6);if(me!=null&&me!=null){en(pe.g,48);var ae=pe.g,de=me;me=0>de,de=Math.abs(de);var Z=de>>>0;for(de=Math.floor((de-Z)/4294967296),de>>>=0,me&&(de=~de>>>0,Z=(~Z>>>0)+1,4294967295<Z&&(Z=0,de++,4294967295<de&&(de=0))),tt=Z,kt=de,me=tt,Z=kt;0<Z||127<me;)ae.push(me&127|128),me=(me>>>7|Z<<25)>>>0,Z>>>=7;ae.push(me)}if(la(oe,pe),Ce=ia(Ce),Te.call(ze,Qe,Ce),fe.O)for(ze=0;ze<fe.O.length;++ze)oe=fe.O[ze],pe=!!oe.visibility,Te=H.data,Qe=Te.addNormalizedLandmark,Ce=ie,oe=Object.assign(Object.assign({},oe),{visibility:pe?oe.visibility:0}),pe=new yr,ve(pe,1,oe.x),ve(pe,2,oe.y),ve(pe,3,oe.z),oe.visibility&&ve(pe,4,oe.visibility),ae=oe=new oa,xt(ae,1,Re(pe,1)),xt(ae,2,Re(pe,2)),xt(ae,3,Re(pe,3)),xt(ae,4,Re(pe,4)),xt(ae,5,Re(pe,5)),la(pe,ae),oe=ia(oe),Qe.call(Te,Ce,oe);if(fe.M)for(ze=0;ze<fe.M.length;++ze){if(Te=H.data,Qe=Te.addClassification,Ce=ie,oe=fe.M[ze],pe=new gr,ve(pe,2,oe.Y),oe.index&&ve(pe,1,oe.index),oe.label&&ve(pe,3,oe.label),oe.displayName&&ve(pe,4,oe.displayName),ae=oe=new oa,Z=Re(pe,1),Z!=null&&Z!=null)if(en(ae.g,8),me=ae.g,0<=Z)en(me,Z);else{for(de=0;9>de;de++)me.push(Z&127|128),Z>>=7;me.push(1)}xt(ae,2,Re(pe,2)),me=Re(pe,3),me!=null&&(me=je(me),en(ae.g,26),en(ae.g,me.length),qn(ae,ae.g.end()),qn(ae,me)),me=Re(pe,4),me!=null&&(me=je(me),en(ae.g,34),en(ae.g,me.length),qn(ae,ae.g.end()),qn(ae,me)),la(pe,ae),oe=ia(oe),Qe.call(Te,Ce,oe)}}H=H.data;break e;default:H={}}}switch(J=H,Se=W.stream,W.type){case"video":B.pushTexture2d(Object.assign(Object.assign({},J),{stream:Se,timestamp:A}));break;case"detections":ue=J,ue.stream=Se,ue.timestamp=A,B.pushDetectionList(ue);break;default:throw Error("Unknown input config type: '"+W.type+"'")}}return T.i.send(B),E(te,T.C,4);case 4:B.delete(),te.g=0}})})};function zm(f,g,y){return He(f,function T(){var A,B,D,P,z,W,J=this,Se,ue,te,H,Q,ie,fe,ze;return C(T,function(Te){switch(Te.g){case 1:if(!y)return Te.return(g);for(A={},B=0,D=i(Object.keys(y)),P=D.next();!P.done;P=D.next())z=P.value,W=y[z],typeof W!="string"&&W.type==="texture"&&g[W.stream]!==void 0&&++B;1<B&&(J.G=!1),Se=i(Object.keys(y)),P=Se.next();case 2:if(P.done){Te.g=4;break}if(ue=P.value,te=y[ue],typeof te=="string")return fe=A,ze=ue,E(Te,Vm(J,ue,g[te]),14);if(H=g[te.stream],te.type==="detection_list"){if(H){for(var Qe=H.getRectList(),Ce=H.getLandmarksList(),oe=H.getClassificationsList(),pe=[],me=0;me<Qe.size();++me){var ae=Qe.get(me);e:{var de=new ha;for(ae=new rs(ae);jn(ae);)switch(ae.i){case 13:var Z=_t(ae.g);ve(de,1,Z);break;case 21:Z=_t(ae.g),ve(de,2,Z);break;case 29:Z=_t(ae.g),ve(de,3,Z);break;case 37:Z=_t(ae.g),ve(de,4,Z);break;case 45:Z=_t(ae.g),ve(de,5,Z);break;case 48:for(var De=ae.g,Le=128,da=0,bn=Z=0;4>bn&&128<=Le;bn++)Le=De.h[De.g++],da|=(Le&127)<<7*bn;if(128<=Le&&(Le=De.h[De.g++],da|=(Le&127)<<28,Z|=(Le&127)>>4),128<=Le)for(bn=0;5>bn&&128<=Le;bn++)Le=De.h[De.g++],Z|=(Le&127)<<7*bn+3;128>Le?(De=da>>>0,Le=Z>>>0,(Z=Le&2147483648)&&(De=~De+1>>>0,Le=~Le>>>0,De==0&&(Le=Le+1>>>0)),De=4294967296*Le+(De>>>0),Z=Z?-De:De):(De.l=!0,Z=void 0),ve(de,6,Z);break;default:if(!mr(de,ae))break e}}de={Z:Pt(de,1),$:Pt(de,2),height:Pt(de,3),width:Pt(de,4),rotation:Pt(de,5,0),X:Bi(de,6)},Z=Ce.get(me);e:for(ae=new Mi,Z=new rs(Z);jn(Z);)switch(Z.i){case 10:De=Ai(Z,new yr,_m),Ci(ae,De,yr,void 0);break;default:if(!mr(ae,Z))break e}ae=ua(ae,yr).map(Am),De=oe.get(me);e:for(Z=new ca,De=new rs(De);jn(De);)switch(De.i){case 10:Z.addClassification(Ai(De,new gr,Em));break;default:if(!mr(Z,De))break e}de={T:de,O:ae,M:$m(Z)},pe.push(de)}Qe=pe}else Qe=[];A[ue]=Qe,Te.g=7;break}if(te.type==="proto_list"){if(H){for(Qe=Array(H.size()),Ce=0;Ce<H.size();Ce++)Qe[Ce]=H.get(Ce);H.delete()}else Qe=[];A[ue]=Qe,Te.g=7;break}if(H===void 0){Te.g=3;break}if(te.type==="float_list"){A[ue]=H,Te.g=7;break}if(te.type==="proto"){A[ue]=H,Te.g=7;break}if(te.type!=="texture")throw Error("Unknown output config type: '"+te.type+"'");return Q=J.s[ue],Q||(Q=new fa(J.h,J.D),J.s[ue]=Q),E(Te,Vi(Q,H,J.G),13);case 13:ie=Te.h,A[ue]=ie;case 7:te.transform&&A[ue]&&(A[ue]=te.transform(A[ue])),Te.g=3;break;case 14:fe[ze]=Te.h;case 3:P=Se.next(),Te.g=2;break;case 4:return Te.return(A)}})})}function Vm(f,g,y){return He(f,function T(){var A=this,B;return C(T,function(D){return typeof y=="number"||y instanceof Uint8Array||y instanceof A.h.Uint8BlobList?D.return(y):y instanceof A.h.Texture2dDataOut?(B=A.s[g],B||(B=new fa(A.h,A.D),A.s[g]=B),D.return(Vi(B,y,A.G))):D.return(void 0)})})}function jm(f,g){for(var y=g.name||"$",T=[].concat(u(g.wants)),A=new f.h.StringList,B=i(g.wants),D=B.next();!D.done;D=B.next())A.push_back(D.value);B=f.h.PacketListener.implement({onResults:function(P){for(var z={},W=0;W<g.wants.length;++W)z[T[W]]=P.get(W);var J=f.listeners[y];J&&(f.C=zm(f,z,g.outs).then(function(Se){Se=J(Se);for(var ue=0;ue<g.wants.length;++ue){var te=z[T[ue]];typeof te=="object"&&te.hasOwnProperty&&te.hasOwnProperty("delete")&&te.delete()}Se&&(f.C=Se)}))}}),f.i.attachMultiListener(A,B),A.delete()}t.onResults=function(f,g){this.listeners[g||"$"]=f},X("Solution",pa),X("OptionType",{BOOL:0,NUMBER:1,aa:2,0:"BOOL",1:"NUMBER",2:"STRING"});function Ui(f){switch(f===void 0&&(f=0),f){case 1:return"selfie_segmentation_landscape.tflite";default:return"selfie_segmentation.tflite"}}function qi(f){var g=this;f=f||{},this.g=new pa({locateFile:f.locateFile,files:function(y){return[{simd:!0,url:"selfie_segmentation_solution_simd_wasm_bin.js"},{simd:!1,url:"selfie_segmentation_solution_wasm_bin.js"},{data:!0,url:Ui(y.modelSelection)}]},graph:{url:"selfie_segmentation.binarypb"},listeners:[{wants:["segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelSelection:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelSelection",fieldName:"int_value"},onChange:function(y){return He(g,function T(){var A,B,D=this,P;return C(T,function(z){return z.g==1?(A=Ui(y),B="third_party/mediapipe/modules/selfie_segmentation/"+A,E(z,as(D.g,A),2)):(P=z.h,D.g.overrideFile(B,P),z.return(!0))})})}}}})}t=qi.prototype,t.close=function(){return this.g.close(),Promise.resolve()},t.onResults=function(f){this.g.onResults(f)},t.initialize=function(){return He(this,function f(){var g=this;return C(f,function(y){return E(y,g.g.initialize(),0)})})},t.reset=function(){this.g.reset()},t.send=function(f){return He(this,function g(){var y=this;return C(g,function(T){return E(T,y.g.send(f),0)})})},t.setOptions=function(f){this.g.setOptions(f)},X("SelfieSegmentation",qi),X("VERSION","0.1.1632777926")}).call(Bt);var vE=SelfieSegmentation,SE=VERSION;var lo=function(t,e){return lo=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,r){n.__proto__=r}||function(n,r){for(var s in r)r.hasOwnProperty(s)&&(n[s]=r[s])},lo(t,e)};function Jd(t,e){function n(){this.constructor=t}lo(t,e),t.prototype=e===null?Object.create(e):(n.prototype=e.prototype,new n)}var Ge=function(){return Ge=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var s in e=arguments[n])Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s]);return t},Ge.apply(this,arguments)};function le(t,e,n,r){return new(n||(n=Promise))(function(s,a){function o(l){try{u(r.next(l))}catch(c){a(c)}}function i(l){try{u(r.throw(l))}catch(c){a(c)}}function u(l){var c;l.done?s(l.value):(c=l.value,c instanceof n?c:new n(function(h){h(c)})).then(o,i)}u((r=r.apply(t,e||[])).next())})}function ce(t,e){var n,r,s,a,o={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return a={next:i(0),throw:i(1),return:i(2)},typeof Symbol=="function"&&(a[Symbol.iterator]=function(){return this}),a;function i(u){return function(l){return function(c){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(s=2&c[0]?r.return:c[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,c[1])).done)return s;switch(r=0,s&&(c=[2&c[0],s.value]),c[0]){case 0:case 1:s=c;break;case 4:return o.label++,{value:c[1],done:!1};case 5:o.label++,r=c[1],c=[0];continue;case 7:c=o.ops.pop(),o.trys.pop();continue;default:if(s=o.trys,!((s=s.length>0&&s[s.length-1])||c[0]!==6&&c[0]!==2)){o=0;continue}if(c[0]===3&&(!s||c[1]>s[0]&&c[1]<s[3])){o.label=c[1];break}if(c[0]===6&&o.label<s[1]){o.label=s[1],s=c;break}if(s&&o.label<s[2]){o.label=s[2],o.ops.push(c);break}s[2]&&o.ops.pop(),o.trys.pop();continue}c=e.call(t,o)}catch(h){c=[6,h],r=0}finally{n=s=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}([u,l])}}}function Fs(t){return t instanceof SVGAnimatedLength?t.baseVal.value:t}function ki(t){return le(this,void 0,void 0,function(){var e,n;return ce(this,function(r){switch(r.label){case 0:return e=document.createElement("canvas"),t instanceof ye?[4,qr(t,e)]:[3,2];case 1:return r.sent(),[3,3];case 2:e.width=Fs(t.width),e.height=Fs(t.height),n=e.getContext("2d"),t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0),r.label=3;case 3:return[2,e]}})})}function Qd(t){return le(this,void 0,void 0,function(){var e,n,r,s,a,o;return ce(this,function(i){switch(i.label){case 0:return t instanceof ye?(e=t.shape.slice(0,2),n=e[0],r=e[1],s=ImageData.bind,[4,qr(t)]):[3,2];case 1:return[2,new(s.apply(ImageData,[void 0,i.sent(),r,n]))];case 2:return a=document.createElement("canvas"),o=a.getContext("2d"),a.width=Fs(t.width),a.height=Fs(t.height),o.drawImage(t,0,0),[2,o.getImageData(0,0,a.width,a.height)]}})})}function em(t){return le(this,void 0,void 0,function(){var e,n;return ce(this,function(r){switch(r.label){case 0:return t instanceof SVGImageElement||t instanceof OffscreenCanvas?[4,ki(t)]:[3,2];case 1:return n=r.sent(),[3,3];case 2:n=t,r.label=3;case 3:return e=n,[2,Ms(e,4)]}})})}function ra(t){if(t<0||t>=256)throw new Error("Mask value must be in range [0, 255] but got "+t);if(!Number.isInteger(t))throw new Error("Mask value must be an integer but got "+t)}function tm(t){var e=t.shape[2],n=Mo(t,2),r=R(n,[-1]);return Dr(r,e)}function us(t,e){return Y(function(){return be(hr(t,se(e)),"int32")})}function NE(t,e){var n=e.shape,r=n[0],s=n[1],a=n[2];return Y(function(){var o=tm(e),i=st(fn(0,a,1,"int32"),1),u=be(ge(o,i),"int32"),l=R(u,[r,s]),c=K(l,se(1,"int32"));return ne(function(h,p){return U(h,p)}(c,t),se(1,"int32"))})}var nm=function(){function t(e,n){this.model=e,this.outputStride=n;var r=this.model.inputs[0].shape;N(r[1]===-1&&r[2]===-1,function(){return"Input shape ["+r[1]+", "+r[2]+"] must both be equal to or -1"})}return t.prototype.predict=function(e){var n=this;return Y(function(){var r=n.preprocessInput(be(e,"float32")),s=st(r,0),a=n.model.predict(s).map(function(i){return mt(i,[0])}),o=n.nameOutputResults(a);return{heatmapScores:Mt(o.heatmap),offsets:o.offsets,displacementFwd:o.displacementFwd,displacementBwd:o.displacementBwd,segmentation:o.segmentation,partHeatmaps:o.partHeatmaps,longOffsets:o.longOffsets,partOffsets:o.partOffsets}})},t.prototype.dispose=function(){this.model.dispose()},t}(),TE=function(t){function e(){return t!==null&&t.apply(this,arguments)||this}return Jd(e,t),e.prototype.preprocessInput=function(n){return Y(function(){return ne(ke(n,127.5),1)})},e.prototype.nameOutputResults=function(n){return{offsets:n[0],segmentation:n[1],partHeatmaps:n[2],longOffsets:n[3],heatmap:n[4],displacementFwd:n[5],displacementBwd:n[6],partOffsets:n[7]}},e}(nm),sa=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],At=sa.length,Ps=sa.reduce(function(t,e,n){return t[e]=n,t},{});[["leftHip","leftShoulder"],["leftElbow","leftShoulder"],["leftElbow","leftWrist"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["rightHip","rightShoulder"],["rightElbow","rightShoulder"],["rightElbow","rightWrist"],["rightHip","rightKnee"],["rightKnee","rightAnkle"],["leftShoulder","rightShoulder"],["leftHip","rightHip"]].map(function(t){var e=t[0],n=t[1];return[Ps[e],Ps[n]]});function _i(t,e,n){var r=t[0],s=t[1],a=e[0],o=e[1],i=n.top,u=n.bottom;return[o/(n.left+n.right+s),a/(i+u+r)]}function rm(t,e,n,r){return{y:r.get(t,e,n),x:r.get(t,e,n+At)}}function sm(t,e,n){var r=rm(t.heatmapY,t.heatmapX,t.id,n),s=r.y,a=r.x;return{x:t.heatmapX*e+a,y:t.heatmapY*e+s}}function bu(t,e,n){return t<e?e:t>n?n:t}function wu(t,e){return{x:t.x+e.x,y:t.y+e.y}}function EE(t,e,n){n===void 0&&(n=.3);for(var r=0,s=0,a=0;a<t.length;a++)e.keypoints[a].score>n&&(s+=1,r+=Math.pow(t[a].x-e.keypoints[a].position.x,2)+Math.pow(t[a].y-e.keypoints[a].position.y,2));return s===0?r=1/0:r/=s,r}function kE(t,e,n,r,s,a,o){for(var i=o[0],u=o[1],l=n(t),c=l.y*r+l.x,h=s[At*(2*c)+e],p=s[At*(2*c+1)+e],m=t.y+h,b=t.x+p,v=0;v<a;v++){m=Math.min(m,i-1);var S=n({x:b=Math.min(b,u-1),y:m}),x=S.y*r+S.x;m+=h=s[At*(2*x)+e],b+=p=s[At*(2*x+1)+e]}return{x:b,y:m}}function am(t,e,n,r,s,a,o,i,u,l){for(var c=s[0],h=s[1],p=a[0],m=a[1],b=i[0],v=i[1],S=[],x=function(M){return function(C,j,V,G){var X=j[0],ee=j[1],he=V[0],we=V[1],Oe=Math.round(((X+C.y+1)*we-1)/G);return{x:Math.round(((ee+C.x+1)*he-1)/G),y:Oe}}(M,[c,h],[p,m],u)},O=0;O<r;O++){var E=kE(t,O,x,o,e,l,[b,v]);S.push(E)}for(var $=-1,I=1/0,F=0;F<n.length;F++){var L=EE(S,n[F]);L<I&&($=F,I=L)}return $}function om(t,e){var n=t[0],r=t[1];return[Math.round((r-1)/e+1),Math.round((n-1)/e+1)]}function im(t,e,n,r,s,a,o,i,u,l,c){for(var h=o[0],p=o[1],m=t.shape,b=m[0],v=m[1],S=e.shape.slice(0,2),x=S[0],O=S[1],E=R(e,[x,O,2,At]),$=new Float32Array(c*At*3).fill(0),I=0;I<n.length;I++)for(var F=I*At*3,L=n[I],M=0;M<At;M++){var C=L.keypoints[M],j=F+3*M;$[j]=C.score,$[j+1]=C.position.y,$[j+2]=C.position.x}var V=_i([r,s],[h,p],i),G=V[0],X=V[1],ee=yt($,[c,At,3]),he=i.top,we=i.left,Oe={variableNames:["segmentation","longOffsets","poses"],outputShape:[b,v],userCode:`
    int convertToPositionInOutput(int pos, int pad, float scale, int stride) {
      return round(((float(pos + pad) + 1.0) * scale - 1.0) / float(stride));
    }

    float convertToPositionInOutputFloat(
        int pos, int pad, float scale, int stride) {
      return ((float(pos + pad) + 1.0) * scale - 1.0) / float(stride);
    }

    float dist(float x1, float y1, float x2, float y2) {
      return pow(x1 - x2, 2.0) + pow(y1 - y2, 2.0);
    }

    float sampleLongOffsets(float h, float w, int d, int k) {
      float fh = fract(h);
      float fw = fract(w);
      int clH = int(ceil(h));
      int clW = int(ceil(w));
      int flH = int(floor(h));
      int flW = int(floor(w));
      float o11 = getLongOffsets(flH, flW, d, k);
      float o12 = getLongOffsets(flH, clW, d, k);
      float o21 = getLongOffsets(clH, flW, d, k);
      float o22 = getLongOffsets(clH, clW, d, k);
      float o1 = mix(o11, o12, fw);
      float o2 = mix(o21, o22, fw);
      return mix(o1, o2, fh);
    }

    int findNearestPose(int h, int w) {
      float prob = getSegmentation(h, w);
      if (prob < 1.0) {
        return -1;
      }

      // Done(Tyler): convert from output space h/w to strided space.
      float stridedH = convertToPositionInOutputFloat(
        h, `+he+", "+X+", "+a+`);
      float stridedW = convertToPositionInOutputFloat(
        w, `+we+", "+G+", "+a+`);

      float minDist = 1000000.0;
      int iMin = -1;
      for (int i = 0; i < `+c+`; i++) {
        float curDistSum = 0.0;
        int numKpt = 0;
        for (int k = 0; k < `+At+`; k++) {
          float dy = sampleLongOffsets(stridedH, stridedW, 0, k);
          float dx = sampleLongOffsets(stridedH, stridedW, 1, k);

          float y = float(h) + dy;
          float x = float(w) + dx;

          for (int s = 0; s < `+u+`; s++) {
            int yRounded = round(min(y, float(`+(r-1)+`)));
            int xRounded = round(min(x, float(`+(s-1)+`)));

            float yStrided = convertToPositionInOutputFloat(
              yRounded, `+he+", "+X+", "+a+`);
            float xStrided = convertToPositionInOutputFloat(
              xRounded, `+we+", "+G+", "+a+`);

            float dy = sampleLongOffsets(yStrided, xStrided, 0, k);
            float dx = sampleLongOffsets(yStrided, xStrided, 1, k);

            y = y + dy;
            x = x + dx;
          }

          float poseScore = getPoses(i, k, 0);
          float poseY = getPoses(i, k, 1);
          float poseX = getPoses(i, k, 2);
          if (poseScore > `+l+`) {
            numKpt = numKpt + 1;
            curDistSum = curDistSum + dist(x, y, poseX, poseY);
          }
        }
        if (numKpt > 0 && curDistSum / float(numKpt) < minDist) {
          minDist = curDistSum / float(numKpt);
          iMin = i;
        }
      }
      return iMin;
    }

    void main() {
        ivec2 coords = getOutputCoords();
        int nearestPose = findNearestPose(coords[0], coords[1]);
        setOutput(float(nearestPose));
      }
  `};return uf().compileAndRun(Oe,[t,E,ee])}function um(){return of()==="webgl"}function _E(t,e,n,r,s,a,o,i,u,l,c,h){var p=o[0],m=o[1];return u===void 0&&(u=.2),l===void 0&&(l=8),c===void 0&&(c=.3),h===void 0&&(h=10),le(this,void 0,void 0,function(){var b,v,S,x,O;return ce(this,function(E){switch(E.label){case 0:return b=n.filter(function($){return $.score>=u}),um()?(S=Y(function(){var $=im(t,e,b,r,s,a,[p,m],i,l,c,h),I=Oo().makeTensorFromDataId($.dataId,$.shape,$.dtype);return b.map(function(F,L){return function(M,C){return Y(function(){return be(Kr(M,se(C)),"int32")})}(I,L)})}),[4,Promise.all(S.map(function($){return $.data()}))]):[3,2];case 1:return v=E.sent(),S.forEach(function($){return $.dispose()}),[3,5];case 2:return[4,t.data()];case 3:return x=E.sent(),[4,e.data()];case 4:O=E.sent(),v=function($,I,F,L,M,C,j,V,G,X){var ee=j[0],he=j[1];X===void 0&&(X=5);for(var we=F.map(function(Ft){return new Uint8Array(L*M).fill(0)}),Oe=V.top,Ve=V.left,je=_i([L,M],[ee,he],V),Ot=je[0],St=je[1],Jt=om([ee,he],C)[0],Dt=0;Dt<L;Dt+=1)for(var Nt=0;Nt<M;Nt+=1){var Tt=Dt*M+Nt;if($[Tt]===1){var Et=am({x:Nt,y:Dt},I,F,X,[Oe,Ve],[Ot,St],Jt,[L,M],C,G);Et>=0&&(we[Et][Tt]=1)}}return we}(x,O,b,r,s,a,[p,m],i,l),E.label=5;case 5:return[2,v.map(function($,I){return{data:$,pose:b[I],width:s,height:r}})]}})})}function xE(t,e,n,r,s,a,o,i,u,l,c,h,p){var m=i[0],b=i[1];return l===void 0&&(l=.2),c===void 0&&(c=8),h===void 0&&(h=.3),p===void 0&&(p=10),le(this,void 0,void 0,function(){var v,S,x,O,E,$;return ce(this,function(I){switch(I.label){case 0:return v=r.filter(function(F){return F.score>=l}),um()?(x=Y(function(){var F=im(t,e,v,s,a,o,[m,b],u,c,h,p),L=Oo().makeTensorFromDataId(F.dataId,F.shape,F.dtype);return v.map(function(M,C){return function(j,V,G){return Y(function(){return ne(U(be(Kr(j,se(G)),"int32"),K(V,1)),1)})}(L,n,C)})}),[4,Promise.all(x.map(function(F){return F.data()}))]):[3,2];case 1:return S=I.sent(),x.forEach(function(F){return F.dispose()}),[3,6];case 2:return[4,t.data()];case 3:return O=I.sent(),[4,e.data()];case 4:return E=I.sent(),[4,n.data()];case 5:$=I.sent(),S=function(F,L,M,C,j,V,G,X,ee,he,we){var Oe=X[0],Ve=X[1];we===void 0&&(we=5);for(var je=C.map(function(kt){return new Int32Array(j*V).fill(-1)}),Ot=ee.top,St=ee.left,Jt=_i([j,V],[Oe,Ve],ee),Dt=Jt[0],Nt=Jt[1],Tt=om([Oe,Ve],G)[0],Et=0;Et<j;Et+=1)for(var Ft=0;Ft<V;Ft+=1){var Qt=Et*V+Ft;if(F[Qt]===1){var tt=am({x:Ft,y:Et},L,C,we,[Ot,St],[Dt,Nt],Tt,[j,V],G,he);tt>=0&&(je[tt][Qt]=M[Qt])}}return je}(O,E,$,v,s,a,o,[m,b],u,c),I.label=6;case 6:return[2,S.map(function(F,L){return{pose:v[L],data:F,height:s,width:a}})]}})})}function Ea(t){return Math.floor(t/2)}var $E=function(){function t(e,n){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=n}return t.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},t.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},t.prototype.empty=function(){return this.numberOfElements===-1},t.prototype.size=function(){return this.numberOfElements+1},t.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},t.prototype.max=function(){return this.priorityQueue[0]},t.prototype.swim=function(e){for(;e>0&&this.less(Ea(e),e);)this.exchange(e,Ea(e)),e=Ea(e)},t.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var n=2*e;if(n<this.numberOfElements&&this.less(n,n+1)&&n++,!this.less(e,n))break;this.exchange(e,n),e=n}},t.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},t.prototype.less=function(e,n){return this.getValueAt(e)<this.getValueAt(n)},t.prototype.exchange=function(e,n){var r=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[n],this.priorityQueue[n]=r},t}();function AE(t,e,n,r,s,a){for(var o=a.shape,i=o[0],u=o[1],l=!0,c=Math.max(n-s,0),h=Math.min(n+s+1,i),p=c;p<h;++p){for(var m=Math.max(r-s,0),b=Math.min(r+s+1,u),v=m;v<b;++v)if(a.get(p,v,t)>e){l=!1;break}if(!l)break}return l}var lm=[["nose","leftEye"],["leftEye","leftEar"],["nose","rightEye"],["rightEye","rightEar"],["nose","leftShoulder"],["leftShoulder","leftElbow"],["leftElbow","leftWrist"],["leftShoulder","leftHip"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["nose","rightShoulder"],["rightShoulder","rightElbow"],["rightElbow","rightWrist"],["rightShoulder","rightHip"],["rightHip","rightKnee"],["rightKnee","rightAnkle"]].map(function(t){var e=t[0],n=t[1];return[Ps[e],Ps[n]]}),ka=lm.map(function(t){return t[1]}),vu=lm.map(function(t){return t[0]});function _a(t,e,n,r){return{y:bu(Math.round(t.y/e),0,n-1),x:bu(Math.round(t.x/e),0,r-1)}}function Su(t,e,n,r,s,a,o,i){i===void 0&&(i=2);for(var u=r.shape,l=u[0],c=u[1],h=function(O,E,$){var I=$.shape[2]/2;return{y:$.get(E.y,E.x,O),x:$.get(E.y,E.x,I+O)}}(t,_a(e.position,a,l,c),o),p=wu(e.position,h),m=0;m<i;m++){var b=_a(p,a,l,c),v=rm(b.y,b.x,n,s);p=wu({x:b.x*a,y:b.y*a},{x:v.x,y:v.y})}var S=_a(p,a,l,c),x=r.get(S.y,S.x,n);return{position:p,part:sa[n],score:x}}function IE(t,e,n,r,s,a){var o=e.shape[2],i=ka.length,u=new Array(o),l=t.part,c=t.score,h=sm(l,r,n);u[l.id]={score:c,part:sa[l.id],position:h};for(var p=i-1;p>=0;--p){var m=ka[p],b=vu[p];u[m]&&!u[b]&&(u[b]=Su(p,u[m],b,e,n,r,a))}for(p=0;p<i;++p)m=vu[p],b=ka[p],u[m]&&!u[b]&&(u[b]=Su(p,u[m],b,e,n,r,s));return u}function cm(t,e,n,r){var s=n.x,a=n.y;return t.some(function(o){var i,u,l,c,h,p,m=o.keypoints[r].position;return i=a,u=s,l=m.y,c=m.x,(h=l-i)*h+(p=c-u)*p<=e})}function OE(t,e,n){var r=n.reduce(function(s,a,o){var i=a.position,u=a.score;return cm(t,e,i,o)||(s+=u),s},0);return r/n.length}function ls(t,e,n,r,s,a,o,i){o===void 0&&(o=.5),i===void 0&&(i=20);for(var u=[],l=function(b,v,S){for(var x=S.shape,O=x[0],E=x[1],$=x[2],I=new $E(O*E*$,function(j){return j.score}),F=0;F<O;++F)for(var L=0;L<E;++L)for(var M=0;M<$;++M){var C=S.get(F,L,M);C<b||AE(M,C,F,L,v,S)&&I.enqueue({score:C,part:{heatmapY:F,heatmapX:L,id:M}})}return I}(o,1,t),c=i*i;u.length<a&&!l.empty();){var h=l.dequeue();if(!cm(u,c,sm(h.part,s,e),h.part.id)){var p=IE(h,t,e,s,n,r),m=OE(u,c,p);u.push({keypoints:p,score:m})}}return u}var vr,DE=[-123.15,-115.9,-103.06],FE=function(t){function e(){return t!==null&&t.apply(this,arguments)||this}return Jd(e,t),e.prototype.preprocessInput=function(n){return K(n,DE)},e.prototype.nameOutputResults=function(n){var r=n[0],s=n[1],a=n[2],o=n[3],i=n[4],u=n[5];return{offsets:i,segmentation:n[6],partHeatmaps:u,longOffsets:o,heatmap:a,displacementFwd:s,displacementBwd:r,partOffsets:n[7]}},e}(nm),Nu="https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/resnet50/",Tu="https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/";function Tr(t){if(typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&t instanceof OffscreenCanvas||typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)return function(e){if("offsetHeight"in e&&e.offsetHeight!==0&&"offsetWidth"in e&&e.offsetWidth!==0)return[e.offsetHeight,e.offsetWidth];if(e.height!=null&&e.width!=null)return[e.height,e.width];throw new Error("HTMLImageElement must have height and width attributes set.")}(t);if(typeof ImageData<"u"&&t instanceof ImageData)return[t.height,t.width];if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)return function(e){return e.hasAttribute("height")&&e.hasAttribute("width")?[e.height,e.width]:[e.videoHeight,e.videoWidth]}(t);if(t instanceof ye)return[t.shape[0],t.shape[1]];throw new Error("error: Unknown input type: "+t+".")}function Eu(t,e){return function(n,r){return(n-1)%r==0}(t,e)?t:Math.floor(t/e)*e+1}var Er={low:"low",medium:"medium",high:"high",full:"full"},PE=((vr={})[Er.low]=.25,vr[Er.medium]=.5,vr[Er.high]=.75,vr[Er.full]=1,vr);function cs(t,e,n){var r=n[0],s=n[1],a=function(o){if(typeof o=="string"){var i=PE[o];return N(typeof i=="number",function(){return"string value of inputResolution must be one of "+Object.values(Er).join(",")+" but was "+o+"."}),i}return N(typeof o=="number"&&o<=2&&o>=.1,function(){return"inputResolution must be a string or number between 0.1 and 2, but was "+o}),o}(t);return[Eu(r*a,e),Eu(s*a,e)]}function Kn(t,e,n,r,s){var a=e[0],o=e[1],i=n[0],u=n[1],l=r[0],c=l[0],h=l[1],p=r[1],m=p[0],b=p[1];return s===void 0&&(s=!1),Y(function(){var v=Rn.resizeBilinear(t,[i,u],!0);return s&&(v=Mt(v)),function(S,x,O){var E=x[0],$=x[1],I=O[0],F=I[0],L=I[1],M=O[1],C=M[0],j=M[1];return Y(function(){var V=st(S);return mt(Rn.cropAndResize(V,[[F/(E+F+L-1),C/($+C+j-1),(F+E-1)/(E+F+L-1),(C+$-1)/($+C+j-1)]],[0],[E,$]),[0])})}(v,[a,o],[[c,h],[m,b]])})}function hs(t,e){var n=e[0],r=e[1],s=Tr(t),a=s[0],o=s[1],i=r/n,u=[0,0,0,0],l=u[0],c=u[1],h=u[2],p=u[3];o/a<i?(l=0,c=0,h=Math.round(.5*(i*a-o)),p=Math.round(.5*(i*a-o))):(l=Math.round(.5*(1/i*o-a)),c=Math.round(.5*(1/i*o-a)),h=0,p=0);var m=Y(function(){var b=function(v){return v instanceof ye?v:Ms(v)}(t);return b=ii(b,[[l,c],[h,p],[0,0]]),Rn.resizeBilinear(b,[n,r])});return{resized:m,padding:{top:l,left:h,right:p,bottom:c}}}function fs(t){return le(this,void 0,void 0,function(){return ce(this,function(e){return[2,Promise.all(t.map(function(n){return n.buffer()}))]})})}function ps(t,e,n,r,s){var a=e[0],o=e[1],i=n[0],u=n[1],l=function(c,h,p,m,b){return m===void 0&&(m=0),b===void 0&&(b=0),p===1&&h===1&&m===0&&b===0?c:c.map(function(v){return function(S,x,O,E,$){return E===void 0&&(E=0),$===void 0&&($=0),{score:S.score,keypoints:S.keypoints.map(function(I){var F=I.score,L=I.part,M=I.position;return{score:F,part:L,position:{x:M.x*O+$,y:M.y*x+E}}})}}(v,h,p,m,b)})}(t,(a+r.top+r.bottom)/i,(o+r.left+r.right)/u,-r.top,-r.left);return s?function(c,h){return h<=0?c:c.map(function(p){return function(m,b){return{score:m.score,keypoints:m.keypoints.map(function(v){var S=v.score,x=v.part,O=v.position;return{score:S,part:x,position:{x:b-1-O.x,y:O.y}}})}}(p,h)})}(l,o):l}var ku={architecture:"MobileNetV1",outputStride:16,quantBytes:4,multiplier:.75},_u=["MobileNetV1","ResNet50"],xu={MobileNetV1:[8,16,32],ResNet50:[32,16]},$u={MobileNetV1:[.5,.75,1],ResNet50:[1]},Au=[1,2,4],ds={flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7,maxDetections:10,scoreThreshold:.4,nmsRadius:20},ms={flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7,maxDetections:10,scoreThreshold:.4,nmsRadius:20,minKeypointScore:.3,refineSteps:10};function Iu(t){var e=t.segmentationThreshold,n=t.maxDetections,r=t.scoreThreshold,s=t.nmsRadius;if(e<0||e>1)throw new Error("segmentationThreshold "+e+". Should be in range [0.0, 1.0]");if(n<=0)throw new Error("Invalid maxDetections "+n+". Should be > 0");if(r<0||r>1)throw new Error("Invalid scoreThreshold "+r+". Should be in range [0.0, 1.0]");if(s<=0)throw new Error("Invalid nmsRadius "+s+".")}function Ou(t){var e=t.segmentationThreshold,n=t.maxDetections,r=t.scoreThreshold,s=t.nmsRadius,a=t.minKeypointScore,o=t.refineSteps;if(e<0||e>1)throw new Error("segmentationThreshold "+e+". Should be in range [0.0, 1.0]");if(n<=0)throw new Error("Invalid maxDetections "+n+". Should be > 0");if(r<0||r>1)throw new Error("Invalid scoreThreshold "+r+". Should be in range [0.0, 1.0]");if(s<=0)throw new Error("Invalid nmsRadius "+s+".");if(a<0||a>1)throw new Error("Invalid minKeypointScore "+a+".Should be in range [0.0, 1.0]");if(o<=0||o>20)throw new Error("Invalid refineSteps "+o+".Should be in range [1, 20]")}var hm=function(){function t(e){this.baseModel=e}return t.prototype.predictForPersonSegmentation=function(e){var n=this.baseModel.predict(e);return{segmentLogits:n.segmentation,heatmapScores:n.heatmapScores,offsets:n.offsets,displacementFwd:n.displacementFwd,displacementBwd:n.displacementBwd}},t.prototype.predictForPersonSegmentationAndPart=function(e){var n=this.baseModel.predict(e);return{segmentLogits:n.segmentation,partHeatmapLogits:n.partHeatmaps,heatmapScores:n.heatmapScores,offsets:n.offsets,displacementFwd:n.displacementFwd,displacementBwd:n.displacementBwd}},t.prototype.predictForMultiPersonInstanceSegmentationAndPart=function(e){var n=this.baseModel.predict(e);return{segmentLogits:n.segmentation,longOffsets:n.longOffsets,heatmapScores:n.heatmapScores,offsets:n.offsets,displacementFwd:n.displacementFwd,displacementBwd:n.displacementBwd,partHeatmaps:n.partHeatmaps}},t.prototype.segmentPersonActivation=function(e,n,r){var s=this;r===void 0&&(r=.5);var a=Tr(e),o=a[0],i=a[1],u=cs(n,this.baseModel.outputStride,[o,i]),l=hs(e,u),c=l.resized,h=l.padding,p=Y(function(){var O=s.predictForPersonSegmentation(c),E=O.segmentLogits,$=O.heatmapScores,I=O.offsets,F=O.displacementFwd,L=O.displacementBwd,M=c.shape,C=M[0],j=M[1],V=Kn(E,[o,i],[C,j],[[h.top,h.bottom],[h.left,h.right]],!0);return{segmentation:us(mt(V),r),heatmapScores:$,offsets:I,displacementFwd:F,displacementBwd:L}}),m=p.segmentation,b=p.heatmapScores,v=p.offsets,S=p.displacementFwd,x=p.displacementBwd;return c.dispose(),{segmentation:m,heatmapScores:b,offsets:v,displacementFwd:S,displacementBwd:x,padding:h,internalResolutionHeightAndWidth:u}},t.prototype.segmentPerson=function(e,n){return n===void 0&&(n=ds),le(this,void 0,void 0,function(){var r,s,a,o,i,u,l,c,h,p,m,b,v,S,x,O,E,$;return ce(this,function(I){switch(I.label){case 0:return Iu(n=Ge(Ge({},ds),n)),r=this.segmentPersonActivation(e,n.internalResolution,n.segmentationThreshold),s=r.segmentation,a=r.heatmapScores,o=r.offsets,i=r.displacementFwd,u=r.displacementBwd,l=r.padding,c=r.internalResolutionHeightAndWidth,h=s.shape,p=h[0],m=h[1],[4,s.data()];case 1:return b=I.sent(),s.dispose(),[4,fs([a,o,i,u])];case 2:return v=I.sent(),S=v[0],x=v[1],O=v[2],E=v[3],$=ps($=ls(S,x,O,E,this.baseModel.outputStride,n.maxDetections,n.scoreThreshold,n.nmsRadius),[p,m],c,l,!1),a.dispose(),o.dispose(),i.dispose(),u.dispose(),[2,{height:p,width:m,data:b,allPoses:$}]}})})},t.prototype.segmentMultiPerson=function(e,n){return n===void 0&&(n=ms),le(this,void 0,void 0,function(){var r,s,a,o,i,u,l,c,h,p,m,b,v,S,x,O,E,$,I,F,L,M=this;return ce(this,function(C){switch(C.label){case 0:return Ou(n=Ge(Ge({},ms),n)),r=Tr(e),s=r[0],a=r[1],o=cs(n.internalResolution,this.baseModel.outputStride,[s,a]),i=hs(e,o),u=i.resized,l=i.padding,c=Y(function(){var j,V=M.predictForMultiPersonInstanceSegmentationAndPart(u),G=V.segmentLogits,X=V.longOffsets,ee=V.heatmapScores,he=V.offsets,we=V.displacementFwd,Oe=V.displacementBwd,Ve=Kn(G,[s,a],o,[[l.top,l.bottom],[l.left,l.right]],!0);return j=X,{segmentation:us(mt(Ve),n.segmentationThreshold),longOffsets:j,heatmapScoresRaw:ee,offsetsRaw:he,displacementFwdRaw:we,displacementBwdRaw:Oe}}),h=c.segmentation,p=c.longOffsets,m=c.heatmapScoresRaw,b=c.offsetsRaw,v=c.displacementFwdRaw,S=c.displacementBwdRaw,[4,fs([m,b,v,S])];case 1:return x=C.sent(),O=x[0],E=x[1],$=x[2],I=x[3],F=ps(F=ls(O,E,$,I,this.baseModel.outputStride,n.maxDetections,n.scoreThreshold,n.nmsRadius),[s,a],o,l,!1),[4,_E(h,p,F,s,a,this.baseModel.outputStride,o,l,n.scoreThreshold,n.refineSteps,n.minKeypointScore,n.maxDetections)];case 2:return L=C.sent(),u.dispose(),h.dispose(),p.dispose(),m.dispose(),b.dispose(),v.dispose(),S.dispose(),[2,L]}})})},t.prototype.segmentPersonPartsActivation=function(e,n,r){var s=this;r===void 0&&(r=.5);var a=Tr(e),o=a[0],i=a[1],u=cs(n,this.baseModel.outputStride,[o,i]),l=hs(e,u),c=l.resized,h=l.padding,p=Y(function(){var O=s.predictForPersonSegmentationAndPart(c),E=O.segmentLogits,$=O.partHeatmapLogits,I=O.heatmapScores,F=O.offsets,L=O.displacementFwd,M=O.displacementBwd,C=c.shape,j=C[0],V=C[1],G=Kn(E,[o,i],[j,V],[[h.top,h.bottom],[h.left,h.right]],!0),X=Kn($,[o,i],[j,V],[[h.top,h.bottom],[h.left,h.right]],!0);return{partSegmentation:NE(us(mt(G),r),X),heatmapScores:I,offsets:F,displacementFwd:L,displacementBwd:M}}),m=p.partSegmentation,b=p.heatmapScores,v=p.offsets,S=p.displacementFwd,x=p.displacementBwd;return c.dispose(),{partSegmentation:m,heatmapScores:b,offsets:v,displacementFwd:S,displacementBwd:x,padding:h,internalResolutionHeightAndWidth:u}},t.prototype.segmentPersonParts=function(e,n){return n===void 0&&(n=ds),le(this,void 0,void 0,function(){var r,s,a,o,i,u,l,c,h,p,m,b,v,S,x,O,E,$;return ce(this,function(I){switch(I.label){case 0:return Iu(n=Ge(Ge({},ds),n)),r=this.segmentPersonPartsActivation(e,n.internalResolution,n.segmentationThreshold),s=r.partSegmentation,a=r.heatmapScores,o=r.offsets,i=r.displacementFwd,u=r.displacementBwd,l=r.padding,c=r.internalResolutionHeightAndWidth,h=s.shape,p=h[0],m=h[1],[4,s.data()];case 1:return b=I.sent(),s.dispose(),[4,fs([a,o,i,u])];case 2:return v=I.sent(),S=v[0],x=v[1],O=v[2],E=v[3],$=ps($=ls(S,x,O,E,this.baseModel.outputStride,n.maxDetections,n.scoreThreshold,n.nmsRadius),[p,m],c,l,!1),a.dispose(),o.dispose(),i.dispose(),u.dispose(),[2,{height:p,width:m,data:b,allPoses:$}]}})})},t.prototype.segmentMultiPersonParts=function(e,n){return n===void 0&&(n=ms),le(this,void 0,void 0,function(){var r,s,a,o,i,u,l,c,h,p,m,b,v,S,x,O,E,$,I,F,L,M,C=this;return ce(this,function(j){switch(j.label){case 0:return Ou(n=Ge(Ge({},ms),n)),r=Tr(e),s=r[0],a=r[1],o=cs(n.internalResolution,this.baseModel.outputStride,[s,a]),i=hs(e,o),u=i.resized,l=i.padding,c=Y(function(){var V=C.predictForMultiPersonInstanceSegmentationAndPart(u),G=V.segmentLogits,X=V.longOffsets,ee=V.heatmapScores,he=V.offsets,we=V.displacementFwd,Oe=V.displacementBwd,Ve=V.partHeatmaps,je=Kn(G,[s,a],o,[[l.top,l.bottom],[l.left,l.right]],!0),Ot=Kn(Ve,[s,a],o,[[l.top,l.bottom],[l.left,l.right]],!0),St=X,Jt=us(mt(je),n.segmentationThreshold),Dt=function(Nt){var Tt=Nt.shape,Et=Tt[0],Ft=Tt[1],Qt=Tt[2];return Y(function(){var tt=tm(Nt),kt=st(fn(0,Qt,1,"int32"),1),ts=be(ge(tt,kt),"int32");return R(ts,[Et,Ft])})}(Ot);return{segmentation:Jt,longOffsets:St,heatmapScoresRaw:ee,offsetsRaw:he,displacementFwdRaw:we,displacementBwdRaw:Oe,partSegmentation:Dt}}),h=c.segmentation,p=c.longOffsets,m=c.heatmapScoresRaw,b=c.offsetsRaw,v=c.displacementFwdRaw,S=c.displacementBwdRaw,x=c.partSegmentation,[4,fs([m,b,v,S])];case 1:return O=j.sent(),E=O[0],$=O[1],I=O[2],F=O[3],L=ps(L=ls(E,$,I,F,this.baseModel.outputStride,n.maxDetections,n.scoreThreshold,n.nmsRadius),[s,a],o,l,!1),[4,xE(h,p,x,L,s,a,this.baseModel.outputStride,o,l,n.scoreThreshold,n.refineSteps,n.minKeypointScore,n.maxDetections)];case 2:return M=j.sent(),u.dispose(),h.dispose(),p.dispose(),m.dispose(),b.dispose(),v.dispose(),S.dispose(),x.dispose(),[2,M]}})})},t.prototype.dispose=function(){this.baseModel.dispose()},t}();function RE(t){return le(this,void 0,void 0,function(){var e,n,r,s,a,o;return ce(this,function(i){switch(i.label){case 0:if(e=t.outputStride,n=t.quantBytes,r=t.multiplier,Gd==null)throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this
        model.`);return s=function(u,l,c){var h={1:"100",.75:"075",.5:"050"},p="model-stride"+u+".json";return c===4?Tu+"float/"+h[l]+"/"+p:Tu+"quant"+c+"/"+h[l]+"/"+p}(e,r,n),[4,Ei(t.modelUrl||s)];case 1:return a=i.sent(),o=new TE(a,e),[2,new hm(o)]}})})}function CE(t){return le(this,void 0,void 0,function(){var e,n,r,s,a;return ce(this,function(o){switch(o.label){case 0:if(e=t.outputStride,n=t.quantBytes,Gd==null)throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this
        model.`);return r=function(i,u){var l="model-stride"+i+".json";return u===4?Nu+"float/"+l:Nu+"quant"+u+"/"+l}(e,n),[4,Ei(t.modelUrl||r)];case 1:return s=o.sent(),a=new FE(s,e),[2,new hm(a)]}})})}function BE(t){return t===void 0&&(t=ku),le(this,void 0,void 0,function(){return ce(this,function(e){return(t=function(n){if((n=n||ku).architecture==null&&(n.architecture="MobileNetV1"),_u.indexOf(n.architecture)<0)throw new Error("Invalid architecture "+n.architecture+". Should be one of "+_u);if(n.outputStride==null&&(n.outputStride=16),xu[n.architecture].indexOf(n.outputStride)<0)throw new Error("Invalid outputStride "+n.outputStride+". Should be one of "+xu[n.architecture]+" for architecture "+n.architecture+".");if(n.multiplier==null&&(n.multiplier=1),$u[n.architecture].indexOf(n.multiplier)<0)throw new Error("Invalid multiplier "+n.multiplier+". Should be one of "+$u[n.architecture]+" for architecture "+n.architecture+".");if(n.quantBytes==null&&(n.quantBytes=4),Au.indexOf(n.quantBytes)<0)throw new Error("Invalid quantBytes "+n.quantBytes+". Should be one of "+Au+" for architecture "+n.architecture+".");return n}(t)).architecture==="ResNet50"?[2,CE(t)]:t.architecture==="MobileNetV1"?[2,RE(t)]:[2,null]})})}var co=["left_face","right_face","left_upper_arm_front","left_upper_arm_back","right_upper_arm_front","right_upper_arm_back","left_lower_arm_front","left_lower_arm_back","right_lower_arm_front","right_lower_arm_back","left_hand","right_hand","torso_front","torso_back","left_upper_leg_front","left_upper_leg_back","right_upper_leg_front","right_upper_leg_back","left_lower_leg_front","left_lower_leg_back","right_lower_leg_front","right_lower_leg_back","left_feet","right_feet"],Du=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return le(this,void 0,void 0,function(){return ce(this,function(e){return[2,ki(this.mask)]})})},t.prototype.toImageData=function(){return le(this,void 0,void 0,function(){return ce(this,function(e){return[2,this.mask]})})},t.prototype.toTensor=function(){return le(this,void 0,void 0,function(){return ce(this,function(e){return[2,em(this.mask)]})})},t.prototype.getUnderlyingType=function(){return"imagedata"},t}();function LE(t){if(ra(t),t!==255)throw new Error("Foreground id must be 255 but got "+t);return"person"}function ME(t){if(ra(t),t>=co.length)throw new Error("Invalid body part value "+t);return co[t]}var zE=function(){function t(e){this.bodyPixModel=e}return t.prototype.segmentPeople=function(e,n){return le(this,void 0,void 0,function(){var r,s,a,o;return ce(this,function(i){switch(i.label){case 0:return e instanceof ImageBitmap&&((r=document.createElement("canvas")).getContext("2d").drawImage(e,0,0),e=r),n.segmentBodyParts?n.multiSegmentation?[4,this.bodyPixModel.segmentMultiPersonParts(e,n)]:[3,2]:[3,5];case 1:return a=i.sent(),[3,4];case 2:return[4,this.bodyPixModel.segmentPersonParts(e,n)];case 3:a=[i.sent()],i.label=4;case 4:return s=a.map(function(u){var l=u.data,c=u.width,h=u.height,p=new Uint8ClampedArray(c*h*4).fill(0);return l.forEach(function(m,b){m===-1?(p[4*b]=co.length,p[4*b+3]=0):(p[4*b]=m,p[4*b+3]=255)}),{maskValueToLabel:ME,mask:new Du(new ImageData(p,c,h))}}),[3,10];case 5:return n.multiSegmentation?[4,this.bodyPixModel.segmentMultiPerson(e,n)]:[3,7];case 6:return o=i.sent(),[3,9];case 7:return[4,this.bodyPixModel.segmentPerson(e,n)];case 8:o=[i.sent()],i.label=9;case 9:s=o.map(function(u){var l=u.data,c=u.width,h=u.height,p=new Uint8ClampedArray(c*h*4).fill(0);return l.forEach(function(m,b){m===0?(p[4*b]=0,p[4*b+3]=0):(p[4*b]=255,p[4*b+3]=255)}),{maskValueToLabel:LE,mask:new Du(new ImageData(p,c,h))}}),i.label=10;case 10:return[2,s]}})})},t.prototype.dispose=function(){this.bodyPixModel.dispose()},t.prototype.reset=function(){},t}();function VE(t){return le(this,void 0,void 0,function(){return ce(this,function(e){return[2,BE(t).then(function(n){return new zE(n)})]})})}var Fu={runtime:"mediapipe",modelType:"general"},jE=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return le(this,void 0,void 0,function(){return ce(this,function(e){return[2,this.mask]})})},t.prototype.toImageData=function(){return le(this,void 0,void 0,function(){return ce(this,function(e){return[2,Qd(this.mask)]})})},t.prototype.toTensor=function(){return le(this,void 0,void 0,function(){return ce(this,function(e){return[2,em(this.mask)]})})},t.prototype.getUnderlyingType=function(){return"canvasimagesource"},t}();function UE(t){return ra(t),"person"}var qE=function(){function t(e){var n,r=this;this.selfieMode=!1,this.selfieSegmentationSolution=new vE({locateFile:function(s,a){return e.solutionPath?e.solutionPath.replace(/\/+$/,"")+"/"+s:a+"/"+s}}),e.modelType==="landscape"?n=1:n=0,this.selfieSegmentationSolution.setOptions({modelSelection:n,selfieMode:this.selfieMode}),this.selfieSegmentationSolution.onResults(function(s){r.segmentation=[{maskValueToLabel:UE,mask:new jE(s.segmentationMask)}]})}return t.prototype.segmentPeople=function(e,n){return le(this,void 0,void 0,function(){var r,s;return ce(this,function(a){switch(a.label){case 0:return n&&n.flipHorizontal&&n.flipHorizontal!==this.selfieMode&&(this.selfieMode=n.flipHorizontal,this.selfieSegmentationSolution.setOptions({selfieMode:this.selfieMode})),e instanceof ye?(s=ImageData.bind,[4,qr(e)]):[3,2];case 1:return r=new(s.apply(ImageData,[void 0,a.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:r=e,a.label=3;case 3:return e=r,[4,this.selfieSegmentationSolution.send({image:e})];case 4:return a.sent(),[2,this.segmentation]}})})},t.prototype.dispose=function(){this.selfieSegmentationSolution.close()},t.prototype.reset=function(){this.selfieSegmentationSolution.reset(),this.segmentation=null,this.selfieMode=!1},t.prototype.initialize=function(){return this.selfieSegmentationSolution.initialize()},t}();function WE(t){return le(this,void 0,void 0,function(){var e,n;return ce(this,function(r){switch(r.label){case 0:return e=function(s){if(s==null)return Ge({},Fu);var a=Ge({},s);return a.runtime="mediapipe",a.modelType==null&&(a.modelType=Fu.modelType),a}(t),[4,(n=new qE(e)).initialize()];case 1:return r.sent(),[2,n]}})})}function HE(t,e,n,r){var s=t.width,a=t.height,o=r?-1:1,i=Math.cos(t.rotation),u=Math.sin(t.rotation),l=t.xCenter,c=t.yCenter,h=1/e,p=1/n,m=new Array(16);return m[0]=s*i*o*h,m[1]=-a*u*h,m[2]=0,m[3]=(-.5*s*i*o+.5*a*u+l)*h,m[4]=s*u*o*p,m[5]=a*i*p,m[6]=0,m[7]=(-.5*a*i-.5*s*u*o+c)*p,m[8]=0,m[9]=0,m[10]=s*h,m[11]=0,m[12]=0,m[13]=0,m[14]=0,m[15]=1,function(b){if(b.length!==16)throw new Error("Array length must be 16 but got "+b.length);return[[b[0],b[1],b[2],b[3]],[b[4],b[5],b[6],b[7]],[b[8],b[9],b[10],b[11]],[b[12],b[13],b[14],b[15]]]}(m)}function fm(t){return t instanceof ye?{height:t.shape[0],width:t.shape[1]}:{height:t.height,width:t.width}}function xa(t,e){N(t.width!==0,function(){return e+" width cannot be 0."}),N(t.height!==0,function(){return e+" height cannot be 0."})}function GE(t,e){var n=function(r,s,a,o){var i=s-r,u=o-a;if(i===0)throw new Error("Original min and max are both "+r+", range cannot be 0.");var l=u/i;return{scale:l,offset:a-r*l}}(0,255,e[0],e[1]);return Y(function(){return K(U(t,n.scale),n.offset)})}function KE(t,e,n){var r=e.outputTensorSize,s=e.keepAspectRatio,a=e.borderMode,o=e.outputTensorFloatRange,i=fm(t),u=function(p,m){return m?{xCenter:m.xCenter*p.width,yCenter:m.yCenter*p.height,width:m.width*p.width,height:m.height*p.height,rotation:m.rotation}:{xCenter:.5*p.width,yCenter:.5*p.height,width:p.width,height:p.height,rotation:0}}(i,n),l=function(p,m,b){if(b===void 0&&(b=!1),!b)return{top:0,left:0,right:0,bottom:0};var v=m.height,S=m.width;xa(m,"targetSize"),xa(p,"roi");var x,O,E=v/S,$=p.height/p.width,I=0,F=0;return E>$?(x=p.width,O=p.width*E,F=(1-$/E)/2):(x=p.height/E,O=p.height,I=(1-E/$)/2),p.width=x,p.height=O,{top:F,left:I,right:I,bottom:F}}(u,r,s),c=HE(u,i.width,i.height,!1),h=Y(function(){var p,m=(p=t)instanceof ye?p:Ms(p),b=xn(function(x,O,E){return xa(E,"inputResolution"),[1/E.width*x[0][0]*O.width,1/E.height*x[0][1]*O.width,x[0][3]*O.width,1/E.width*x[1][0]*O.height,1/E.height*x[1][1]*O.height,x[1][3]*O.height,0,0]}(c,i,r),[1,8]),v=a==="zero"?"constant":"nearest",S=Rn.transform(st(be(m,"float32")),b,"bilinear",v,0,[r.height,r.width]);return o!=null?GE(S,o):S});return{imageTensor:h,padding:l,transformationMatrix:c}}function XE(t,e,n){return Y(function(){var r=mt(t,[0]),s=r.shape[2];if(s===1){var a=r;switch(e.activation){case"none":break;case"sigmoid":a=Mt(a);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported ("+e.activation+")")}var o=n?Rn.resizeBilinear(a,[n.height,n.width]):a;return mt(o,[2])}throw new Error("Unsupported number of tensor channels "+s)})}var Pu={runtime:"tfjs",modelType:"general",modelUrl:"https://tfhub.dev/mediapipe/tfjs-model/selfie_segmentation/general/1"},Ru={flipHorizontal:!1},YE={outputTensorSize:{width:256,height:256},keepAspectRatio:!1,borderMode:"zero",outputTensorFloatRange:[0,1]},ZE={outputTensorSize:{width:256,height:144},keepAspectRatio:!1,borderMode:"zero",outputTensorFloatRange:[0,1]},JE={activation:"none"},QE=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return le(this,void 0,void 0,function(){return ce(this,function(e){return[2,ki(this.mask)]})})},t.prototype.toImageData=function(){return le(this,void 0,void 0,function(){return ce(this,function(e){return[2,Qd(this.mask)]})})},t.prototype.toTensor=function(){return le(this,void 0,void 0,function(){return ce(this,function(e){return[2,this.mask]})})},t.prototype.getUnderlyingType=function(){return"tensor"},t}();function ek(t){return ra(t),"person"}var Lr,tk=function(){function t(e,n){this.modelType=e,this.model=n}return t.prototype.segmentPeople=function(e,n){return le(this,void 0,void 0,function(){var r,s=this;return ce(this,function(a){return n=function(o){if(o==null)return Ge({},Ru);var i=Ge({},o);return i.flipHorizontal==null&&(i.flipHorizontal=Ru.flipHorizontal),i}(n),e==null?(this.reset(),[2,[]]):(r=Y(function(){var o=KE(e,s.modelType==="general"?YE:ZE).imageTensor,i=Ne(s.model.predict(o),[0,0,0,1],-1),u=fm(e),l=XE(i,JE,u),c=st(l,2),h=Mn(c,[[0,0],[0,0],[0,1]]);return ai(h,[[0,0],[0,0],[0,2]],"symmetric")}),[2,[{maskValueToLabel:ek,mask:new QE(r)}]])})})},t.prototype.dispose=function(){this.model.dispose()},t.prototype.reset=function(){},t}();function nk(t){return le(this,void 0,void 0,function(){var e,n,r;return ce(this,function(s){switch(s.label){case 0:return e=function(a){if(a==null)return Ge({},Pu);var o=Ge({},a);if(o.runtime="tfjs",o.modelType==null&&(o.modelType=Pu.modelType),o.modelType!=="general"&&o.modelType!=="landscape")throw new Error("Model type must be one of general or landscape, but got "+o.modelType);return o.modelUrl==null&&(o.modelType==="general"?o.modelUrl="https://tfhub.dev/mediapipe/tfjs-model/selfie_segmentation/general/1":o.modelUrl="https://tfhub.dev/mediapipe/tfjs-model/selfie_segmentation/landscape/1"),o}(t),n=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,Ei(e.modelUrl,{fromTFHub:n})];case 1:return r=s.sent(),[2,new tk(e.modelType,r)]}})})}function rk(t,e){return le(this,void 0,void 0,function(){var n,r;return ce(this,function(s){switch(t){case Lr.MediaPipeSelfieSegmentation:if(n=void 0,(r=e)!=null){if(r.runtime==="tfjs")return[2,nk(r)];if(r.runtime==="mediapipe")return[2,WE(r)];n=r.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got "+n);case Lr.BodyPix:return[2,VE(r=e)];default:throw new Error(t+" is not a supported model name.")}})})}(function(t){t.BodyPix="BodyPix",t.MediaPipeSelfieSegmentation="MediaPipeSelfieSegmentation"})(Lr||(Lr={}));var sk="blurred",ak="blurred-mask",ok="mask",ik="draw-image",$a={};function aa(t){if(typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&t instanceof OffscreenCanvas||typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)return function(e){if("offsetHeight"in e&&e.offsetHeight!==0&&"offsetWidth"in e&&e.offsetWidth!==0)return[e.offsetHeight,e.offsetWidth];if(e.height!=null&&e.width!=null)return[e.height,e.width];throw new Error("HTMLImageElement must have height and width attributes set.")}(t);if(typeof ImageData<"u"&&t instanceof ImageData)return[t.height,t.width];if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)return function(e){return e.hasAttribute("height")&&e.hasAttribute("width")?[e.height,e.width]:[e.videoHeight,e.videoWidth]}(t);if(t instanceof ye)return[t.shape[0],t.shape[1]];throw new Error("error: Unknown input type: "+t+".")}function pm(t){return $a[t]||($a[t]=function(){if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(0,0);throw new Error("Cannot create a canvas in this context")}()),$a[t]}function dm(t,e){var n=pm(e);return function(r,s){s.width=r.width,s.height=r.height,s.getContext("2d").putImageData(r,0,0)}(t,n),n}function es(t,e,n,r,s,a){return le(this,void 0,void 0,function(){var o,i,u,l;return ce(this,function(c){switch(c.label){case 0:return e instanceof ye?[4,qr(e)]:[3,2];case 1:o=c.sent(),i=aa(e),u=i[0],l=i[1],e=new ImageData(o,l,u),c.label=2;case 2:return e instanceof ImageData&&(e=dm(e,ik)),s==null||a==null?t.drawImage(e,n,r):t.drawImage(e,n,r,s,a),[2]}})})}function uk(t,e){return le(this,void 0,void 0,function(){var n,r,s;return ce(this,function(a){switch(a.label){case 0:return n=aa(t),r=n[0],s=n[1],e.width=s,e.height=r,[4,es(e.getContext("2d"),t,0,0,s,r)];case 1:return a.sent(),[2]}})})}function lk(t){var e=t.getContext("2d");e.scale(-1,1),e.translate(-t.width,0)}function Cu(t,e,n){return le(this,void 0,void 0,function(){return ce(this,function(r){switch(r.label){case 0:return t.globalCompositeOperation=n,[4,es(t,e,0,0)];case 1:return r.sent(),[2]}})})}function ck(t,e,n){return le(this,void 0,void 0,function(){var r,s,a,o,i,u,l,c;return ce(this,function(h){switch(h.label){case 0:for(r=t.getContext("2d"),s=0,a=5,o=1/(2*Math.PI*a*a),i=n<3?1:2,l=-n;l<=n;l+=i)for(c=-n;c<=n;c+=i)u=o*Math.exp(-(c*c+l*l)/(2*a*a)),s+=u;l=-n,h.label=1;case 1:if(!(l<=n))return[3,6];c=-n,h.label=2;case 2:return c<=n?(r.globalAlpha=o*Math.exp(-(c*c+l*l)/(2*a*a))/s*n,[4,es(r,e,c,l)]):[3,5];case 3:h.sent(),h.label=4;case 4:return c+=i,[3,2];case 5:return l+=i,[3,1];case 6:return r.globalAlpha=1,[2]}})})}function hk(t,e,n){return le(this,void 0,void 0,function(){var r,s,a,o;return ce(this,function(i){switch(i.label){case 0:return r=aa(t),s=r[0],a=r[1],o=n.getContext("2d"),n.width=a,n.height=s,o.clearRect(0,0,a,s),o.save(),/^((?!chrome|android).)*safari/i.test(navigator.userAgent)?[4,ck(n,t,e)]:[3,2];case 1:return i.sent(),[3,4];case 2:return o.filter="blur("+e+"px)",[4,es(o,t,0,0,a,s)];case 3:i.sent(),i.label=4;case 4:return o.restore(),[2]}})})}function mm(t,e,n){return le(this,void 0,void 0,function(){var r;return ce(this,function(s){switch(s.label){case 0:return r=pm(n),e!==0?[3,2]:[4,uk(t,r)];case 1:return s.sent(),[3,4];case 2:return[4,hk(t,e,r)];case 3:s.sent(),s.label=4;case 4:return[2,r]}})})}function fk(t,e,n,r,s,a){a===void 0&&(a={r:0,g:255,b:255,a:255});for(var o=-s;o<=s;o++)for(var i=-s;i<=s;i++)if(o!==0&&i!==0){var u=(e+o)*r+(n+i);t[4*u+0]=a.r,t[4*u+1]=a.g,t[4*u+2]=a.b,t[4*u+3]=a.a}}function pk(t,e,n,r,s,a,o){o===void 0&&(o=1);for(var i=0,u=-o;u<=o;u++)for(var l=-o;l<=o;l++)if(u!==0&&l!==0){var c=(e+u)*r+(n+l);(!s[t[4*c]]||t[4*c+3]<a)&&(i+=1)}return i>0}function dk(t,e,n,r,s,a){return e===void 0&&(e={r:0,g:0,b:0,a:0}),n===void 0&&(n={r:0,g:0,b:0,a:255}),r===void 0&&(r=!1),s===void 0&&(s=.5),a===void 0&&(a=Array.from(Array(256).keys())),le(this,void 0,void 0,function(){var o,i,u,l,c,h,p,m,b,v,S,x,O,E;return ce(this,function($){switch($.label){case 0:return(o=Array.isArray(t)?t:[t]).length===0?[2,null]:[4,Promise.all(o.map(function(I){return I.mask.toImageData()}))];case 1:for(i=$.sent(),u=i[0],l=u.width,c=u.height,h=new Uint8ClampedArray(l*c*4),p=Math.round(255*s),m=new Array(256).fill(!1),a.forEach(function(I){return m[I]=!0}),b=0;b<c;b++)for(v=0;v<l;v++)for(h[4*(S=b*l+v)+0]=n.r,h[4*S+1]=n.g,h[4*S+2]=n.b,h[4*S+3]=n.a,x=0,O=i;x<O.length;x++)E=O[x],m[E.data[4*S]]&&E.data[4*S+3]>=p&&(h[4*S]=e.r,h[4*S+1]=e.g,h[4*S+2]=e.b,h[4*S+3]=e.a,r&&b-1>=0&&b+1<c&&v-1>=0&&v+1<l&&pk(E.data,b,v,l,m,p)&&fk(h,b,v,l,1));return[2,new ImageData(h,l,c)]}})})}function mk(t,e,n){return le(this,void 0,void 0,function(){var r,s;return ce(this,function(a){switch(a.label){case 0:return[4,dk(t,{r:0,g:0,b:0,a:255},{r:0,g:0,b:0,a:0},!1,e)];case 1:return r=a.sent(),s=dm(r,ok),n===0?[2,s]:[2,mm(s,n,ak)]}})})}function gk(t,e,n,r,s,a,o){return r===void 0&&(r=.5),s===void 0&&(s=3),a===void 0&&(a=3),o===void 0&&(o=!1),le(this,void 0,void 0,function(){var i,u,l,c,h,p;return ce(this,function(m){switch(m.label){case 0:return[4,mm(e,s,sk)];case 1:return i=m.sent(),t.width=i.width,t.height=i.height,u=t.getContext("2d"),Array.isArray(n)&&n.length===0?(u.drawImage(i,0,0),[2]):[4,mk(n,r,a)];case 2:return l=m.sent(),u.save(),o&&lk(t),c=aa(e),h=c[0],p=c[1],[4,es(u,e,0,0,p,h)];case 3:return m.sent(),[4,Cu(u,l,"destination-in")];case 4:return m.sent(),[4,Cu(u,i,"destination-over")];case 5:return m.sent(),u.restore(),[2]}})})}var gm,ym,Zn,bm,wm,vm;({camera:bm}=tg);gm="video";Zn=0;vm=.5;ym=20;wm=3;var yk={setup:()=>{var t,e,n,r,s,a,o,i,u,l,c,h,p,m,b,v,S;return S=tn(),i=tn(),h=tn(),a=tn(localStorage.美颜!==void 0?localStorage.美颜-0:0),s=tn(localStorage.背景!==void 0?localStorage.背景-0:0),p=tn(localStorage.人像镜像!==void 0?localStorage.人像镜像-0:0),l=tn(!1),m=void 0,o=void 0,Zn!==void 0&&window.cancelAnimationFrame(Zn),Zn=void 0,e=async x=>{for(var O,E;;){try{E=await eg(x)}catch($){O=$,console.error(x,O),l.value="请授权"+{audio:"麦克风",video:"摄像头"}[x],await sg(1e3);continue}return l.value=!1,E}},b=async()=>{var x,O;m===void 0&&(x=Lr.MediaPipeSelfieSegmentation,O={runtime:"mediapipe",solutionPath:"https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation@"+SE,modelType:"general"},m=await rk(x,O))},n=async()=>{var x;l.value="加载中...";try{await b(),l.value=!1}catch(O){x=O,console.error(x),l.value="加载失败"}},u=async()=>{var x,O,E,$;try{S.value.readyState===4&&(i.value.width=S.value.videoWidth,i.value.height=S.value.videoHeight,x=p.value-0,s.value-0===0?($=x*i.value.width*-1,O=1-2*x,o.scale(O,1),o.drawImage(S.value,$,0)):(await b(),E=await m.segmentPeople(S.value),await gk(i.value,S.value,E,vm,ym,wm,x===1)))}catch{}Zn=window.requestAnimationFrame(u)},c=Gn.src==="camera",Um(async()=>{var x,O,E,$,I,F,L,M;await n(),ng(h.value),I=await e(gm),S.value.srcObject=I,$=i.value,o=$.getContext("2d"),await b(),c&&(F=await Jm(Gn.sys_audio),O=await e("audio"),E=O?O.getTracks():[],L=$.captureStream(30),M=L?L.getVideoTracks():[],x=I?I.getVideoTracks():[],x=x.concat(M),setTimeout(async()=>{var C;C=new MediaStream([...M,...Qm(E,F)]),qm(()=>{var j,V,G;G=!!Gn.video;for(j of x)j.enabled=G;Gn.audio;for(j of E)j.enabled=G;V=Gn.sys_audio;for(j of F)j.enabled=V}),(await Wm(()=>import("./u.js"),["u.js","..js","q.js","_.js","1.js","i.js","x.js","-.js","o.js","d.js","9.css","l.js"])).default(C,E)})),Zn=window.requestAnimationFrame(u)}),v=tn(outerWidth),r=()=>{localStorage.美颜=(a.value=!a.value)-0},t=()=>{localStorage.背景=(s.value=!s.value)-0},{v:S,cvs:i,main:h,size:v,mirror:p,beauty:a,background:s,err:l,w:x=>{localStorage.人像尺寸=x,v.value=x,bm.size(x)},turn:()=>{localStorage.人像镜像=(p.value=!p.value)-0},makeup:()=>{r(),localStorage.背景-0===1&&localStorage.美颜-0===1&&t()},blur:()=>{t(),localStorage.背景-0===1&&localStorage.美颜-0===1&&r()},x:()=>{Gn.video=""}}}};const Vn=t=>(Km("data-v-04af9a0f"),t=t(),Xm(),t),bk={key:0},wk={style:{display:"none"},autoplay:"",ref:"v"},vk={ref:"cvs"},Sk=Vn(()=>Ee("svg",{fill:"none",height:"11",viewBox:"0 0 10 11",width:"10",xmlns:"http://www.w3.org/2000/svg"},[Ee("circle",{cx:"5",cy:"5.5",opacity:"0.6",r:"4.5",stroke:"var(--c)"})],-1)),Nk=Vn(()=>Ee("svg",{class:"now",fill:"none",height:"24",viewBox:"0 0 24 24",width:"24",xmlns:"http://www.w3.org/2000/svg"},[Ee("circle",{cx:"12",cy:"12",fill:"var(--c)",opacity:"0.7",r:"4.5",stroke:"var(--c)"})],-1)),Tk=[Sk,Nk],Ek=Vn(()=>Ee("svg",{fill:"none",height:"15",viewBox:"0 0 14 15",width:"14",xmlns:"http://www.w3.org/2000/svg"},[Ee("circle",{cx:"7",cy:"7.5",opacity:"0.7",r:"6.5",stroke:"var(--c)"})],-1)),kk=Vn(()=>Ee("svg",{class:"now",fill:"none",height:"25",viewBox:"0 0 24 25",width:"24",xmlns:"http://www.w3.org/2000/svg"},[Ee("circle",{cx:"12",cy:"12.5",fill:"var(--c)",opacity:"0.7",r:"6.5",stroke:"var(--c)"})],-1)),_k=[Ek,kk],xk=Vn(()=>Ee("svg",{fill:"none",height:"25",viewBox:"0 0 24 25",width:"24",xmlns:"http://www.w3.org/2000/svg"},[Ee("g",{opacity:"0.6"},[Ee("path",{d:"M10 18.5V6.5L3 18.5H10Z",fill:"var(--c)",stroke:"var(--c)","stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"1.5"}),Ee("path",{d:"M14 18.5V6.5L21 18.5H14Z",stroke:"var(--c)","stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"1.5"})])],-1)),$k=[xk],Ak=Ym('<svg fill="none" height="25" viewBox="0 0 24 25" width="24" xmlns="http://www.w3.org/2000/svg" data-v-04af9a0f><g opacity="0.6" data-v-04af9a0f><circle cx="9" cy="10.5" r="1" fill="var(--c)" data-v-04af9a0f></circle><circle cx="15" cy="10.5" r="1" fill="var(--c)" data-v-04af9a0f></circle><path d="M19.5448 9.83333C19.8396 10.6674 20 11.565 20 12.5C20 16.9183 16.4183 20.5 12 20.5C7.58172 20.5 4 16.9183 4 12.5C4 8.08172 7.58172 4.5 12 4.5C12.935 4.5 13.8326 4.66041 14.6667 4.95522" stroke="var(--c)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-v-04af9a0f></path><path d="M15.2427 14.7427C13.5858 16.3995 10.8995 16.3995 9.24268 14.7427" stroke="var(--c)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-v-04af9a0f></path><path fill-rule="evenodd" clip-rule="evenodd" d="M17.5 4.5C18.0509 5.90137 18.5605 6.48753 20 7C18.5605 7.51247 18.0509 8.09863 17.5 9.5C16.9875 8.06046 16.4014 7.55095 15 7C16.4014 6.44905 16.9875 5.93954 17.5 4.5Z" fill="var(--c)" data-v-04af9a0f></path></g></svg>',1),Ik=[Ak],Ok=Vn(()=>Ee("svg",{fill:"none",height:"25",viewBox:"0 0 24 25",width:"24",xmlns:"http://www.w3.org/2000/svg"},[Ee("g",{opacity:"0.6"},[Ee("path",{d:"M19 5.5H12.875M19 5.5L5 19.5M19 5.5V11.625M5 19.5V13.375M5 19.5H11.125M5 13.375V10.75V8.5C5 6.84315 6.34315 5.5 8 5.5H10.25H12.875M5 13.375L12.875 5.5M19 11.625L11.125 19.5M19 11.625V14.25V16.5C19 18.1569 17.6569 19.5 16 19.5H13.75H11.125",stroke:"var(--c)","stroke-width":"1.5","stroke-linecap":"round","stroke-linejoin":"round"})])],-1)),Dk=[Ok],Fk=Vn(()=>Ee("svg",{fill:"none",height:"25",viewBox:"0 0 24 25",width:"24",xmlns:"http://www.w3.org/2000/svg"},[Ee("g",{opacity:"0.6"},[Ee("path",{d:"M16 8.5L8 16.5",stroke:"var(--c)","stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"1.5"}),Ee("path",{d:"M16 16.5L8 8.5",stroke:"var(--c)","stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"1.5"})])],-1)),Pk=[Fk];function Rk(t,e){return ga(),ma("main",{ref:"main",class:Hn({err:t.err!=!1})},[t.err?(ga(),ma("h3",bk,Hm(t.err),1)):(ga(),ma(Gm,{key:1},[Ee("video",wk,null,512),Ee("canvas",vk,null,512),Ee("nav",null,[Ee("a",{class:Hn(["circle",{now:t.size<=250}]),onClick:e[0]||(e[0]=n=>t.w(204))},Tk,2),Ee("a",{class:Hn(["circle",{now:t.size>=310}]),onClick:e[1]||(e[1]=n=>t.w(324))},_k,2),Ee("a",{class:Hn({mirror:t.mirror}),onClick:e[2]||(e[2]=(...n)=>t.turn&&t.turn(...n))},$k,2),Ee("a",{class:Hn({beauty:t.beauty}),onClick:e[3]||(e[3]=(...n)=>t.makeup&&t.makeup(...n))},Ik,2),Ee("a",{class:Hn({background:t.background}),onClick:e[4]||(e[4]=(...n)=>t.blur&&t.blur(...n))},Dk,2),Ee("a",{onClick:e[5]||(e[5]=(...n)=>t.x&&t.x(...n))},Pk)])],64))],2)}var Hk=Zm(yk,[["render",Rk],["__scopeId","data-v-04af9a0f"]]);export{Hk as default};
